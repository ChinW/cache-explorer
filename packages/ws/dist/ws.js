/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../shared/node_modules/balanced-match/index.js":
/*!******************************************************!*\
  !*** ../shared/node_modules/balanced-match/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/balanced-match/index.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/any.js":
/*!*********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/any.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function (promises) {\n    return any(promises);\n};\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/any.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/async.js":
/*!***********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/async.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar firstLineError;\ntry {throw new Error(); } catch (e) {firstLineError = e;}\nvar schedule = __webpack_require__(/*! ./schedule */ \"../shared/node_modules/bluebird/js/release/schedule.js\");\nvar Queue = __webpack_require__(/*! ./queue */ \"../shared/node_modules/bluebird/js/release/queue.js\");\n\nfunction Async() {\n    this._customScheduler = false;\n    this._isTickUsed = false;\n    this._lateQueue = new Queue(16);\n    this._normalQueue = new Queue(16);\n    this._haveDrainedQueues = false;\n    var self = this;\n    this.drainQueues = function () {\n        self._drainQueues();\n    };\n    this._schedule = schedule;\n}\n\nAsync.prototype.setScheduler = function(fn) {\n    var prev = this._schedule;\n    this._schedule = fn;\n    this._customScheduler = true;\n    return prev;\n};\n\nAsync.prototype.hasCustomScheduler = function() {\n    return this._customScheduler;\n};\n\nAsync.prototype.haveItemsQueued = function () {\n    return this._isTickUsed || this._haveDrainedQueues;\n};\n\n\nAsync.prototype.fatalError = function(e, isNode) {\n    if (isNode) {\n        process.stderr.write(\"Fatal \" + (e instanceof Error ? e.stack : e) +\n            \"\\n\");\n        process.exit(2);\n    } else {\n        this.throwLater(e);\n    }\n};\n\nAsync.prototype.throwLater = function(fn, arg) {\n    if (arguments.length === 1) {\n        arg = fn;\n        fn = function () { throw arg; };\n    }\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function() {\n            fn(arg);\n        }, 0);\n    } else try {\n        this._schedule(function() {\n            fn(arg);\n        });\n    } catch (e) {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n};\n\nfunction AsyncInvokeLater(fn, receiver, arg) {\n    this._lateQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncInvoke(fn, receiver, arg) {\n    this._normalQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncSettlePromises(promise) {\n    this._normalQueue._pushOne(promise);\n    this._queueTick();\n}\n\nAsync.prototype.invokeLater = AsyncInvokeLater;\nAsync.prototype.invoke = AsyncInvoke;\nAsync.prototype.settlePromises = AsyncSettlePromises;\n\n\nfunction _drainQueue(queue) {\n    while (queue.length() > 0) {\n        _drainQueueStep(queue);\n    }\n}\n\nfunction _drainQueueStep(queue) {\n    var fn = queue.shift();\n    if (typeof fn !== \"function\") {\n        fn._settlePromises();\n    } else {\n        var receiver = queue.shift();\n        var arg = queue.shift();\n        fn.call(receiver, arg);\n    }\n}\n\nAsync.prototype._drainQueues = function () {\n    _drainQueue(this._normalQueue);\n    this._reset();\n    this._haveDrainedQueues = true;\n    _drainQueue(this._lateQueue);\n};\n\nAsync.prototype._queueTick = function () {\n    if (!this._isTickUsed) {\n        this._isTickUsed = true;\n        this._schedule(this.drainQueues);\n    }\n};\n\nAsync.prototype._reset = function () {\n    this._isTickUsed = false;\n};\n\nmodule.exports = Async;\nmodule.exports.firstLineError = firstLineError;\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/async.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/bind.js":
/*!**********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/bind.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {\nvar calledBind = false;\nvar rejectThis = function(_, e) {\n    this._reject(e);\n};\n\nvar targetRejected = function(e, context) {\n    context.promiseRejectionQueued = true;\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n};\n\nvar bindingResolved = function(thisArg, context) {\n    if (((this._bitField & 50397184) === 0)) {\n        this._resolveCallback(context.target);\n    }\n};\n\nvar bindingRejected = function(e, context) {\n    if (!context.promiseRejectionQueued) this._reject(e);\n};\n\nPromise.prototype.bind = function (thisArg) {\n    if (!calledBind) {\n        calledBind = true;\n        Promise.prototype._propagateFrom = debug.propagateFromFunction();\n        Promise.prototype._boundValue = debug.boundValueFunction();\n    }\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 1);\n    var target = this._target();\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        var context = {\n            promiseRejectionQueued: false,\n            promise: ret,\n            target: target,\n            bindingPromise: maybePromise\n        };\n        target._then(INTERNAL, targetRejected, undefined, ret, context);\n        maybePromise._then(\n            bindingResolved, bindingRejected, undefined, ret, context);\n        ret._setOnCancel(maybePromise);\n    } else {\n        ret._resolveCallback(target);\n    }\n    return ret;\n};\n\nPromise.prototype._setBoundTo = function (obj) {\n    if (obj !== undefined) {\n        this._bitField = this._bitField | 2097152;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~2097152);\n    }\n};\n\nPromise.prototype._isBound = function () {\n    return (this._bitField & 2097152) === 2097152;\n};\n\nPromise.bind = function (thisArg, value) {\n    return Promise.resolve(value).bind(thisArg);\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/bind.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/bluebird.js":
/*!**************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/bluebird.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict() {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nvar bluebird = __webpack_require__(/*! ./promise */ \"../shared/node_modules/bluebird/js/release/promise.js\")();\nbluebird.noConflict = noConflict;\nmodule.exports = bluebird;\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/bluebird.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/call_get.js":
/*!**************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/call_get.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nvar getMethodCaller;\nvar getGetter;\nif (true) {\nvar makeMethodCaller = function (methodName) {\n    return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n};\n\nvar makeGetter = function (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n};\n\nvar getCompiled = function(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n};\n\ngetMethodCaller = function(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n};\n\ngetGetter = function(name) {\n    return getCompiled(name, makeGetter, getterCache);\n};\n}\n\nfunction ensureMethod(obj, methodName) {\n    var fn;\n    if (obj != null) fn = obj[methodName];\n    if (typeof fn !== \"function\") {\n        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n            util.toString(methodName) + \"'\";\n        throw new Promise.TypeError(message);\n    }\n    return fn;\n}\n\nfunction caller(obj) {\n    var methodName = this.pop();\n    var fn = ensureMethod(obj, methodName);\n    return fn.apply(obj, this);\n}\nPromise.prototype.call = function (methodName) {\n    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n    if (true) {\n        if (canEvaluate) {\n            var maybeCaller = getMethodCaller(methodName);\n            if (maybeCaller !== null) {\n                return this._then(\n                    maybeCaller, undefined, undefined, args, undefined);\n            }\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, undefined, undefined, args, undefined);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    var index = +this;\n    if (index < 0) index = Math.max(0, index + obj.length);\n    return obj[index];\n}\nPromise.prototype.get = function (propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, undefined, undefined, propertyName, undefined);\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/call_get.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/cancel.js":
/*!************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/cancel.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, PromiseArray, apiRejection, debug) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nPromise.prototype[\"break\"] = Promise.prototype.cancel = function() {\n    if (!debug.cancellation()) return this._warn(\"cancellation is disabled\");\n\n    var promise = this;\n    var child = promise;\n    while (promise._isCancellable()) {\n        if (!promise._cancelBy(child)) {\n            if (child._isFollowing()) {\n                child._followee().cancel();\n            } else {\n                child._cancelBranched();\n            }\n            break;\n        }\n\n        var parent = promise._cancellationParent;\n        if (parent == null || !parent._isCancellable()) {\n            if (promise._isFollowing()) {\n                promise._followee().cancel();\n            } else {\n                promise._cancelBranched();\n            }\n            break;\n        } else {\n            if (promise._isFollowing()) promise._followee().cancel();\n            promise._setWillBeCancelled();\n            child = promise;\n            promise = parent;\n        }\n    }\n};\n\nPromise.prototype._branchHasCancelled = function() {\n    this._branchesRemainingToCancel--;\n};\n\nPromise.prototype._enoughBranchesHaveCancelled = function() {\n    return this._branchesRemainingToCancel === undefined ||\n           this._branchesRemainingToCancel <= 0;\n};\n\nPromise.prototype._cancelBy = function(canceller) {\n    if (canceller === this) {\n        this._branchesRemainingToCancel = 0;\n        this._invokeOnCancel();\n        return true;\n    } else {\n        this._branchHasCancelled();\n        if (this._enoughBranchesHaveCancelled()) {\n            this._invokeOnCancel();\n            return true;\n        }\n    }\n    return false;\n};\n\nPromise.prototype._cancelBranched = function() {\n    if (this._enoughBranchesHaveCancelled()) {\n        this._cancel();\n    }\n};\n\nPromise.prototype._cancel = function() {\n    if (!this._isCancellable()) return;\n    this._setCancelled();\n    async.invoke(this._cancelPromises, this, undefined);\n};\n\nPromise.prototype._cancelPromises = function() {\n    if (this._length() > 0) this._settlePromises();\n};\n\nPromise.prototype._unsetOnCancel = function() {\n    this._onCancelField = undefined;\n};\n\nPromise.prototype._isCancellable = function() {\n    return this.isPending() && !this._isCancelled();\n};\n\nPromise.prototype.isCancellable = function() {\n    return this.isPending() && !this.isCancelled();\n};\n\nPromise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {\n    if (util.isArray(onCancelCallback)) {\n        for (var i = 0; i < onCancelCallback.length; ++i) {\n            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);\n        }\n    } else if (onCancelCallback !== undefined) {\n        if (typeof onCancelCallback === \"function\") {\n            if (!internalOnly) {\n                var e = tryCatch(onCancelCallback).call(this._boundValue());\n                if (e === errorObj) {\n                    this._attachExtraTrace(e.e);\n                    async.throwLater(e.e);\n                }\n            }\n        } else {\n            onCancelCallback._resultCancelled(this);\n        }\n    }\n};\n\nPromise.prototype._invokeOnCancel = function() {\n    var onCancelCallback = this._onCancel();\n    this._unsetOnCancel();\n    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);\n};\n\nPromise.prototype._invokeInternalOnCancel = function() {\n    if (this._isCancellable()) {\n        this._doInvokeOnCancel(this._onCancel(), true);\n        this._unsetOnCancel();\n    }\n};\n\nPromise.prototype._resultCancelled = function() {\n    this.cancel();\n};\n\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/cancel.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/catch_filter.js":
/*!******************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/catch_filter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(NEXT_FILTER) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar getKeys = __webpack_require__(/*! ./es5 */ \"../shared/node_modules/bluebird/js/release/es5.js\").keys;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction catchFilter(instances, cb, promise) {\n    return function(e) {\n        var boundTo = promise._boundValue();\n        predicateLoop: for (var i = 0; i < instances.length; ++i) {\n            var item = instances[i];\n\n            if (item === Error ||\n                (item != null && item.prototype instanceof Error)) {\n                if (e instanceof item) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (typeof item === \"function\") {\n                var matchesPredicate = tryCatch(item).call(boundTo, e);\n                if (matchesPredicate === errorObj) {\n                    return matchesPredicate;\n                } else if (matchesPredicate) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (util.isObject(e)) {\n                var keys = getKeys(item);\n                for (var j = 0; j < keys.length; ++j) {\n                    var key = keys[j];\n                    if (item[key] != e[key]) {\n                        continue predicateLoop;\n                    }\n                }\n                return tryCatch(cb).call(boundTo, e);\n            }\n        }\n        return NEXT_FILTER;\n    };\n}\n\nreturn catchFilter;\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/catch_filter.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/context.js":
/*!*************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/context.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar longStackTraces = false;\nvar contextStack = [];\n\nPromise.prototype._promiseCreated = function() {};\nPromise.prototype._pushContext = function() {};\nPromise.prototype._popContext = function() {return null;};\nPromise._peekContext = Promise.prototype._peekContext = function() {};\n\nfunction Context() {\n    this._trace = new Context.CapturedTrace(peekContext());\n}\nContext.prototype._pushContext = function () {\n    if (this._trace !== undefined) {\n        this._trace._promiseCreated = null;\n        contextStack.push(this._trace);\n    }\n};\n\nContext.prototype._popContext = function () {\n    if (this._trace !== undefined) {\n        var trace = contextStack.pop();\n        var ret = trace._promiseCreated;\n        trace._promiseCreated = null;\n        return ret;\n    }\n    return null;\n};\n\nfunction createContext() {\n    if (longStackTraces) return new Context();\n}\n\nfunction peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return undefined;\n}\nContext.CapturedTrace = null;\nContext.create = createContext;\nContext.deactivateLongStackTraces = function() {};\nContext.activateLongStackTraces = function() {\n    var Promise_pushContext = Promise.prototype._pushContext;\n    var Promise_popContext = Promise.prototype._popContext;\n    var Promise_PeekContext = Promise._peekContext;\n    var Promise_peekContext = Promise.prototype._peekContext;\n    var Promise_promiseCreated = Promise.prototype._promiseCreated;\n    Context.deactivateLongStackTraces = function() {\n        Promise.prototype._pushContext = Promise_pushContext;\n        Promise.prototype._popContext = Promise_popContext;\n        Promise._peekContext = Promise_PeekContext;\n        Promise.prototype._peekContext = Promise_peekContext;\n        Promise.prototype._promiseCreated = Promise_promiseCreated;\n        longStackTraces = false;\n    };\n    longStackTraces = true;\n    Promise.prototype._pushContext = Context.prototype._pushContext;\n    Promise.prototype._popContext = Context.prototype._popContext;\n    Promise._peekContext = Promise.prototype._peekContext = peekContext;\n    Promise.prototype._promiseCreated = function() {\n        var ctx = this._peekContext();\n        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;\n    };\n};\nreturn Context;\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/context.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/debuggability.js":
/*!*******************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/debuggability.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, Context,\n    enableAsyncHooks, disableAsyncHooks) {\nvar async = Promise._async;\nvar Warning = __webpack_require__(/*! ./errors */ \"../shared/node_modules/bluebird/js/release/errors.js\").Warning;\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar es5 = __webpack_require__(/*! ./es5 */ \"../shared/node_modules/bluebird/js/release/es5.js\");\nvar canAttachTrace = util.canAttachTrace;\nvar unhandledRejectionHandled;\nvar possiblyUnhandledRejection;\nvar bluebirdFramePattern =\n    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](release|debug|instrumented)/;\nvar nodeFramePattern = /\\((?:timers\\.js):\\d+:\\d+\\)/;\nvar parseLinePattern = /[\\/<\\(](.+?):(\\d+):(\\d+)\\)?\\s*$/;\nvar stackFramePattern = null;\nvar formatStack = null;\nvar indentStackFrames = false;\nvar printWarning;\nvar debugging = !!(util.env(\"BLUEBIRD_DEBUG\") != 0 &&\n                        ( false ||\n                         util.env(\"BLUEBIRD_DEBUG\") ||\n                         util.env(\"NODE_ENV\") === \"development\"));\n\nvar warnings = !!(util.env(\"BLUEBIRD_WARNINGS\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_WARNINGS\")));\n\nvar longStackTraces = !!(util.env(\"BLUEBIRD_LONG_STACK_TRACES\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_LONG_STACK_TRACES\")));\n\nvar wForgottenReturn = util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\") != 0 &&\n    (warnings || !!util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\"));\n\nvar deferUnhandledRejectionCheck;\n(function() {\n    var promises = [];\n\n    function unhandledRejectionCheck() {\n        for (var i = 0; i < promises.length; ++i) {\n            promises[i]._notifyUnhandledRejection();\n        }\n        unhandledRejectionClear();\n    }\n\n    function unhandledRejectionClear() {\n        promises.length = 0;\n    }\n\n    deferUnhandledRejectionCheck = function(promise) {\n        promises.push(promise);\n        setTimeout(unhandledRejectionCheck, 1);\n    };\n\n    es5.defineProperty(Promise, \"_unhandledRejectionCheck\", {\n        value: unhandledRejectionCheck\n    });\n    es5.defineProperty(Promise, \"_unhandledRejectionClear\", {\n        value: unhandledRejectionClear\n    });\n})();\n\nPromise.prototype.suppressUnhandledRejections = function() {\n    var target = this._target();\n    target._bitField = ((target._bitField & (~1048576)) |\n                      524288);\n};\n\nPromise.prototype._ensurePossibleRejectionHandled = function () {\n    if ((this._bitField & 524288) !== 0) return;\n    this._setRejectionIsUnhandled();\n    deferUnhandledRejectionCheck(this);\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    fireRejectionEvent(\"rejectionHandled\",\n                                  unhandledRejectionHandled, undefined, this);\n};\n\nPromise.prototype._setReturnedNonUndefined = function() {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._returnedNonUndefined = function() {\n    return (this._bitField & 268435456) !== 0;\n};\n\nPromise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._settledValue();\n        this._setUnhandledRejectionIsNotified();\n        fireRejectionEvent(\"unhandledRejection\",\n                                      possiblyUnhandledRejection, reason, this);\n    }\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 262144;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & (~262144);\n};\n\nPromise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 262144) > 0;\n};\n\nPromise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 1048576;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & (~1048576);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._warn = function(message, shouldUseOwnTrace, promise) {\n    return warn(message, shouldUseOwnTrace, promise || this);\n};\n\nPromise.onPossiblyUnhandledRejection = function (fn) {\n    var context = Promise._getContext();\n    possiblyUnhandledRejection = util.contextBind(context, fn);\n};\n\nPromise.onUnhandledRejectionHandled = function (fn) {\n    var context = Promise._getContext();\n    unhandledRejectionHandled = util.contextBind(context, fn);\n};\n\nvar disableLongStackTraces = function() {};\nPromise.longStackTraces = function () {\n    if (async.haveItemsQueued() && !config.longStackTraces) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (!config.longStackTraces && longStackTracesIsSupported()) {\n        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;\n        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;\n        var Promise_dereferenceTrace = Promise.prototype._dereferenceTrace;\n        config.longStackTraces = true;\n        disableLongStackTraces = function() {\n            if (async.haveItemsQueued() && !config.longStackTraces) {\n                throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n            }\n            Promise.prototype._captureStackTrace = Promise_captureStackTrace;\n            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;\n            Promise.prototype._dereferenceTrace = Promise_dereferenceTrace;\n            Context.deactivateLongStackTraces();\n            config.longStackTraces = false;\n        };\n        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;\n        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;\n        Promise.prototype._dereferenceTrace = longStackTracesDereferenceTrace;\n        Context.activateLongStackTraces();\n    }\n};\n\nPromise.hasLongStackTraces = function () {\n    return config.longStackTraces && longStackTracesIsSupported();\n};\n\n\nvar legacyHandlers = {\n    unhandledrejection: {\n        before: function() {\n            var ret = util.global.onunhandledrejection;\n            util.global.onunhandledrejection = null;\n            return ret;\n        },\n        after: function(fn) {\n            util.global.onunhandledrejection = fn;\n        }\n    },\n    rejectionhandled: {\n        before: function() {\n            var ret = util.global.onrejectionhandled;\n            util.global.onrejectionhandled = null;\n            return ret;\n        },\n        after: function(fn) {\n            util.global.onrejectionhandled = fn;\n        }\n    }\n};\n\nvar fireDomEvent = (function() {\n    var dispatch = function(legacy, e) {\n        if (legacy) {\n            var fn;\n            try {\n                fn = legacy.before();\n                return !util.global.dispatchEvent(e);\n            } finally {\n                legacy.after(fn);\n            }\n        } else {\n            return !util.global.dispatchEvent(e);\n        }\n    };\n    try {\n        if (typeof CustomEvent === \"function\") {\n            var event = new CustomEvent(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                name = name.toLowerCase();\n                var eventData = {\n                    detail: event,\n                    cancelable: true\n                };\n                var domEvent = new CustomEvent(name, eventData);\n                es5.defineProperty(\n                    domEvent, \"promise\", {value: event.promise});\n                es5.defineProperty(\n                    domEvent, \"reason\", {value: event.reason});\n\n                return dispatch(legacyHandlers[name], domEvent);\n            };\n        } else if (typeof Event === \"function\") {\n            var event = new Event(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                name = name.toLowerCase();\n                var domEvent = new Event(name, {\n                    cancelable: true\n                });\n                domEvent.detail = event;\n                es5.defineProperty(domEvent, \"promise\", {value: event.promise});\n                es5.defineProperty(domEvent, \"reason\", {value: event.reason});\n                return dispatch(legacyHandlers[name], domEvent);\n            };\n        } else {\n            var event = document.createEvent(\"CustomEvent\");\n            event.initCustomEvent(\"testingtheevent\", false, true, {});\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                name = name.toLowerCase();\n                var domEvent = document.createEvent(\"CustomEvent\");\n                domEvent.initCustomEvent(name, false, true,\n                    event);\n                return dispatch(legacyHandlers[name], domEvent);\n            };\n        }\n    } catch (e) {}\n    return function() {\n        return false;\n    };\n})();\n\nvar fireGlobalEvent = (function() {\n    if (util.isNode) {\n        return function() {\n            return process.emit.apply(process, arguments);\n        };\n    } else {\n        if (!util.global) {\n            return function() {\n                return false;\n            };\n        }\n        return function(name) {\n            var methodName = \"on\" + name.toLowerCase();\n            var method = util.global[methodName];\n            if (!method) return false;\n            method.apply(util.global, [].slice.call(arguments, 1));\n            return true;\n        };\n    }\n})();\n\nfunction generatePromiseLifecycleEventObject(name, promise) {\n    return {promise: promise};\n}\n\nvar eventToObjectGenerator = {\n    promiseCreated: generatePromiseLifecycleEventObject,\n    promiseFulfilled: generatePromiseLifecycleEventObject,\n    promiseRejected: generatePromiseLifecycleEventObject,\n    promiseResolved: generatePromiseLifecycleEventObject,\n    promiseCancelled: generatePromiseLifecycleEventObject,\n    promiseChained: function(name, promise, child) {\n        return {promise: promise, child: child};\n    },\n    warning: function(name, warning) {\n        return {warning: warning};\n    },\n    unhandledRejection: function (name, reason, promise) {\n        return {reason: reason, promise: promise};\n    },\n    rejectionHandled: generatePromiseLifecycleEventObject\n};\n\nvar activeFireEvent = function (name) {\n    var globalEventFired = false;\n    try {\n        globalEventFired = fireGlobalEvent.apply(null, arguments);\n    } catch (e) {\n        async.throwLater(e);\n        globalEventFired = true;\n    }\n\n    var domEventFired = false;\n    try {\n        domEventFired = fireDomEvent(name,\n                    eventToObjectGenerator[name].apply(null, arguments));\n    } catch (e) {\n        async.throwLater(e);\n        domEventFired = true;\n    }\n\n    return domEventFired || globalEventFired;\n};\n\nPromise.config = function(opts) {\n    opts = Object(opts);\n    if (\"longStackTraces\" in opts) {\n        if (opts.longStackTraces) {\n            Promise.longStackTraces();\n        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {\n            disableLongStackTraces();\n        }\n    }\n    if (\"warnings\" in opts) {\n        var warningsOption = opts.warnings;\n        config.warnings = !!warningsOption;\n        wForgottenReturn = config.warnings;\n\n        if (util.isObject(warningsOption)) {\n            if (\"wForgottenReturn\" in warningsOption) {\n                wForgottenReturn = !!warningsOption.wForgottenReturn;\n            }\n        }\n    }\n    if (\"cancellation\" in opts && opts.cancellation && !config.cancellation) {\n        if (async.haveItemsQueued()) {\n            throw new Error(\n                \"cannot enable cancellation after promises are in use\");\n        }\n        Promise.prototype._clearCancellationData =\n            cancellationClearCancellationData;\n        Promise.prototype._propagateFrom = cancellationPropagateFrom;\n        Promise.prototype._onCancel = cancellationOnCancel;\n        Promise.prototype._setOnCancel = cancellationSetOnCancel;\n        Promise.prototype._attachCancellationCallback =\n            cancellationAttachCancellationCallback;\n        Promise.prototype._execute = cancellationExecute;\n        propagateFromFunction = cancellationPropagateFrom;\n        config.cancellation = true;\n    }\n    if (\"monitoring\" in opts) {\n        if (opts.monitoring && !config.monitoring) {\n            config.monitoring = true;\n            Promise.prototype._fireEvent = activeFireEvent;\n        } else if (!opts.monitoring && config.monitoring) {\n            config.monitoring = false;\n            Promise.prototype._fireEvent = defaultFireEvent;\n        }\n    }\n    if (\"asyncHooks\" in opts && util.nodeSupportsAsyncResource) {\n        var prev = config.asyncHooks;\n        var cur = !!opts.asyncHooks;\n        if (prev !== cur) {\n            config.asyncHooks = cur;\n            if (cur) {\n                enableAsyncHooks();\n            } else {\n                disableAsyncHooks();\n            }\n        }\n    }\n    return Promise;\n};\n\nfunction defaultFireEvent() { return false; }\n\nPromise.prototype._fireEvent = defaultFireEvent;\nPromise.prototype._execute = function(executor, resolve, reject) {\n    try {\n        executor(resolve, reject);\n    } catch (e) {\n        return e;\n    }\n};\nPromise.prototype._onCancel = function () {};\nPromise.prototype._setOnCancel = function (handler) { ; };\nPromise.prototype._attachCancellationCallback = function(onCancel) {\n    ;\n};\nPromise.prototype._captureStackTrace = function () {};\nPromise.prototype._attachExtraTrace = function () {};\nPromise.prototype._dereferenceTrace = function () {};\nPromise.prototype._clearCancellationData = function() {};\nPromise.prototype._propagateFrom = function (parent, flags) {\n    ;\n    ;\n};\n\nfunction cancellationExecute(executor, resolve, reject) {\n    var promise = this;\n    try {\n        executor(resolve, reject, function(onCancel) {\n            if (typeof onCancel !== \"function\") {\n                throw new TypeError(\"onCancel must be a function, got: \" +\n                                    util.toString(onCancel));\n            }\n            promise._attachCancellationCallback(onCancel);\n        });\n    } catch (e) {\n        return e;\n    }\n}\n\nfunction cancellationAttachCancellationCallback(onCancel) {\n    if (!this._isCancellable()) return this;\n\n    var previousOnCancel = this._onCancel();\n    if (previousOnCancel !== undefined) {\n        if (util.isArray(previousOnCancel)) {\n            previousOnCancel.push(onCancel);\n        } else {\n            this._setOnCancel([previousOnCancel, onCancel]);\n        }\n    } else {\n        this._setOnCancel(onCancel);\n    }\n}\n\nfunction cancellationOnCancel() {\n    return this._onCancelField;\n}\n\nfunction cancellationSetOnCancel(onCancel) {\n    this._onCancelField = onCancel;\n}\n\nfunction cancellationClearCancellationData() {\n    this._cancellationParent = undefined;\n    this._onCancelField = undefined;\n}\n\nfunction cancellationPropagateFrom(parent, flags) {\n    if ((flags & 1) !== 0) {\n        this._cancellationParent = parent;\n        var branchesRemainingToCancel = parent._branchesRemainingToCancel;\n        if (branchesRemainingToCancel === undefined) {\n            branchesRemainingToCancel = 0;\n        }\n        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;\n    }\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\n\nfunction bindingPropagateFrom(parent, flags) {\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\nvar propagateFromFunction = bindingPropagateFrom;\n\nfunction boundValueFunction() {\n    var ret = this._boundTo;\n    if (ret !== undefined) {\n        if (ret instanceof Promise) {\n            if (ret.isFulfilled()) {\n                return ret.value();\n            } else {\n                return undefined;\n            }\n        }\n    }\n    return ret;\n}\n\nfunction longStackTracesCaptureStackTrace() {\n    this._trace = new CapturedTrace(this._peekContext());\n}\n\nfunction longStackTracesAttachExtraTrace(error, ignoreSelf) {\n    if (canAttachTrace(error)) {\n        var trace = this._trace;\n        if (trace !== undefined) {\n            if (ignoreSelf) trace = trace._parent;\n        }\n        if (trace !== undefined) {\n            trace.attachExtraTrace(error);\n        } else if (!error.__stackCleaned__) {\n            var parsed = parseStackAndMessage(error);\n            util.notEnumerableProp(error, \"stack\",\n                parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        }\n    }\n}\n\nfunction longStackTracesDereferenceTrace() {\n    this._trace = undefined;\n}\n\nfunction checkForgottenReturns(returnValue, promiseCreated, name, promise,\n                               parent) {\n    if (returnValue === undefined && promiseCreated !== null &&\n        wForgottenReturn) {\n        if (parent !== undefined && parent._returnedNonUndefined()) return;\n        if ((promise._bitField & 65535) === 0) return;\n\n        if (name) name = name + \" \";\n        var handlerLine = \"\";\n        var creatorLine = \"\";\n        if (promiseCreated._trace) {\n            var traceLines = promiseCreated._trace.stack.split(\"\\n\");\n            var stack = cleanStack(traceLines);\n            for (var i = stack.length - 1; i >= 0; --i) {\n                var line = stack[i];\n                if (!nodeFramePattern.test(line)) {\n                    var lineMatches = line.match(parseLinePattern);\n                    if (lineMatches) {\n                        handlerLine  = \"at \" + lineMatches[1] +\n                            \":\" + lineMatches[2] + \":\" + lineMatches[3] + \" \";\n                    }\n                    break;\n                }\n            }\n\n            if (stack.length > 0) {\n                var firstUserLine = stack[0];\n                for (var i = 0; i < traceLines.length; ++i) {\n\n                    if (traceLines[i] === firstUserLine) {\n                        if (i > 0) {\n                            creatorLine = \"\\n\" + traceLines[i - 1];\n                        }\n                        break;\n                    }\n                }\n\n            }\n        }\n        var msg = \"a promise was created in a \" + name +\n            \"handler \" + handlerLine + \"but was not returned from it, \" +\n            \"see http://goo.gl/rRqMUw\" +\n            creatorLine;\n        promise._warn(msg, true, promiseCreated);\n    }\n}\n\nfunction deprecated(name, replacement) {\n    var message = name +\n        \" is deprecated and will be removed in a future version.\";\n    if (replacement) message += \" Use \" + replacement + \" instead.\";\n    return warn(message);\n}\n\nfunction warn(message, shouldUseOwnTrace, promise) {\n    if (!config.warnings) return;\n    var warning = new Warning(message);\n    var ctx;\n    if (shouldUseOwnTrace) {\n        promise._attachExtraTrace(warning);\n    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\n        ctx.attachExtraTrace(warning);\n    } else {\n        var parsed = parseStackAndMessage(warning);\n        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n\n    if (!activeFireEvent(\"warning\", warning)) {\n        formatAndLogError(warning, \"\", true);\n    }\n}\n\nfunction reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n        stacks[i].push(\"From previous event:\");\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n}\n\nfunction removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n        if (stacks[i].length === 0 ||\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n            stacks.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n        var prev = stacks[i];\n        var currentLastIndex = current.length - 1;\n        var currentLastLine = current[currentLastIndex];\n        var commonRootMeetPoint = -1;\n\n        for (var j = prev.length - 1; j >= 0; --j) {\n            if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n            }\n        }\n\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\n            var line = prev[j];\n            if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n            } else {\n                break;\n            }\n        }\n        current = prev;\n    }\n}\n\nfunction cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        var isTraceLine = \"    (No stack trace)\" === line ||\n            stackFramePattern.test(line);\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\n        if (isTraceLine && !isInternalFrame) {\n            if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n            }\n            ret.push(line);\n        }\n    }\n    return ret;\n}\n\nfunction stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n            break;\n        }\n    }\n    if (i > 0 && error.name != \"SyntaxError\") {\n        stack = stack.slice(i);\n    }\n    return stack;\n}\n\nfunction parseStackAndMessage(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0\n                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n        message: message,\n        stack: error.name == \"SyntaxError\" ? stack : cleanStack(stack)\n    };\n}\n\nfunction formatAndLogError(error, title, isSoft) {\n    if (typeof console !== \"undefined\") {\n        var message;\n        if (util.isObject(error)) {\n            var stack = error.stack;\n            message = title + formatStack(stack, error);\n        } else {\n            message = title + String(error);\n        }\n        if (typeof printWarning === \"function\") {\n            printWarning(message, isSoft);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n}\n\nfunction fireRejectionEvent(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n        if (typeof localHandler === \"function\") {\n            localEventFired = true;\n            if (name === \"rejectionHandled\") {\n                localHandler(promise);\n            } else {\n                localHandler(reason, promise);\n            }\n        }\n    } catch (e) {\n        async.throwLater(e);\n    }\n\n    if (name === \"unhandledRejection\") {\n        if (!activeFireEvent(name, reason, promise) && !localEventFired) {\n            formatAndLogError(reason, \"Unhandled rejection \");\n        }\n    } else {\n        activeFireEvent(name, promise);\n    }\n}\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj && typeof obj.toString === \"function\"\n            ? obj.toString() : util.toString(obj);\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nfunction longStackTracesIsSupported() {\n    return typeof captureStackTrace === \"function\";\n}\n\nvar shouldIgnore = function() { return false; };\nvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\nfunction parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n        return {\n            fileName: matches[1],\n            line: parseInt(matches[2], 10)\n        };\n    }\n}\n\nfunction setBounds(firstLineError, lastLineError) {\n    if (!longStackTracesIsSupported()) return;\n    var firstStackLines = (firstLineError.stack || \"\").split(\"\\n\");\n    var lastStackLines = (lastLineError.stack || \"\").split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n        var result = parseLineInfo(firstStackLines[i]);\n        if (result) {\n            firstFileName = result.fileName;\n            firstIndex = result.line;\n            break;\n        }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n        var result = parseLineInfo(lastStackLines[i]);\n        if (result) {\n            lastFileName = result.fileName;\n            lastIndex = result.line;\n            break;\n        }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n        return;\n    }\n\n    shouldIgnore = function(line) {\n        if (bluebirdFramePattern.test(line)) return true;\n        var info = parseLineInfo(line);\n        if (info) {\n            if (info.fileName === firstFileName &&\n                (firstIndex <= info.line && info.line <= lastIndex)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n\nfunction CapturedTrace(parent) {\n    this._parent = parent;\n    this._promisesCreated = 0;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n}\nutil.inherits(CapturedTrace, Error);\nContext.CapturedTrace = CapturedTrace;\n\nCapturedTrace.prototype.uncycle = function() {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n\n    for (var i = 0, node = this; node !== undefined; ++i) {\n        nodes.push(node);\n        node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n        var stack = nodes[i].stack;\n        if (stackToIndex[stack] === undefined) {\n            stackToIndex[stack] = i;\n        }\n    }\n    for (var i = 0; i < length; ++i) {\n        var currentStack = nodes[i].stack;\n        var index = stackToIndex[currentStack];\n        if (index !== undefined && index !== i) {\n            if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n            }\n            nodes[i]._parent = undefined;\n            nodes[i]._length = 1;\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n            if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n                cycleEdgeNode._parent.uncycle();\n                cycleEdgeNode._length =\n                    cycleEdgeNode._parent._length + 1;\n            } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n            }\n            var currentChildLength = cycleEdgeNode._length + 1;\n            for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n            }\n            return;\n        }\n    }\n};\n\nCapturedTrace.prototype.attachExtraTrace = function(error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n\n    var trace = this;\n    while (trace !== undefined) {\n        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n        trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n};\n\nvar captureStackTrace = (function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if (error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        Error.stackTraceLimit += 6;\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        var captureStackTrace = Error.captureStackTrace;\n\n        shouldIgnore = function(line) {\n            return bluebirdFramePattern.test(line);\n        };\n        return function(receiver, ignoreUntil) {\n            Error.stackTraceLimit += 6;\n            captureStackTrace(receiver, ignoreUntil);\n            Error.stackTraceLimit -= 6;\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n        stackFramePattern = /@/;\n        formatStack = v8stackFormatter;\n        indentStackFrames = true;\n        return function captureStackTrace(o) {\n            o.stack = new Error().stack;\n        };\n    }\n\n    var hasStackAfterThrow;\n    try { throw new Error(); }\n    catch(e) {\n        hasStackAfterThrow = (\"stack\" in e);\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow &&\n        typeof Error.stackTraceLimit === \"number\") {\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        return function captureStackTrace(o) {\n            Error.stackTraceLimit += 6;\n            try { throw new Error(); }\n            catch(e) { o.stack = e.stack; }\n            Error.stackTraceLimit -= 6;\n        };\n    }\n\n    formatStack = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if ((typeof error === \"object\" ||\n            typeof error === \"function\") &&\n            error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    return null;\n\n})([]);\n\nif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    printWarning = function (message) {\n        console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n        printWarning = function(message, isSoft) {\n            var color = isSoft ? \"\\u001b[33m\" : \"\\u001b[31m\";\n            console.warn(color + message + \"\\u001b[0m\\n\");\n        };\n    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n        printWarning = function(message, isSoft) {\n            console.warn(\"%c\" + message,\n                        isSoft ? \"color: darkorange\" : \"color: red\");\n        };\n    }\n}\n\nvar config = {\n    warnings: warnings,\n    longStackTraces: false,\n    cancellation: false,\n    monitoring: false,\n    asyncHooks: false\n};\n\nif (longStackTraces) Promise.longStackTraces();\n\nreturn {\n    asyncHooks: function() {\n        return config.asyncHooks;\n    },\n    longStackTraces: function() {\n        return config.longStackTraces;\n    },\n    warnings: function() {\n        return config.warnings;\n    },\n    cancellation: function() {\n        return config.cancellation;\n    },\n    monitoring: function() {\n        return config.monitoring;\n    },\n    propagateFromFunction: function() {\n        return propagateFromFunction;\n    },\n    boundValueFunction: function() {\n        return boundValueFunction;\n    },\n    checkForgottenReturns: checkForgottenReturns,\n    setBounds: setBounds,\n    warn: warn,\n    deprecated: deprecated,\n    CapturedTrace: CapturedTrace,\n    fireDomEvent: fireDomEvent,\n    fireGlobalEvent: fireGlobalEvent\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/debuggability.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/direct_resolve.js":
/*!********************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/direct_resolve.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nfunction returner() {\n    return this.value;\n}\nfunction thrower() {\n    throw this.reason;\n}\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn = function (value) {\n    if (value instanceof Promise) value.suppressUnhandledRejections();\n    return this._then(\n        returner, undefined, undefined, {value: value}, undefined);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow = function (reason) {\n    return this._then(\n        thrower, undefined, undefined, {reason: reason}, undefined);\n};\n\nPromise.prototype.catchThrow = function (reason) {\n    if (arguments.length <= 1) {\n        return this._then(\n            undefined, thrower, undefined, {reason: reason}, undefined);\n    } else {\n        var _reason = arguments[1];\n        var handler = function() {throw _reason;};\n        return this.caught(reason, handler);\n    }\n};\n\nPromise.prototype.catchReturn = function (value) {\n    if (arguments.length <= 1) {\n        if (value instanceof Promise) value.suppressUnhandledRejections();\n        return this._then(\n            undefined, returner, undefined, {value: value}, undefined);\n    } else {\n        var _value = arguments[1];\n        if (_value instanceof Promise) _value.suppressUnhandledRejections();\n        var handler = function() {return _value;};\n        return this.caught(value, handler);\n    }\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/direct_resolve.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/each.js":
/*!**********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/each.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\nvar PromiseAll = Promise.all;\n\nfunction promiseAllThis() {\n    return PromiseAll(this);\n}\n\nfunction PromiseMapSeries(promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);\n}\n\nPromise.prototype.each = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, this, undefined);\n};\n\nPromise.prototype.mapSeries = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, INTERNAL);\n};\n\nPromise.each = function (promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, promises, undefined);\n};\n\nPromise.mapSeries = PromiseMapSeries;\n};\n\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/each.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/errors.js":
/*!************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/errors.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5 */ \"../shared/node_modules/bluebird/js/release/es5.js\");\nvar Objectfreeze = es5.freeze;\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        notEnumerableProp(this, \"message\",\n            typeof message === \"string\" ? message : defaultMessage);\n        notEnumerableProp(this, \"name\", nameProperty);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Error.call(this);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nes5.defineProperty(AggregateError.prototype, \"length\", {\n    value: 0,\n    configurable: false,\n    writable: true,\n    enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    if (!(this instanceof OperationalError))\n        return new OperationalError(message);\n    notEnumerableProp(this, \"name\", \"OperationalError\");\n    notEnumerableProp(this, \"message\", message);\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        notEnumerableProp(this, \"message\", message.message);\n        notEnumerableProp(this, \"stack\", message.stack);\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    es5.defineProperty(Error, \"__BluebirdErrorTypes__\", {\n        value: errorTypes,\n        writable: false,\n        enumerable: false,\n        configurable: false\n    });\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    Warning: Warning\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/errors.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/es5.js":
/*!*********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/es5.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var isES5 = (function(){\n    \"use strict\";\n    return this === undefined;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        getDescriptor: Object.getOwnPropertyDescriptor,\n        keys: Object.keys,\n        names: Object.getOwnPropertyNames,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5,\n        propertyIsWritable: function(obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n        }\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function (o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    };\n\n    var ObjectGetDescriptor = function(o, key) {\n        return {value: o[key]};\n    };\n\n    var ObjectDefineProperty = function (o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    };\n\n    var ObjectFreeze = function (obj) {\n        return obj;\n    };\n\n    var ObjectGetPrototypeOf = function (obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    };\n\n    var ArrayIsArray = function (obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    };\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        names: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        getDescriptor: ObjectGetDescriptor,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5,\n        propertyIsWritable: function() {\n            return true;\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/es5.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/filter.js":
/*!************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/filter.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function (fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function (promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/filter.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/finally.js":
/*!*************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/finally.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar CancellationError = Promise.CancellationError;\nvar errorObj = util.errorObj;\nvar catchFilter = __webpack_require__(/*! ./catch_filter */ \"../shared/node_modules/bluebird/js/release/catch_filter.js\")(NEXT_FILTER);\n\nfunction PassThroughHandlerContext(promise, type, handler) {\n    this.promise = promise;\n    this.type = type;\n    this.handler = handler;\n    this.called = false;\n    this.cancelPromise = null;\n}\n\nPassThroughHandlerContext.prototype.isFinallyHandler = function() {\n    return this.type === 0;\n};\n\nfunction FinallyHandlerCancelReaction(finallyHandler) {\n    this.finallyHandler = finallyHandler;\n}\n\nFinallyHandlerCancelReaction.prototype._resultCancelled = function() {\n    checkCancel(this.finallyHandler);\n};\n\nfunction checkCancel(ctx, reason) {\n    if (ctx.cancelPromise != null) {\n        if (arguments.length > 1) {\n            ctx.cancelPromise._reject(reason);\n        } else {\n            ctx.cancelPromise._cancel();\n        }\n        ctx.cancelPromise = null;\n        return true;\n    }\n    return false;\n}\n\nfunction succeed() {\n    return finallyHandler.call(this, this.promise._target()._settledValue());\n}\nfunction fail(reason) {\n    if (checkCancel(this, reason)) return;\n    errorObj.e = reason;\n    return errorObj;\n}\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    if (!this.called) {\n        this.called = true;\n        var ret = this.isFinallyHandler()\n            ? handler.call(promise._boundValue())\n            : handler.call(promise._boundValue(), reasonOrValue);\n        if (ret === NEXT_FILTER) {\n            return ret;\n        } else if (ret !== undefined) {\n            promise._setReturnedNonUndefined();\n            var maybePromise = tryConvertToPromise(ret, promise);\n            if (maybePromise instanceof Promise) {\n                if (this.cancelPromise != null) {\n                    if (maybePromise._isCancelled()) {\n                        var reason =\n                            new CancellationError(\"late cancellation observer\");\n                        promise._attachExtraTrace(reason);\n                        errorObj.e = reason;\n                        return errorObj;\n                    } else if (maybePromise.isPending()) {\n                        maybePromise._attachCancellationCallback(\n                            new FinallyHandlerCancelReaction(this));\n                    }\n                }\n                return maybePromise._then(\n                    succeed, fail, undefined, this, undefined);\n            }\n        }\n    }\n\n    if (promise.isRejected()) {\n        checkCancel(this);\n        errorObj.e = reasonOrValue;\n        return errorObj;\n    } else {\n        checkCancel(this);\n        return reasonOrValue;\n    }\n}\n\nPromise.prototype._passThrough = function(handler, type, success, fail) {\n    if (typeof handler !== \"function\") return this.then();\n    return this._then(success,\n                      fail,\n                      undefined,\n                      new PassThroughHandlerContext(this, type, handler),\n                      undefined);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function (handler) {\n    return this._passThrough(handler,\n                             0,\n                             finallyHandler,\n                             finallyHandler);\n};\n\n\nPromise.prototype.tap = function (handler) {\n    return this._passThrough(handler, 1, finallyHandler);\n};\n\nPromise.prototype.tapCatch = function (handlerOrPredicate) {\n    var len = arguments.length;\n    if(len === 1) {\n        return this._passThrough(handlerOrPredicate,\n                                 1,\n                                 undefined,\n                                 finallyHandler);\n    } else {\n         var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (util.isObject(item)) {\n                catchInstances[j++] = item;\n            } else {\n                return Promise.reject(new TypeError(\n                    \"tapCatch statement predicate: \"\n                    + \"expecting an object but got \" + util.classString(item)\n                ));\n            }\n        }\n        catchInstances.length = j;\n        var handler = arguments[i];\n        return this._passThrough(catchFilter(catchInstances, handler, this),\n                                 1,\n                                 undefined,\n                                 finallyHandler);\n    }\n\n};\n\nreturn PassThroughHandlerContext;\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/finally.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/generators.js":
/*!****************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/generators.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          apiRejection,\n                          INTERNAL,\n                          tryConvertToPromise,\n                          Proxyable,\n                          debug) {\nvar errors = __webpack_require__(/*! ./errors */ \"../shared/node_modules/bluebird/js/release/errors.js\");\nvar TypeError = errors.TypeError;\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n        traceParent._pushContext();\n        var result = tryCatch(yieldHandlers[i])(value);\n        traceParent._popContext();\n        if (result === errorObj) {\n            traceParent._pushContext();\n            var ret = Promise.reject(errorObj.e);\n            traceParent._popContext();\n            return ret;\n        }\n        var maybePromise = tryConvertToPromise(result, traceParent);\n        if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    if (debug.cancellation()) {\n        var internal = new Promise(INTERNAL);\n        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);\n        this._promise = internal.lastly(function() {\n            return _finallyPromise;\n        });\n        internal._captureStackTrace();\n        internal._setOnCancel(this);\n    } else {\n        var promise = this._promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n    }\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n    this._yieldedPromise = null;\n    this._cancellationPhase = false;\n}\nutil.inherits(PromiseSpawn, Proxyable);\n\nPromiseSpawn.prototype._isResolved = function() {\n    return this._promise === null;\n};\n\nPromiseSpawn.prototype._cleanup = function() {\n    this._promise = this._generator = null;\n    if (debug.cancellation() && this._finallyPromise !== null) {\n        this._finallyPromise._fulfill();\n        this._finallyPromise = null;\n    }\n};\n\nPromiseSpawn.prototype._promiseCancelled = function() {\n    if (this._isResolved()) return;\n    var implementsReturn = typeof this._generator[\"return\"] !== \"undefined\";\n\n    var result;\n    if (!implementsReturn) {\n        var reason = new Promise.CancellationError(\n            \"generator .return() sentinel\");\n        Promise.coroutine.returnSentinel = reason;\n        this._promise._attachExtraTrace(reason);\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"throw\"]).call(this._generator,\n                                                         reason);\n        this._promise._popContext();\n    } else {\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"return\"]).call(this._generator,\n                                                          undefined);\n        this._promise._popContext();\n    }\n    this._cancellationPhase = true;\n    this._yieldedPromise = null;\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseFulfilled = function(value) {\n    this._yieldedPromise = null;\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseRejected = function(reason) {\n    this._yieldedPromise = null;\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"])\n        .call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._resultCancelled = function() {\n    if (this._yieldedPromise instanceof Promise) {\n        var promise = this._yieldedPromise;\n        this._yieldedPromise = null;\n        promise.cancel();\n    }\n};\n\nPromiseSpawn.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = undefined;\n    this._promiseFulfilled(undefined);\n};\n\nPromiseSpawn.prototype._continue = function (result) {\n    var promise = this._promise;\n    if (result === errorObj) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._rejectCallback(result.e, false);\n        }\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._resolveCallback(value);\n        }\n    } else {\n        var maybePromise = tryConvertToPromise(value, this._promise);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise,\n                                        this._yieldHandlers,\n                                        this._promise);\n            if (maybePromise === null) {\n                this._promiseRejected(\n                    new TypeError(\n                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\\u000a\".replace(\"%s\", String(value)) +\n                        \"From coroutine:\\u000a\" +\n                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n                    )\n                );\n                return;\n            }\n        }\n        maybePromise = maybePromise._target();\n        var bitField = maybePromise._bitField;\n        ;\n        if (((bitField & 50397184) === 0)) {\n            this._yieldedPromise = maybePromise;\n            maybePromise._proxy(this, null);\n        } else if (((bitField & 33554432) !== 0)) {\n            Promise._async.invoke(\n                this._promiseFulfilled, this, maybePromise._value()\n            );\n        } else if (((bitField & 16777216) !== 0)) {\n            Promise._async.invoke(\n                this._promiseRejected, this, maybePromise._reason()\n            );\n        } else {\n            this._promiseCancelled();\n        }\n    }\n};\n\nPromise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n                                      stack);\n        var ret = spawn.promise();\n        spawn._generator = generator;\n        spawn._promiseFulfilled(undefined);\n        return ret;\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function (generatorFunction) {\n    debug.deprecated(\"Promise.spawn()\", \"Promise.coroutine()\");\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/generators.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/join.js":
/*!**********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/join.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar reject;\n\nif (true) {\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var promiseSetter = function(i) {\n        return new Function(\"promise\", \"holder\", \"                           \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = promise;                                         \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var generateHolderClass = function(total) {\n        var props = new Array(total);\n        for (var i = 0; i < props.length; ++i) {\n            props[i] = \"this.p\" + (i+1);\n        }\n        var assignment = props.join(\" = \") + \" = null;\";\n        var cancellationCode= \"var promise;\\n\" + props.map(function(prop) {\n            return \"                                                         \\n\\\n                promise = \" + prop + \";                                      \\n\\\n                if (promise instanceof Promise) {                            \\n\\\n                    promise.cancel();                                        \\n\\\n                }                                                            \\n\\\n            \";\n        }).join(\"\\n\");\n        var passedArguments = props.join(\", \");\n        var name = \"Holder$\" + total;\n\n\n        var code = \"return function(tryCatch, errorObj, Promise, async) {    \\n\\\n            'use strict';                                                    \\n\\\n            function [TheName](fn) {                                         \\n\\\n                [TheProperties]                                              \\n\\\n                this.fn = fn;                                                \\n\\\n                this.asyncNeeded = true;                                     \\n\\\n                this.now = 0;                                                \\n\\\n            }                                                                \\n\\\n                                                                             \\n\\\n            [TheName].prototype._callFunction = function(promise) {          \\n\\\n                promise._pushContext();                                      \\n\\\n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \\n\\\n                promise._popContext();                                       \\n\\\n                if (ret === errorObj) {                                      \\n\\\n                    promise._rejectCallback(ret.e, false);                   \\n\\\n                } else {                                                     \\n\\\n                    promise._resolveCallback(ret);                           \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype.checkFulfillment = function(promise) {       \\n\\\n                var now = ++this.now;                                        \\n\\\n                if (now === [TheTotal]) {                                    \\n\\\n                    if (this.asyncNeeded) {                                  \\n\\\n                        async.invoke(this._callFunction, this, promise);     \\n\\\n                    } else {                                                 \\n\\\n                        this._callFunction(promise);                         \\n\\\n                    }                                                        \\n\\\n                                                                             \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype._resultCancelled = function() {              \\n\\\n                [CancellationCode]                                           \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            return [TheName];                                                \\n\\\n        }(tryCatch, errorObj, Promise, async);                               \\n\\\n        \";\n\n        code = code.replace(/\\[TheName\\]/g, name)\n            .replace(/\\[TheTotal\\]/g, total)\n            .replace(/\\[ThePassedArguments\\]/g, passedArguments)\n            .replace(/\\[TheProperties\\]/g, assignment)\n            .replace(/\\[CancellationCode\\]/g, cancellationCode);\n\n        return new Function(\"tryCatch\", \"errorObj\", \"Promise\", \"async\", code)\n                           (tryCatch, errorObj, Promise, async);\n    };\n\n    var holderClasses = [];\n    var thenCallbacks = [];\n    var promiseSetters = [];\n\n    for (var i = 0; i < 8; ++i) {\n        holderClasses.push(generateHolderClass(i + 1));\n        thenCallbacks.push(thenCallback(i + 1));\n        promiseSetters.push(promiseSetter(i + 1));\n    }\n\n    reject = function (reason) {\n        this._reject(reason);\n    };\n}}\n\nPromise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (true) {\n            if (last <= 8 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n                ret._captureStackTrace();\n                var HolderClass = holderClasses[last - 1];\n                var holder = new HolderClass(fn);\n                var callbacks = thenCallbacks;\n\n                for (var i = 0; i < last; ++i) {\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                    if (maybePromise instanceof Promise) {\n                        maybePromise = maybePromise._target();\n                        var bitField = maybePromise._bitField;\n                        ;\n                        if (((bitField & 50397184) === 0)) {\n                            maybePromise._then(callbacks[i], reject,\n                                               undefined, ret, holder);\n                            promiseSetters[i](maybePromise, holder);\n                            holder.asyncNeeded = false;\n                        } else if (((bitField & 33554432) !== 0)) {\n                            callbacks[i].call(ret,\n                                              maybePromise._value(), holder);\n                        } else if (((bitField & 16777216) !== 0)) {\n                            ret._reject(maybePromise._reason());\n                        } else {\n                            ret._cancel();\n                        }\n                    } else {\n                        callbacks[i].call(ret, maybePromise, holder);\n                    }\n                }\n\n                if (!ret._isFateSealed()) {\n                    if (holder.asyncNeeded) {\n                        var context = Promise._getContext();\n                        holder.fn = util.contextBind(context, holder.fn);\n                    }\n                    ret._setAsyncGuaranteed();\n                    ret._setOnCancel(holder);\n                }\n                return ret;\n            }\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len ; ++$_i) {args[$_i] = arguments[$_i ];};\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n};\n\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/join.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/map.js":
/*!*********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/map.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    var context = Promise._getContext();\n    this._callback = util.contextBind(context, fn);\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = [];\n    async.invoke(this._asyncInit, this, undefined);\n    if (util.isArray(promises)) {\n        for (var i = 0; i < promises.length; ++i) {\n            var maybePromise = promises[i];\n            if (maybePromise instanceof Promise) {\n                maybePromise.suppressUnhandledRejections();\n            }\n        }\n    }\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\n\nMappingPromiseArray.prototype._asyncInit = function() {\n    this._init$(undefined, -2);\n};\n\nMappingPromiseArray.prototype._init = function () {};\n\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n\n    if (index < 0) {\n        index = (index * -1) - 1;\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return true;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return false;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var promise = this._promise;\n        var callback = this._callback;\n        var receiver = promise._boundValue();\n        promise._pushContext();\n        var ret = tryCatch(callback).call(receiver, value, index, length);\n        var promiseCreated = promise._popContext();\n        debug.checkForgottenReturns(\n            ret,\n            promiseCreated,\n            preservedValues !== null ? \"Promise.filter\" : \"Promise.map\",\n            promise\n        );\n        if (ret === errorObj) {\n            this._reject(ret.e);\n            return true;\n        }\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            var bitField = maybePromise._bitField;\n            ;\n            if (((bitField & 50397184) === 0)) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = maybePromise;\n                maybePromise._proxy(this, (index + 1) * -1);\n                return false;\n            } else if (((bitField & 33554432) !== 0)) {\n                ret = maybePromise._value();\n            } else if (((bitField & 16777216) !== 0)) {\n                this._reject(maybePromise._reason());\n                return true;\n            } else {\n                this._cancel();\n                return true;\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n        return true;\n    }\n    return false;\n};\n\nMappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        if (this._isResolved()) return;\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n\n    var limit = 0;\n    if (options !== undefined) {\n        if (typeof options === \"object\" && options !== null) {\n            if (typeof options.concurrency !== \"number\") {\n                return Promise.reject(\n                    new TypeError(\"'concurrency' must be a number but it is \" +\n                                    util.classString(options.concurrency)));\n            }\n            limit = options.concurrency;\n        } else {\n            return Promise.reject(new TypeError(\n                            \"options argument must be an object but it is \" +\n                             util.classString(options)));\n        }\n    }\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter).promise();\n}\n\nPromise.prototype.map = function (fn, options) {\n    return map(this, fn, options, null);\n};\n\nPromise.map = function (promises, fn, options, _filter) {\n    return map(promises, fn, options, _filter);\n};\n\n\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/map.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/method.js":
/*!************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/method.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\n\nPromise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n        throw new Promise.TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return function () {\n        var ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._pushContext();\n        var value = tryCatch(fn).apply(this, arguments);\n        var promiseCreated = ret._popContext();\n        debug.checkForgottenReturns(\n            value, promiseCreated, \"Promise.method\", ret);\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value;\n    if (arguments.length > 1) {\n        debug.deprecated(\"calling Promise.try with more than 1 argument\");\n        var arg = arguments[1];\n        var ctx = arguments[2];\n        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)\n                                  : tryCatch(fn).call(ctx, arg);\n    } else {\n        value = tryCatch(fn)();\n    }\n    var promiseCreated = ret._popContext();\n    debug.checkForgottenReturns(\n        value, promiseCreated, \"Promise.try\", ret);\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n        this._rejectCallback(value.e, false);\n    } else {\n        this._resolveCallback(value, true);\n    }\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/method.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/nodeback.js":
/*!**************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/nodeback.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = __webpack_require__(/*! ./errors */ \"../shared/node_modules/bluebird/js/release/errors.js\");\nvar OperationalError = errors.OperationalError;\nvar es5 = __webpack_require__(/*! ./es5 */ \"../shared/node_modules/bluebird/js/release/es5.js\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n        ret.name = obj.name;\n        ret.message = obj.message;\n        ret.stack = obj.stack;\n        var keys = es5.keys(obj);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!rErrorKey.test(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    util.markAsOriginatingFromRejection(obj);\n    return obj;\n}\n\nfunction nodebackForPromise(promise, multiArgs) {\n    return function(err, value) {\n        if (promise === null) return;\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (!multiArgs) {\n            promise._fulfill(value);\n        } else {\n            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n            promise._fulfill(args);\n        }\n        promise = null;\n    };\n}\n\nmodule.exports = nodebackForPromise;\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/nodeback.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/nodeify.js":
/*!*************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/nodeify.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar async = Promise._async;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction spreadAdapter(val, nodeback) {\n    var promise = this;\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n    var ret =\n        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nfunction successAdapter(val, nodeback) {\n    var promise = this;\n    var receiver = promise._boundValue();\n    var ret = val === undefined\n        ? tryCatch(nodeback).call(receiver, null)\n        : tryCatch(nodeback).call(receiver, null, val);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\nfunction errorAdapter(reason, nodeback) {\n    var promise = this;\n    if (!reason) {\n        var newReason = new Error(reason + \"\");\n        newReason.cause = reason;\n        reason = newReason;\n    }\n    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nPromise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,\n                                                                     options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = successAdapter;\n        if (options !== undefined && Object(options).spread) {\n            adapter = spreadAdapter;\n        }\n        this._then(\n            adapter,\n            errorAdapter,\n            undefined,\n            this,\n            nodeback\n        );\n    }\n    return this;\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/nodeify.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/promise.js":
/*!*************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/promise.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function() {\nvar makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar reflectHandler = function() {\n    return new Promise.PromiseInspection(this._target());\n};\nvar apiRejection = function(msg) {\n    return Promise.reject(new TypeError(msg));\n};\nfunction Proxyable() {}\nvar UNDEFINED_BINDING = {};\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nutil.setReflectHandler(reflectHandler);\n\nvar getDomain = function() {\n    var domain = process.domain;\n    if (domain === undefined) {\n        return null;\n    }\n    return domain;\n};\nvar getContextDefault = function() {\n    return null;\n};\nvar getContextDomain = function() {\n    return {\n        domain: getDomain(),\n        async: null\n    };\n};\nvar AsyncResource = util.isNode && util.nodeSupportsAsyncResource ?\n    __webpack_require__(/*! async_hooks */ \"async_hooks\").AsyncResource : null;\nvar getContextAsyncHooks = function() {\n    return {\n        domain: getDomain(),\n        async: new AsyncResource(\"Bluebird::Promise\")\n    };\n};\nvar getContext = util.isNode ? getContextDomain : getContextDefault;\nutil.notEnumerableProp(Promise, \"_getContext\", getContext);\nvar enableAsyncHooks = function() {\n    getContext = getContextAsyncHooks;\n    util.notEnumerableProp(Promise, \"_getContext\", getContextAsyncHooks);\n};\nvar disableAsyncHooks = function() {\n    getContext = getContextDomain;\n    util.notEnumerableProp(Promise, \"_getContext\", getContextDomain);\n};\n\nvar es5 = __webpack_require__(/*! ./es5 */ \"../shared/node_modules/bluebird/js/release/es5.js\");\nvar Async = __webpack_require__(/*! ./async */ \"../shared/node_modules/bluebird/js/release/async.js\");\nvar async = new Async();\nes5.defineProperty(Promise, \"_async\", {value: async});\nvar errors = __webpack_require__(/*! ./errors */ \"../shared/node_modules/bluebird/js/release/errors.js\");\nvar TypeError = Promise.TypeError = errors.TypeError;\nPromise.RangeError = errors.RangeError;\nvar CancellationError = Promise.CancellationError = errors.CancellationError;\nPromise.TimeoutError = errors.TimeoutError;\nPromise.OperationalError = errors.OperationalError;\nPromise.RejectionError = errors.OperationalError;\nPromise.AggregateError = errors.AggregateError;\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {};\nvar tryConvertToPromise = __webpack_require__(/*! ./thenables */ \"../shared/node_modules/bluebird/js/release/thenables.js\")(Promise, INTERNAL);\nvar PromiseArray =\n    __webpack_require__(/*! ./promise_array */ \"../shared/node_modules/bluebird/js/release/promise_array.js\")(Promise, INTERNAL,\n                               tryConvertToPromise, apiRejection, Proxyable);\nvar Context = __webpack_require__(/*! ./context */ \"../shared/node_modules/bluebird/js/release/context.js\")(Promise);\n /*jshint unused:false*/\nvar createContext = Context.create;\n\nvar debug = __webpack_require__(/*! ./debuggability */ \"../shared/node_modules/bluebird/js/release/debuggability.js\")(Promise, Context,\n    enableAsyncHooks, disableAsyncHooks);\nvar CapturedTrace = debug.CapturedTrace;\nvar PassThroughHandlerContext =\n    __webpack_require__(/*! ./finally */ \"../shared/node_modules/bluebird/js/release/finally.js\")(Promise, tryConvertToPromise, NEXT_FILTER);\nvar catchFilter = __webpack_require__(/*! ./catch_filter */ \"../shared/node_modules/bluebird/js/release/catch_filter.js\")(NEXT_FILTER);\nvar nodebackForPromise = __webpack_require__(/*! ./nodeback */ \"../shared/node_modules/bluebird/js/release/nodeback.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nfunction check(self, executor) {\n    if (self == null || self.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (typeof executor !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(executor));\n    }\n\n}\n\nfunction Promise(executor) {\n    if (executor !== INTERNAL) {\n        check(this, executor);\n    }\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._resolveFromExecutor(executor);\n    this._promiseCreated();\n    this._fireEvent(\"promiseCreated\", this);\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (util.isObject(item)) {\n                catchInstances[j++] = item;\n            } else {\n                return apiRejection(\"Catch statement predicate: \" +\n                    \"expecting an object but got \" + util.classString(item));\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n\n        if (typeof fn !== \"function\") {\n            throw new TypeError(\"The last argument to .catch() \" +\n                \"must be a function, got \" + util.toString(fn));\n        }\n        return this.then(undefined, catchFilter(catchInstances, fn, this));\n    }\n    return this.then(undefined, fn);\n};\n\nPromise.prototype.reflect = function () {\n    return this._then(reflectHandler,\n        reflectHandler, undefined, this, undefined);\n};\n\nPromise.prototype.then = function (didFulfill, didReject) {\n    if (debug.warnings() && arguments.length > 0 &&\n        typeof didFulfill !== \"function\" &&\n        typeof didReject !== \"function\") {\n        var msg = \".then() only accepts functions but was passed: \" +\n                util.classString(didFulfill);\n        if (arguments.length > 1) {\n            msg += \", \" + util.classString(didReject);\n        }\n        this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, undefined, undefined, undefined);\n};\n\nPromise.prototype.done = function (didFulfill, didReject) {\n    var promise =\n        this._then(didFulfill, didReject, undefined, undefined, undefined);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    return this.all()._then(fn, undefined, undefined, APPLY, undefined);\n};\n\nPromise.prototype.toJSON = function () {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: undefined,\n        rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this.value();\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this.reason();\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function () {\n    if (arguments.length > 0) {\n        this._warn(\".all() was passed arguments but it does not take any\");\n    }\n    return new PromiseArray(this).promise();\n};\n\nPromise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n};\n\nPromise.getNewLibraryCopy = module.exports;\n\nPromise.is = function (val) {\n    return val instanceof Promise;\n};\n\nPromise.fromNode = Promise.fromCallback = function(fn) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs\n                                         : false;\n    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));\n    if (result === errorObj) {\n        ret._rejectCallback(result.e, true);\n    }\n    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n        ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._setFulfilled();\n        ret._rejectionHandler0 = obj;\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return async.setScheduler(fn);\n};\n\nPromise.prototype._then = function (\n    didFulfill,\n    didReject,\n    _,    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== undefined;\n    var promise = haveInternalData ? internalData : new Promise(INTERNAL);\n    var target = this._target();\n    var bitField = target._bitField;\n\n    if (!haveInternalData) {\n        promise._propagateFrom(this, 3);\n        promise._captureStackTrace();\n        if (receiver === undefined &&\n            ((this._bitField & 2097152) !== 0)) {\n            if (!((bitField & 50397184) === 0)) {\n                receiver = this._boundValue();\n            } else {\n                receiver = target === this ? undefined : this._boundTo;\n            }\n        }\n        this._fireEvent(\"promiseChained\", this, promise);\n    }\n\n    var context = getContext();\n    if (!((bitField & 50397184) === 0)) {\n        var handler, value, settler = target._settlePromiseCtx;\n        if (((bitField & 33554432) !== 0)) {\n            value = target._rejectionHandler0;\n            handler = didFulfill;\n        } else if (((bitField & 16777216) !== 0)) {\n            value = target._fulfillmentHandler0;\n            handler = didReject;\n            target._unsetRejectionIsUnhandled();\n        } else {\n            settler = target._settlePromiseLateCancellationObserver;\n            value = new CancellationError(\"late cancellation observer\");\n            target._attachExtraTrace(value);\n            handler = didReject;\n        }\n\n        async.invoke(settler, target, {\n            handler: util.contextBind(context, handler),\n            promise: promise,\n            receiver: receiver,\n            value: value\n        });\n    } else {\n        target._addCallbacks(didFulfill, didReject, promise,\n                receiver, context);\n    }\n\n    return promise;\n};\n\nPromise.prototype._length = function () {\n    return this._bitField & 65535;\n};\n\nPromise.prototype._isFateSealed = function () {\n    return (this._bitField & 117506048) !== 0;\n};\n\nPromise.prototype._isFollowing = function () {\n    return (this._bitField & 67108864) === 67108864;\n};\n\nPromise.prototype._setLength = function (len) {\n    this._bitField = (this._bitField & -65536) |\n        (len & 65535);\n};\n\nPromise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 33554432;\n    this._fireEvent(\"promiseFulfilled\", this);\n};\n\nPromise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 16777216;\n    this._fireEvent(\"promiseRejected\", this);\n};\n\nPromise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 67108864;\n    this._fireEvent(\"promiseResolved\", this);\n};\n\nPromise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._isFinal = function () {\n    return (this._bitField & 4194304) > 0;\n};\n\nPromise.prototype._unsetCancelled = function() {\n    this._bitField = this._bitField & (~65536);\n};\n\nPromise.prototype._setCancelled = function() {\n    this._bitField = this._bitField | 65536;\n    this._fireEvent(\"promiseCancelled\", this);\n};\n\nPromise.prototype._setWillBeCancelled = function() {\n    this._bitField = this._bitField | 8388608;\n};\n\nPromise.prototype._setAsyncGuaranteed = function() {\n    if (async.hasCustomScheduler()) return;\n    var bitField = this._bitField;\n    this._bitField = bitField |\n        (((bitField & 536870912) >> 2) ^\n        134217728);\n};\n\nPromise.prototype._setNoAsyncGuarantee = function() {\n    this._bitField = (this._bitField | 536870912) &\n        (~134217728);\n};\n\nPromise.prototype._receiverAt = function (index) {\n    var ret = index === 0 ? this._receiver0 : this[\n            index * 4 - 4 + 3];\n    if (ret === UNDEFINED_BINDING) {\n        return undefined;\n    } else if (ret === undefined && this._isBound()) {\n        return this._boundValue();\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function (index) {\n    return this[\n            index * 4 - 4 + 2];\n};\n\nPromise.prototype._fulfillmentHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 1];\n};\n\nPromise.prototype._boundValue = function() {};\n\nPromise.prototype._migrateCallback0 = function (follower) {\n    var bitField = follower._bitField;\n    var fulfill = follower._fulfillmentHandler0;\n    var reject = follower._rejectionHandler0;\n    var promise = follower._promise0;\n    var receiver = follower._receiverAt(0);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._migrateCallbackAt = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._addCallbacks = function (\n    fulfill,\n    reject,\n    promise,\n    receiver,\n    context\n) {\n    var index = this._length();\n\n    if (index >= 65535 - 4) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        this._receiver0 = receiver;\n        if (typeof fulfill === \"function\") {\n            this._fulfillmentHandler0 = util.contextBind(context, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this._rejectionHandler0 = util.contextBind(context, reject);\n        }\n    } else {\n        var base = index * 4 - 4;\n        this[base + 2] = promise;\n        this[base + 3] = receiver;\n        if (typeof fulfill === \"function\") {\n            this[base + 0] =\n                util.contextBind(context, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this[base + 1] =\n                util.contextBind(context, reject);\n        }\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._proxy = function (proxyable, arg) {\n    this._addCallbacks(undefined, undefined, arg, proxyable, null);\n};\n\nPromise.prototype._resolveCallback = function(value, shouldBind) {\n    if (((this._bitField & 117506048) !== 0)) return;\n    if (value === this)\n        return this._rejectCallback(makeSelfResolutionError(), false);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n    if (shouldBind) this._propagateFrom(maybePromise, 2);\n\n\n    var promise = maybePromise._target();\n\n    if (promise === this) {\n        this._reject(makeSelfResolutionError());\n        return;\n    }\n\n    var bitField = promise._bitField;\n    if (((bitField & 50397184) === 0)) {\n        var len = this._length();\n        if (len > 0) promise._migrateCallback0(this);\n        for (var i = 1; i < len; ++i) {\n            promise._migrateCallbackAt(this, i);\n        }\n        this._setFollowing();\n        this._setLength(0);\n        this._setFollowee(maybePromise);\n    } else if (((bitField & 33554432) !== 0)) {\n        this._fulfill(promise._value());\n    } else if (((bitField & 16777216) !== 0)) {\n        this._reject(promise._reason());\n    } else {\n        var reason = new CancellationError(\"late cancellation observer\");\n        promise._attachExtraTrace(reason);\n        this._reject(reason);\n    }\n};\n\nPromise.prototype._rejectCallback =\nfunction(reason, synchronous, ignoreNonErrorWarnings) {\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {\n        var message = \"a promise was rejected with a non-error: \" +\n            util.classString(reason);\n        this._warn(message, true);\n    }\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason);\n};\n\nPromise.prototype._resolveFromExecutor = function (executor) {\n    if (executor === INTERNAL) return;\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = this._execute(executor, function(value) {\n        promise._resolveCallback(value);\n    }, function (reason) {\n        promise._rejectCallback(reason, synchronous);\n    });\n    synchronous = false;\n    this._popContext();\n\n    if (r !== undefined) {\n        promise._rejectCallback(r, true);\n    }\n};\n\nPromise.prototype._settlePromiseFromHandler = function (\n    handler, receiver, value, promise\n) {\n    var bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY) {\n        if (!value || typeof value.length !== \"number\") {\n            x = errorObj;\n            x.e = new TypeError(\"cannot .spread() a non-array: \" +\n                                    util.classString(value));\n        } else {\n            x = tryCatch(handler).apply(this._boundValue(), value);\n        }\n    } else {\n        x = tryCatch(handler).call(receiver, value);\n    }\n    var promiseCreated = promise._popContext();\n    bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n\n    if (x === NEXT_FILTER) {\n        promise._reject(value);\n    } else if (x === errorObj) {\n        promise._rejectCallback(x.e, false);\n    } else {\n        debug.checkForgottenReturns(x, promiseCreated, \"\",  promise, this);\n        promise._resolveCallback(x);\n    }\n};\n\nPromise.prototype._target = function() {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n};\n\nPromise.prototype._followee = function() {\n    return this._rejectionHandler0;\n};\n\nPromise.prototype._setFollowee = function(promise) {\n    this._rejectionHandler0 = promise;\n};\n\nPromise.prototype._settlePromise = function(promise, handler, receiver, value) {\n    var isPromise = promise instanceof Promise;\n    var bitField = this._bitField;\n    var asyncGuaranteed = ((bitField & 134217728) !== 0);\n    if (((bitField & 65536) !== 0)) {\n        if (isPromise) promise._invokeInternalOnCancel();\n\n        if (receiver instanceof PassThroughHandlerContext &&\n            receiver.isFinallyHandler()) {\n            receiver.cancelPromise = promise;\n            if (tryCatch(handler).call(receiver, value) === errorObj) {\n                promise._reject(errorObj.e);\n            }\n        } else if (handler === reflectHandler) {\n            promise._fulfill(reflectHandler.call(receiver));\n        } else if (receiver instanceof Proxyable) {\n            receiver._promiseCancelled(promise);\n        } else if (isPromise || promise instanceof PromiseArray) {\n            promise._cancel();\n        } else {\n            receiver.cancel();\n        }\n    } else if (typeof handler === \"function\") {\n        if (!isPromise) {\n            handler.call(receiver, value, promise);\n        } else {\n            if (asyncGuaranteed) promise._setAsyncGuaranteed();\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (receiver instanceof Proxyable) {\n        if (!receiver._isResolved()) {\n            if (((bitField & 33554432) !== 0)) {\n                receiver._promiseFulfilled(value, promise);\n            } else {\n                receiver._promiseRejected(value, promise);\n            }\n        }\n    } else if (isPromise) {\n        if (asyncGuaranteed) promise._setAsyncGuaranteed();\n        if (((bitField & 33554432) !== 0)) {\n            promise._fulfill(value);\n        } else {\n            promise._reject(value);\n        }\n    }\n};\n\nPromise.prototype._settlePromiseLateCancellationObserver = function(ctx) {\n    var handler = ctx.handler;\n    var promise = ctx.promise;\n    var receiver = ctx.receiver;\n    var value = ctx.value;\n    if (typeof handler === \"function\") {\n        if (!(promise instanceof Promise)) {\n            handler.call(receiver, value, promise);\n        } else {\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (promise instanceof Promise) {\n        promise._reject(value);\n    }\n};\n\nPromise.prototype._settlePromiseCtx = function(ctx) {\n    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);\n};\n\nPromise.prototype._settlePromise0 = function(handler, value, bitField) {\n    var promise = this._promise0;\n    var receiver = this._receiverAt(0);\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settlePromise(promise, handler, receiver, value);\n};\n\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\n    var base = index * 4 - 4;\n    this[base + 2] =\n    this[base + 3] =\n    this[base + 0] =\n    this[base + 1] = undefined;\n};\n\nPromise.prototype._fulfill = function (value) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._reject(err);\n    }\n    this._setFulfilled();\n    this._rejectionHandler0 = value;\n\n    if ((bitField & 65535) > 0) {\n        if (((bitField & 134217728) !== 0)) {\n            this._settlePromises();\n        } else {\n            async.settlePromises(this);\n        }\n        this._dereferenceTrace();\n    }\n};\n\nPromise.prototype._reject = function (reason) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    this._setRejected();\n    this._fulfillmentHandler0 = reason;\n\n    if (this._isFinal()) {\n        return async.fatalError(reason, util.isNode);\n    }\n\n    if ((bitField & 65535) > 0) {\n        async.settlePromises(this);\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._fulfillPromises = function (len, value) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._fulfillmentHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, value);\n    }\n};\n\nPromise.prototype._rejectPromises = function (len, reason) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._rejectionHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, reason);\n    }\n};\n\nPromise.prototype._settlePromises = function () {\n    var bitField = this._bitField;\n    var len = (bitField & 65535);\n\n    if (len > 0) {\n        if (((bitField & 16842752) !== 0)) {\n            var reason = this._fulfillmentHandler0;\n            this._settlePromise0(this._rejectionHandler0, reason, bitField);\n            this._rejectPromises(len, reason);\n        } else {\n            var value = this._rejectionHandler0;\n            this._settlePromise0(this._fulfillmentHandler0, value, bitField);\n            this._fulfillPromises(len, value);\n        }\n        this._setLength(0);\n    }\n    this._clearCancellationData();\n};\n\nPromise.prototype._settledValue = function() {\n    var bitField = this._bitField;\n    if (((bitField & 33554432) !== 0)) {\n        return this._rejectionHandler0;\n    } else if (((bitField & 16777216) !== 0)) {\n        return this._fulfillmentHandler0;\n    }\n};\n\nif (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n    es5.defineProperty(Promise.prototype, Symbol.toStringTag, {\n        get: function () {\n            return \"Object\";\n        }\n    });\n}\n\nfunction deferResolve(v) {this.promise._resolveCallback(v);}\nfunction deferReject(v) {this.promise._rejectCallback(v, false);}\n\nPromise.defer = Promise.pending = function() {\n    debug.deprecated(\"Promise.defer\", \"new Promise\");\n    var promise = new Promise(INTERNAL);\n    return {\n        promise: promise,\n        resolve: deferResolve,\n        reject: deferReject\n    };\n};\n\nutil.notEnumerableProp(Promise,\n                       \"_makeSelfResolutionError\",\n                       makeSelfResolutionError);\n\n__webpack_require__(/*! ./method */ \"../shared/node_modules/bluebird/js/release/method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection,\n    debug);\n__webpack_require__(/*! ./bind */ \"../shared/node_modules/bluebird/js/release/bind.js\")(Promise, INTERNAL, tryConvertToPromise, debug);\n__webpack_require__(/*! ./cancel */ \"../shared/node_modules/bluebird/js/release/cancel.js\")(Promise, PromiseArray, apiRejection, debug);\n__webpack_require__(/*! ./direct_resolve */ \"../shared/node_modules/bluebird/js/release/direct_resolve.js\")(Promise);\n__webpack_require__(/*! ./synchronous_inspection */ \"../shared/node_modules/bluebird/js/release/synchronous_inspection.js\")(Promise);\n__webpack_require__(/*! ./join */ \"../shared/node_modules/bluebird/js/release/join.js\")(\n    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async);\nPromise.Promise = Promise;\nPromise.version = \"3.7.2\";\n__webpack_require__(/*! ./call_get.js */ \"../shared/node_modules/bluebird/js/release/call_get.js\")(Promise);\n__webpack_require__(/*! ./generators.js */ \"../shared/node_modules/bluebird/js/release/generators.js\")(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);\n__webpack_require__(/*! ./map.js */ \"../shared/node_modules/bluebird/js/release/map.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n__webpack_require__(/*! ./nodeify.js */ \"../shared/node_modules/bluebird/js/release/nodeify.js\")(Promise);\n__webpack_require__(/*! ./promisify.js */ \"../shared/node_modules/bluebird/js/release/promisify.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./props.js */ \"../shared/node_modules/bluebird/js/release/props.js\")(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./race.js */ \"../shared/node_modules/bluebird/js/release/race.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./reduce.js */ \"../shared/node_modules/bluebird/js/release/reduce.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n__webpack_require__(/*! ./settle.js */ \"../shared/node_modules/bluebird/js/release/settle.js\")(Promise, PromiseArray, debug);\n__webpack_require__(/*! ./some.js */ \"../shared/node_modules/bluebird/js/release/some.js\")(Promise, PromiseArray, apiRejection);\n__webpack_require__(/*! ./timers.js */ \"../shared/node_modules/bluebird/js/release/timers.js\")(Promise, INTERNAL, debug);\n__webpack_require__(/*! ./using.js */ \"../shared/node_modules/bluebird/js/release/using.js\")(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);\n__webpack_require__(/*! ./any.js */ \"../shared/node_modules/bluebird/js/release/any.js\")(Promise);\n__webpack_require__(/*! ./each.js */ \"../shared/node_modules/bluebird/js/release/each.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./filter.js */ \"../shared/node_modules/bluebird/js/release/filter.js\")(Promise, INTERNAL);\n                                                         \n    util.toFastProperties(Promise);                                          \n    util.toFastProperties(Promise.prototype);                                \n    function fillTypes(value) {                                              \n        var p = new Promise(INTERNAL);                                       \n        p._fulfillmentHandler0 = value;                                      \n        p._rejectionHandler0 = value;                                        \n        p._promise0 = value;                                                 \n        p._receiver0 = value;                                                \n    }                                                                        \n    // Complete slack tracking, opt out of field-type tracking and           \n    // stabilize map                                                         \n    fillTypes({a: 1});                                                       \n    fillTypes({b: 2});                                                       \n    fillTypes({c: 3});                                                       \n    fillTypes(1);                                                            \n    fillTypes(function(){});                                                 \n    fillTypes(undefined);                                                    \n    fillTypes(false);                                                        \n    fillTypes(new Promise(INTERNAL));                                        \n    debug.setBounds(Async.firstLineError, util.lastLineError);               \n    return Promise;                                                          \n\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/promise.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/promise_array.js":
/*!*******************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/promise_array.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n    apiRejection, Proxyable) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -2: return [];\n    case -3: return {};\n    case -6: return new Map();\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    if (values instanceof Promise) {\n        promise._propagateFrom(values, 3);\n        values.suppressUnhandledRejections();\n    }\n    promise._setOnCancel(this);\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(undefined, -2);\n}\nutil.inherits(PromiseArray, Proxyable);\n\nPromiseArray.prototype.length = function () {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n    var values = tryConvertToPromise(this._values, this._promise);\n    if (values instanceof Promise) {\n        values = values._target();\n        var bitField = values._bitField;\n        ;\n        this._values = values;\n\n        if (((bitField & 50397184) === 0)) {\n            this._promise._setAsyncGuaranteed();\n            return values._then(\n                init,\n                this._reject,\n                undefined,\n                this,\n                resolveValueIfEmpty\n           );\n        } else if (((bitField & 33554432) !== 0)) {\n            values = values._value();\n        } else if (((bitField & 16777216) !== 0)) {\n            return this._reject(values._reason());\n        } else {\n            return this._cancel();\n        }\n    }\n    values = util.asArray(values);\n    if (values === null) {\n        var err = apiRejection(\n            \"expecting an array or an iterable object but got \" + util.classString(values)).reason();\n        this._promise._rejectCallback(err, false);\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    this._iterate(values);\n};\n\nPromiseArray.prototype._iterate = function(values) {\n    var len = this.getActualLength(values.length);\n    this._length = len;\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n    var result = this._promise;\n    var isResolved = false;\n    var bitField = null;\n    for (var i = 0; i < len; ++i) {\n        var maybePromise = tryConvertToPromise(values[i], result);\n\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            bitField = maybePromise._bitField;\n        } else {\n            bitField = null;\n        }\n\n        if (isResolved) {\n            if (bitField !== null) {\n                maybePromise.suppressUnhandledRejections();\n            }\n        } else if (bitField !== null) {\n            if (((bitField & 50397184) === 0)) {\n                maybePromise._proxy(this, i);\n                this._values[i] = maybePromise;\n            } else if (((bitField & 33554432) !== 0)) {\n                isResolved = this._promiseFulfilled(maybePromise._value(), i);\n            } else if (((bitField & 16777216) !== 0)) {\n                isResolved = this._promiseRejected(maybePromise._reason(), i);\n            } else {\n                isResolved = this._promiseCancelled(i);\n            }\n        } else {\n            isResolved = this._promiseFulfilled(maybePromise, i);\n        }\n    }\n    if (!isResolved) result._setAsyncGuaranteed();\n};\n\nPromiseArray.prototype._isResolved = function () {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function (value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype._cancel = function() {\n    if (this._isResolved() || !this._promise._isCancellable()) return;\n    this._values = null;\n    this._promise._cancel();\n};\n\nPromiseArray.prototype._reject = function (reason) {\n    this._values = null;\n    this._promise._rejectCallback(reason, false);\n};\n\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nPromiseArray.prototype._promiseCancelled = function() {\n    this._cancel();\n    return true;\n};\n\nPromiseArray.prototype._promiseRejected = function (reason) {\n    this._totalResolved++;\n    this._reject(reason);\n    return true;\n};\n\nPromiseArray.prototype._resultCancelled = function() {\n    if (this._isResolved()) return;\n    var values = this._values;\n    this._cancel();\n    if (values instanceof Promise) {\n        values.cancel();\n    } else {\n        for (var i = 0; i < values.length; ++i) {\n            if (values[i] instanceof Promise) {\n                values[i].cancel();\n            }\n        }\n    }\n};\n\nPromiseArray.prototype.shouldCopyValues = function () {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength = function (len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/promise_array.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/promisify.js":
/*!***************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/promisify.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar nodebackForPromise = __webpack_require__(/*! ./nodeback */ \"../shared/node_modules/bluebird/js/release/nodeback.js\");\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = __webpack_require__(/*! ./errors */ \"../shared/node_modules/bluebird/js/release/errors.js\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyProps = [\n    \"arity\",    \"length\",\n    \"name\",\n    \"arguments\",\n    \"caller\",\n    \"callee\",\n    \"prototype\",\n    \"__isPromisified__\"\n];\nvar noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\nvar defaultFilter = function(name) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        name !== \"constructor\";\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (true) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn, _, multiArgs) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n    var body = \"'use strict';                                                \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise, \" + multiArgs + \");   \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n    \".replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode);\n    body = body.replace(\"Parameters\", parameterDeclaration(newParameterCount));\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"notEnumerableProp\",\n                        \"INTERNAL\",\n                        body)(\n                    Promise,\n                    fn,\n                    receiver,\n                    withAppended,\n                    maybeWrapAsError,\n                    nodebackForPromise,\n                    util.tryCatch,\n                    util.errorObj,\n                    util.notEnumerableProp,\n                    INTERNAL);\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise, multiArgs);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n        return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        if (promisifier === makeNodePromisified) {\n            obj[promisifiedKey] =\n                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n        } else {\n            var promisified = promisifier(fn, function() {\n                return makeNodePromisified(key, THIS, key,\n                                           fn, suffix, multiArgs);\n            });\n            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n            obj[promisifiedKey] = promisified;\n        }\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver, multiArgs) {\n    return makeNodePromisified(callback, receiver, undefined,\n                                callback, null, multiArgs);\n}\n\nPromise.promisify = function (fn, options) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    options = Object(options);\n    var receiver = options.context === undefined ? THIS : options.context;\n    var multiArgs = !!options.multiArgs;\n    var ret = promisify(fn, receiver, multiArgs);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    options = Object(options);\n    var multiArgs = !!options.multiArgs;\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier,\n                multiArgs);\n            promisifyAll(value, suffix, filter, promisifier, multiArgs);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n};\n};\n\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/promisify.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/props.js":
/*!***********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/props.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar isObject = util.isObject;\nvar es5 = __webpack_require__(/*! ./es5 */ \"../shared/node_modules/bluebird/js/release/es5.js\");\nvar Es6Map;\nif (typeof Map === \"function\") Es6Map = Map;\n\nvar mapToEntries = (function() {\n    var index = 0;\n    var size = 0;\n\n    function extractEntry(value, key) {\n        this[index] = value;\n        this[index + size] = key;\n        index++;\n    }\n\n    return function mapToEntries(map) {\n        size = map.size;\n        index = 0;\n        var ret = new Array(map.size * 2);\n        map.forEach(extractEntry, ret);\n        return ret;\n    };\n})();\n\nvar entriesToMap = function(entries) {\n    var ret = new Es6Map();\n    var length = entries.length / 2 | 0;\n    for (var i = 0; i < length; ++i) {\n        var key = entries[length + i];\n        var value = entries[i];\n        ret.set(key, value);\n    }\n    return ret;\n};\n\nfunction PropertiesPromiseArray(obj) {\n    var isMap = false;\n    var entries;\n    if (Es6Map !== undefined && obj instanceof Es6Map) {\n        entries = mapToEntries(obj);\n        isMap = true;\n    } else {\n        var keys = es5.keys(obj);\n        var len = keys.length;\n        entries = new Array(len * 2);\n        for (var i = 0; i < len; ++i) {\n            var key = keys[i];\n            entries[i] = obj[key];\n            entries[i + len] = key;\n        }\n    }\n    this.constructor$(entries);\n    this._isMap = isMap;\n    this._init$(undefined, isMap ? -6 : -3);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init = function () {};\n\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val;\n        if (this._isMap) {\n            val = entriesToMap(this._values);\n        } else {\n            val = {};\n            var keyOffset = this.length();\n            for (var i = 0, len = this.length(); i < len; ++i) {\n                val[this._values[i + keyOffset]] = this._values[i];\n            }\n        }\n        this._resolve(val);\n        return true;\n    }\n    return false;\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\n    return len >> 1;\n};\n\nfunction props(promises) {\n    var ret;\n    var castValue = tryConvertToPromise(promises);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(\n            Promise.props, undefined, undefined, undefined, undefined);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 2);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function () {\n    return props(this);\n};\n\nPromise.props = function (promises) {\n    return props(promises);\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/props.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/queue.js":
/*!***********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/queue.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n}\n\nQueue.prototype._willBeOverCapacity = function (size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function (arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype.push = function (fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function () {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = undefined;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function () {\n    return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 1);\n    }\n};\n\nQueue.prototype._resizeTo = function (capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n};\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/queue.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/race.js":
/*!**********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/race.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\n\nvar raceLater = function (promise) {\n    return promise.then(function(array) {\n        return race(array, promise);\n    });\n};\n\nfunction race(promises, parent) {\n    var maybePromise = tryConvertToPromise(promises);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else {\n        promises = util.asArray(promises);\n        if (promises === null)\n            return apiRejection(\"expecting an array or an iterable object but got \" + util.classString(promises));\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== undefined) {\n        ret._propagateFrom(parent, 3);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === undefined && !(i in promises)) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function (promises) {\n    return race(promises, undefined);\n};\n\nPromise.prototype.race = function () {\n    return race(this, undefined);\n};\n\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/race.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/reduce.js":
/*!************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/reduce.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\n\nfunction ReductionPromiseArray(promises, fn, initialValue, _each) {\n    this.constructor$(promises);\n    var context = Promise._getContext();\n    this._fn = util.contextBind(context, fn);\n    if (initialValue !== undefined) {\n        initialValue = Promise.resolve(initialValue);\n        initialValue._attachCancellationCallback(this);\n    }\n    this._initialValue = initialValue;\n    this._currentCancellable = null;\n    if(_each === INTERNAL) {\n        this._eachValues = Array(this._length);\n    } else if (_each === 0) {\n        this._eachValues = null;\n    } else {\n        this._eachValues = undefined;\n    }\n    this._promise._captureStackTrace();\n    this._init$(undefined, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._gotAccum = function(accum) {\n    if (this._eachValues !== undefined &&\n        this._eachValues !== null &&\n        accum !== INTERNAL) {\n        this._eachValues.push(accum);\n    }\n};\n\nReductionPromiseArray.prototype._eachComplete = function(value) {\n    if (this._eachValues !== null) {\n        this._eachValues.push(value);\n    }\n    return this._eachValues;\n};\n\nReductionPromiseArray.prototype._init = function() {};\n\nReductionPromiseArray.prototype._resolveEmptyArray = function() {\n    this._resolve(this._eachValues !== undefined ? this._eachValues\n                                                 : this._initialValue);\n};\n\nReductionPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nReductionPromiseArray.prototype._resolve = function(value) {\n    this._promise._resolveCallback(value);\n    this._values = null;\n};\n\nReductionPromiseArray.prototype._resultCancelled = function(sender) {\n    if (sender === this._initialValue) return this._cancel();\n    if (this._isResolved()) return;\n    this._resultCancelled$();\n    if (this._currentCancellable instanceof Promise) {\n        this._currentCancellable.cancel();\n    }\n    if (this._initialValue instanceof Promise) {\n        this._initialValue.cancel();\n    }\n};\n\nReductionPromiseArray.prototype._iterate = function (values) {\n    this._values = values;\n    var value;\n    var i;\n    var length = values.length;\n    if (this._initialValue !== undefined) {\n        value = this._initialValue;\n        i = 0;\n    } else {\n        value = Promise.resolve(values[0]);\n        i = 1;\n    }\n\n    this._currentCancellable = value;\n\n    for (var j = i; j < length; ++j) {\n        var maybePromise = values[j];\n        if (maybePromise instanceof Promise) {\n            maybePromise.suppressUnhandledRejections();\n        }\n    }\n\n    if (!value.isRejected()) {\n        for (; i < length; ++i) {\n            var ctx = {\n                accum: null,\n                value: values[i],\n                index: i,\n                length: length,\n                array: this\n            };\n\n            value = value._then(gotAccum, undefined, undefined, ctx, undefined);\n\n            if ((i & 127) === 0) {\n                value._setNoAsyncGuarantee();\n            }\n        }\n    }\n\n    if (this._eachValues !== undefined) {\n        value = value\n            ._then(this._eachComplete, undefined, undefined, this, undefined);\n    }\n    value._then(completed, completed, undefined, value, this);\n};\n\nPromise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n\nfunction completed(valueOrReason, array) {\n    if (this.isFulfilled()) {\n        array._resolve(valueOrReason);\n    } else {\n        array._reject(valueOrReason);\n    }\n}\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nfunction gotAccum(accum) {\n    this.accum = accum;\n    this.array._gotAccum(accum);\n    var value = tryConvertToPromise(this.value, this.array._promise);\n    if (value instanceof Promise) {\n        this.array._currentCancellable = value;\n        return value._then(gotValue, undefined, undefined, this, undefined);\n    } else {\n        return gotValue.call(this, value);\n    }\n}\n\nfunction gotValue(value) {\n    var array = this.array;\n    var promise = array._promise;\n    var fn = tryCatch(array._fn);\n    promise._pushContext();\n    var ret;\n    if (array._eachValues !== undefined) {\n        ret = fn.call(promise._boundValue(), value, this.index, this.length);\n    } else {\n        ret = fn.call(promise._boundValue(),\n                              this.accum, value, this.index, this.length);\n    }\n    if (ret instanceof Promise) {\n        array._currentCancellable = ret;\n    }\n    var promiseCreated = promise._popContext();\n    debug.checkForgottenReturns(\n        ret,\n        promiseCreated,\n        array._eachValues !== undefined ? \"Promise.each\" : \"Promise.reduce\",\n        promise\n    );\n    return ret;\n}\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/reduce.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/schedule.js":
/*!**************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/schedule.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar schedule;\nvar noAsyncScheduler = function() {\n    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar NativePromise = util.getNativePromise();\nif (util.isNode && typeof MutationObserver === \"undefined\") {\n    var GlobalSetImmediate = global.setImmediate;\n    var ProcessNextTick = process.nextTick;\n    schedule = util.isRecentNode\n                ? function(fn) { GlobalSetImmediate.call(global, fn); }\n                : function(fn) { ProcessNextTick.call(process, fn); };\n} else if (typeof NativePromise === \"function\" &&\n           typeof NativePromise.resolve === \"function\") {\n    var nativePromise = NativePromise.resolve();\n    schedule = function(fn) {\n        nativePromise.then(fn);\n    };\n} else if ((typeof MutationObserver !== \"undefined\") &&\n          !(typeof window !== \"undefined\" &&\n            window.navigator &&\n            (window.navigator.standalone || window.cordova)) &&\n          (\"classList\" in document.documentElement)) {\n    schedule = (function() {\n        var div = document.createElement(\"div\");\n        var opts = {attributes: true};\n        var toggleScheduled = false;\n        var div2 = document.createElement(\"div\");\n        var o2 = new MutationObserver(function() {\n            div.classList.toggle(\"foo\");\n            toggleScheduled = false;\n        });\n        o2.observe(div2, opts);\n\n        var scheduleToggle = function() {\n            if (toggleScheduled) return;\n            toggleScheduled = true;\n            div2.classList.toggle(\"foo\");\n        };\n\n        return function schedule(fn) {\n            var o = new MutationObserver(function() {\n                o.disconnect();\n                fn();\n            });\n            o.observe(div, opts);\n            scheduleToggle();\n        };\n    })();\n} else if (typeof setImmediate !== \"undefined\") {\n    schedule = function (fn) {\n        setImmediate(fn);\n    };\n} else if (typeof setTimeout !== \"undefined\") {\n    schedule = function (fn) {\n        setTimeout(fn, 0);\n    };\n} else {\n    schedule = noAsyncScheduler;\n}\nmodule.exports = schedule;\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/schedule.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/settle.js":
/*!************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/settle.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\n    function(Promise, PromiseArray, debug) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 33554432;\n    ret._settledValueField = value;\n    return this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 16777216;\n    ret._settledValueField = reason;\n    return this._promiseResolved(index, ret);\n};\n\nPromise.settle = function (promises) {\n    debug.deprecated(\".settle()\", \".reflect()\");\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.allSettled = function (promises) {\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function () {\n    return Promise.settle(this);\n};\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/settle.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/some.js":
/*!**********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/some.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar RangeError = __webpack_require__(/*! ./errors */ \"../shared/node_modules/bluebird/js/release/errors.js\").RangeError;\nvar AggregateError = __webpack_require__(/*! ./errors */ \"../shared/node_modules/bluebird/js/release/errors.js\").AggregateError;\nvar isArray = util.isArray;\nvar CANCELLATION = {};\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function () {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(undefined, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function () {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function () {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function () {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany = function (count) {\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n        return true;\n    }\n    return false;\n\n};\nSomePromiseArray.prototype._promiseRejected = function (reason) {\n    this._addRejected(reason);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._promiseCancelled = function () {\n    if (this._values instanceof Promise || this._values == null) {\n        return this._cancel();\n    }\n    this._addRejected(CANCELLATION);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._checkOutcome = function() {\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            if (this._values[i] !== CANCELLATION) {\n                e.push(this._values[i]);\n            }\n        }\n        if (e.length > 0) {\n            this._reject(e);\n        } else {\n            this._cancel();\n        }\n        return true;\n    }\n    return false;\n};\n\nSomePromiseArray.prototype._fulfilled = function () {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function () {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected = function (reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled = function (value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError = function (count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray = function () {\n    this._reject(this._getRangeError(0));\n};\n\nfunction some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function (promises, howMany) {\n    return some(promises, howMany);\n};\n\nPromise.prototype.some = function (howMany) {\n    return some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/some.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/synchronous_inspection.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/synchronous_inspection.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== undefined) {\n        promise = promise._target();\n        this._bitField = promise._bitField;\n        this._settledValueField = promise._isFateSealed()\n            ? promise._settledValue() : undefined;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValueField = undefined;\n    }\n}\n\nPromiseInspection.prototype._settledValue = function() {\n    return this._settledValueField;\n};\n\nvar value = PromiseInspection.prototype.value = function () {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar reason = PromiseInspection.prototype.error =\nPromiseInspection.prototype.reason = function () {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar isFulfilled = PromiseInspection.prototype.isFulfilled = function() {\n    return (this._bitField & 33554432) !== 0;\n};\n\nvar isRejected = PromiseInspection.prototype.isRejected = function () {\n    return (this._bitField & 16777216) !== 0;\n};\n\nvar isPending = PromiseInspection.prototype.isPending = function () {\n    return (this._bitField & 50397184) === 0;\n};\n\nvar isResolved = PromiseInspection.prototype.isResolved = function () {\n    return (this._bitField & 50331648) !== 0;\n};\n\nPromiseInspection.prototype.isCancelled = function() {\n    return (this._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.__isCancelled = function() {\n    return (this._bitField & 65536) === 65536;\n};\n\nPromise.prototype._isCancelled = function() {\n    return this._target().__isCancelled();\n};\n\nPromise.prototype.isCancelled = function() {\n    return (this._target()._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.isPending = function() {\n    return isPending.call(this._target());\n};\n\nPromise.prototype.isRejected = function() {\n    return isRejected.call(this._target());\n};\n\nPromise.prototype.isFulfilled = function() {\n    return isFulfilled.call(this._target());\n};\n\nPromise.prototype.isResolved = function() {\n    return isResolved.call(this._target());\n};\n\nPromise.prototype.value = function() {\n    return value.call(this._target());\n};\n\nPromise.prototype.reason = function() {\n    var target = this._target();\n    target._unsetRejectionIsUnhandled();\n    return reason.call(target);\n};\n\nPromise.prototype._value = function() {\n    return this._settledValue();\n};\n\nPromise.prototype._reason = function() {\n    this._unsetRejectionIsUnhandled();\n    return this._settledValue();\n};\n\nPromise.PromiseInspection = PromiseInspection;\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/synchronous_inspection.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/thenables.js":
/*!***************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/thenables.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction tryConvertToPromise(obj, context) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) return obj;\n        var then = getThen(obj);\n        if (then === errorObj) {\n            if (context) context._pushContext();\n            var ret = Promise.reject(then.e);\n            if (context) context._popContext();\n            return ret;\n        } else if (typeof then === \"function\") {\n            if (isAnyBluebirdPromise(obj)) {\n                var ret = new Promise(INTERNAL);\n                obj._then(\n                    ret._fulfill,\n                    ret._reject,\n                    undefined,\n                    ret,\n                    null\n                );\n                return ret;\n            }\n            return doThenable(obj, then, context);\n        }\n    }\n    return obj;\n}\n\nfunction doGetThen(obj) {\n    return obj.then;\n}\n\nfunction getThen(obj) {\n    try {\n        return doGetThen(obj);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    try {\n        return hasProp.call(obj, \"_promise0\");\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction doThenable(x, then, context) {\n    var promise = new Promise(INTERNAL);\n    var ret = promise;\n    if (context) context._pushContext();\n    promise._captureStackTrace();\n    if (context) context._popContext();\n    var synchronous = true;\n    var result = util.tryCatch(then).call(x, resolve, reject);\n    synchronous = false;\n\n    if (promise && result === errorObj) {\n        promise._rejectCallback(result.e, true, true);\n        promise = null;\n    }\n\n    function resolve(value) {\n        if (!promise) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }\n\n    function reject(reason) {\n        if (!promise) return;\n        promise._rejectCallback(reason, synchronous, true);\n        promise = null;\n    }\n    return ret;\n}\n\nreturn tryConvertToPromise;\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/thenables.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/timers.js":
/*!************************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/timers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, debug) {\nvar util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\nvar TimeoutError = Promise.TimeoutError;\n\nfunction HandleWrapper(handle)  {\n    this.handle = handle;\n}\n\nHandleWrapper.prototype._resultCancelled = function() {\n    clearTimeout(this.handle);\n};\n\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\nvar delay = Promise.delay = function (ms, value) {\n    var ret;\n    var handle;\n    if (value !== undefined) {\n        ret = Promise.resolve(value)\n                ._then(afterValue, null, null, ms, undefined);\n        if (debug.cancellation() && value instanceof Promise) {\n            ret._setOnCancel(value);\n        }\n    } else {\n        ret = new Promise(INTERNAL);\n        handle = setTimeout(function() { ret._fulfill(); }, +ms);\n        if (debug.cancellation()) {\n            ret._setOnCancel(new HandleWrapper(handle));\n        }\n        ret._captureStackTrace();\n    }\n    ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.prototype.delay = function (ms) {\n    return delay(ms, this);\n};\n\nvar afterTimeout = function (promise, message, parent) {\n    var err;\n    if (typeof message !== \"string\") {\n        if (message instanceof Error) {\n            err = message;\n        } else {\n            err = new TimeoutError(\"operation timed out\");\n        }\n    } else {\n        err = new TimeoutError(message);\n    }\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._reject(err);\n\n    if (parent != null) {\n        parent.cancel();\n    }\n};\n\nfunction successClear(value) {\n    clearTimeout(this.handle);\n    return value;\n}\n\nfunction failureClear(reason) {\n    clearTimeout(this.handle);\n    throw reason;\n}\n\nPromise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret, parent;\n\n    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {\n        if (ret.isPending()) {\n            afterTimeout(ret, message, parent);\n        }\n    }, ms));\n\n    if (debug.cancellation()) {\n        parent = this.then();\n        ret = parent._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n        ret._setOnCancel(handleWrapper);\n    } else {\n        ret = this._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n    }\n\n    return ret;\n};\n\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/timers.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/using.js":
/*!***********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/using.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n    createContext, INTERNAL, debug) {\n    var util = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\");\n    var TypeError = __webpack_require__(/*! ./errors */ \"../shared/node_modules/bluebird/js/release/errors.js\").TypeError;\n    var inherits = __webpack_require__(/*! ./util */ \"../shared/node_modules/bluebird/js/release/util.js\").inherits;\n    var errorObj = util.errorObj;\n    var tryCatch = util.tryCatch;\n    var NULL = {};\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function castPreservingDisposable(thenable) {\n        var maybePromise = tryConvertToPromise(thenable);\n        if (maybePromise !== thenable &&\n            typeof thenable._isDisposable === \"function\" &&\n            typeof thenable._getDisposer === \"function\" &&\n            thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n        }\n        return maybePromise;\n    }\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = new Promise(INTERNAL);\n        function iterator() {\n            if (i >= len) return ret._fulfill();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = tryConvertToPromise(\n                        maybePromise._getDisposer().tryDispose(inspection),\n                        resources.promise);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret;\n    }\n\n    function Disposer(data, promise, context) {\n        this._data = data;\n        this._promise = promise;\n        this._context = context;\n    }\n\n    Disposer.prototype.data = function () {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function () {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function () {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return NULL;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var context = this._context;\n        if (context !== undefined) context._pushContext();\n        var ret = resource !== NULL\n            ? this.doDispose(resource, inspection) : null;\n        if (context !== undefined) context._popContext();\n        this._promise._unsetDisposable();\n        this._data = null;\n        return ret;\n    };\n\n    Disposer.isDisposer = function (d) {\n        return (d != null &&\n                typeof d.resource === \"function\" &&\n                typeof d.tryDispose === \"function\");\n    };\n\n    function FunctionDisposer(fn, promise, context) {\n        this.constructor$(fn, promise, context);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    function maybeUnwrapDisposer(value) {\n        if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n            return value.promise();\n        }\n        return value;\n    }\n\n    function ResourceList(length) {\n        this.length = length;\n        this.promise = null;\n        this[length-1] = null;\n    }\n\n    ResourceList.prototype._resultCancelled = function() {\n        var len = this.length;\n        for (var i = 0; i < len; ++i) {\n            var item = this[i];\n            if (item instanceof Promise) {\n                item.cancel();\n            }\n        }\n    };\n\n    Promise.using = function () {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") {\n            return apiRejection(\"expecting a function but got \" + util.classString(fn));\n        }\n        var input;\n        var spreadArgs = true;\n        if (len === 2 && Array.isArray(arguments[0])) {\n            input = arguments[0];\n            len = input.length;\n            spreadArgs = false;\n        } else {\n            input = arguments;\n            len--;\n        }\n        var resources = new ResourceList(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = input[i];\n            if (Disposer.isDisposer(resource)) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            } else {\n                var maybePromise = tryConvertToPromise(resource);\n                if (maybePromise instanceof Promise) {\n                    resource =\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n                            resources: resources,\n                            index: i\n                    }, undefined);\n                }\n            }\n            resources[i] = resource;\n        }\n\n        var reflectedResources = new Array(resources.length);\n        for (var i = 0; i < reflectedResources.length; ++i) {\n            reflectedResources[i] = Promise.resolve(resources[i]).reflect();\n        }\n\n        var resultPromise = Promise.all(reflectedResources)\n            .then(function(inspections) {\n                for (var i = 0; i < inspections.length; ++i) {\n                    var inspection = inspections[i];\n                    if (inspection.isRejected()) {\n                        errorObj.e = inspection.error();\n                        return errorObj;\n                    } else if (!inspection.isFulfilled()) {\n                        resultPromise.cancel();\n                        return;\n                    }\n                    inspections[i] = inspection.value();\n                }\n                promise._pushContext();\n\n                fn = tryCatch(fn);\n                var ret = spreadArgs\n                    ? fn.apply(undefined, inspections) : fn(inspections);\n                var promiseCreated = promise._popContext();\n                debug.checkForgottenReturns(\n                    ret, promiseCreated, \"Promise.using\", promise);\n                return ret;\n            });\n\n        var promise = resultPromise.lastly(function() {\n            var inspection = new Promise.PromiseInspection(resultPromise);\n            return dispose(resources, inspection);\n        });\n        resources.promise = promise;\n        promise._setOnCancel(resources);\n        return promise;\n    };\n\n    Promise.prototype._setDisposable = function (disposer) {\n        this._bitField = this._bitField | 131072;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function () {\n        return (this._bitField & 131072) > 0;\n    };\n\n    Promise.prototype._getDisposer = function () {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function () {\n        this._bitField = this._bitField & (~131072);\n        this._disposer = undefined;\n    };\n\n    Promise.prototype.disposer = function (fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n        }\n        throw new TypeError();\n    };\n\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/using.js?");

/***/ }),

/***/ "../shared/node_modules/bluebird/js/release/util.js":
/*!**********************************************************!*\
  !*** ../shared/node_modules/bluebird/js/release/util.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5 */ \"../shared/node_modules/bluebird/js/release/es5.js\");\nvar canEvaluate = typeof navigator == \"undefined\";\n\nvar errorObj = {e: {}};\nvar tryCatchTarget;\nvar globalObject = typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    typeof global !== \"undefined\" ? global :\n    this !== undefined ? this : null;\n\nfunction tryCatcher() {\n    try {\n        var target = tryCatchTarget;\n        tryCatchTarget = null;\n        return target.apply(this, arguments);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return typeof value === \"function\" ||\n           typeof value === \"object\" && value !== null;\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(safeToString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    var excludedPrototypes = [\n        Array.prototype,\n        Object.prototype,\n        Function.prototype\n    ];\n\n    var isExcludedProto = function(val) {\n        for (var i = 0; i < excludedPrototypes.length; ++i) {\n            if (excludedPrototypes[i] === val) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (es5.isES5) {\n        var getKeys = Object.getOwnPropertyNames;\n        return function(obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            while (obj != null && !isExcludedProto(obj)) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        var hasProp = {}.hasOwnProperty;\n        return function(obj) {\n            if (isExcludedProto(obj)) return [];\n            var ret = [];\n\n            /*jshint forin:false */\n            enumeration: for (var key in obj) {\n                if (hasProp.call(obj, key)) {\n                    ret.push(key);\n                } else {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (hasProp.call(excludedPrototypes[i], key)) {\n                            continue enumeration;\n                        }\n                    }\n                    ret.push(key);\n                }\n            }\n            return ret;\n        };\n    }\n\n})();\n\nvar thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n\n            var hasMethods = es5.isES5 && keys.length > 1;\n            var hasMethodsOtherThanConstructor = keys.length > 0 &&\n                !(keys.length === 1 && keys[0] === \"constructor\");\n            var hasThisAssignmentAndStaticMethods =\n                thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n            if (hasMethods || hasMethodsOtherThanConstructor ||\n                hasThisAssignmentAndStaticMethods) {\n                return true;\n            }\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027,-W055,-W031*/\n    function FakeConstructor() {}\n    FakeConstructor.prototype = obj;\n    var receiver = new FakeConstructor();\n    function ic() {\n        return typeof receiver.foo;\n    }\n    ic();\n    ic();\n    return obj;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nfunction safeToString(obj) {\n    try {\n        return obj + \"\";\n    } catch (e) {\n        return \"[no string representation]\";\n    }\n}\n\nfunction isError(obj) {\n    return obj instanceof Error ||\n        (obj !== null &&\n           typeof obj === \"object\" &&\n           typeof obj.message === \"string\" &&\n           typeof obj.name === \"string\");\n}\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction canAttachTrace(obj) {\n    return isError(obj) && es5.propertyIsWritable(obj, \"stack\");\n}\n\nvar ensureErrorObject = (function() {\n    if (!(\"stack\" in new Error())) {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            try {throw new Error(safeToString(value));}\n            catch(err) {return err;}\n        };\n    } else {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n        };\n    }\n})();\n\nfunction classString(obj) {\n    return {}.toString.call(obj);\n}\n\nfunction copyDescriptors(from, to, filter) {\n    var keys = es5.names(from);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        if (filter(key)) {\n            try {\n                es5.defineProperty(to, key, es5.getDescriptor(from, key));\n            } catch (ignore) {}\n        }\n    }\n}\n\nvar asArray = function(v) {\n    if (es5.isArray(v)) {\n        return v;\n    }\n    return null;\n};\n\nif (typeof Symbol !== \"undefined\" && Symbol.iterator) {\n    var ArrayFrom = typeof Array.from === \"function\" ? function(v) {\n        return Array.from(v);\n    } : function(v) {\n        var ret = [];\n        var it = v[Symbol.iterator]();\n        var itResult;\n        while (!((itResult = it.next()).done)) {\n            ret.push(itResult.value);\n        }\n        return ret;\n    };\n\n    asArray = function(v) {\n        if (es5.isArray(v)) {\n            return v;\n        } else if (v != null && typeof v[Symbol.iterator] === \"function\") {\n            return ArrayFrom(v);\n        }\n        return null;\n    };\n}\n\nvar isNode = typeof process !== \"undefined\" &&\n        classString(process).toLowerCase() === \"[object process]\";\n\nvar hasEnvVariables = typeof process !== \"undefined\" &&\n    typeof process.env !== \"undefined\";\n\nfunction env(key) {\n    return hasEnvVariables ? process.env[key] : undefined;\n}\n\nfunction getNativePromise() {\n    if (typeof Promise === \"function\") {\n        try {\n            var promise = new Promise(function(){});\n            if (classString(promise) === \"[object Promise]\") {\n                return Promise;\n            }\n        } catch (e) {}\n    }\n}\n\nvar reflectHandler;\nfunction contextBind(ctx, cb) {\n    if (ctx === null ||\n        typeof cb !== \"function\" ||\n        cb === reflectHandler) {\n        return cb;\n    }\n\n    if (ctx.domain !== null) {\n        cb = ctx.domain.bind(cb);\n    }\n\n    var async = ctx.async;\n    if (async !== null) {\n        var old = cb;\n        cb = function() {\n            var $_len = arguments.length + 2;var args = new Array($_len); for(var $_i = 2; $_i < $_len ; ++$_i) {args[$_i] = arguments[$_i  - 2];};\n            args[0] = old;\n            args[1] = this;\n            return async.runInAsyncScope.apply(async, args);\n        };\n    }\n    return cb;\n}\n\nvar ret = {\n    setReflectHandler: function(fn) {\n        reflectHandler = fn;\n    },\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    asArray: asArray,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    isError: isError,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch: tryCatch,\n    inherits: inherits,\n    withAppended: withAppended,\n    maybeWrapAsError: maybeWrapAsError,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange,\n    toString: safeToString,\n    canAttachTrace: canAttachTrace,\n    ensureErrorObject: ensureErrorObject,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    classString: classString,\n    copyDescriptors: copyDescriptors,\n    isNode: isNode,\n    hasEnvVariables: hasEnvVariables,\n    env: env,\n    global: globalObject,\n    getNativePromise: getNativePromise,\n    contextBind: contextBind\n};\nret.isRecentNode = ret.isNode && (function() {\n    var version;\n    if (process.versions && process.versions.node) {\n        version = process.versions.node.split(\".\").map(Number);\n    } else if (process.version) {\n        version = process.version.split(\".\").map(Number);\n    }\n    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);\n})();\nret.nodeSupportsAsyncResource = ret.isNode && (function() {\n    var supportsAsync = false;\n    try {\n        var res = __webpack_require__(/*! async_hooks */ \"async_hooks\").AsyncResource;\n        supportsAsync = typeof res.prototype.runInAsyncScope === \"function\";\n    } catch (e) {\n        supportsAsync = false;\n    }\n    return supportsAsync;\n})();\n\nif (ret.isNode) ret.toFastProperties(process);\n\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\nmodule.exports = ret;\n\n\n//# sourceURL=webpack:///../shared/node_modules/bluebird/js/release/util.js?");

/***/ }),

/***/ "../shared/node_modules/brace-expansion/index.js":
/*!*******************************************************!*\
  !*** ../shared/node_modules/brace-expansion/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var concatMap = __webpack_require__(/*! concat-map */ \"../shared/node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"../shared/node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n\n//# sourceURL=webpack:///../shared/node_modules/brace-expansion/index.js?");

/***/ }),

/***/ "../shared/node_modules/bunyan/lib/bunyan.js":
/*!***************************************************!*\
  !*** ../shared/node_modules/bunyan/lib/bunyan.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright 2020 Trent Mick.\n * Copyright 2020 Joyent Inc.\n *\n * The bunyan logging library for node.js.\n *\n * -*- mode: js -*-\n * vim: expandtab:ts=4:sw=4\n */\n\nvar VERSION = '1.8.14';\n\n/*\n * Bunyan log format version. This becomes the 'v' field on all log records.\n * This will be incremented if there is any backward incompatible change to\n * the log record format. Details will be in 'CHANGES.md' (the change log).\n */\nvar LOG_VERSION = 0;\n\n\nvar xxx = function xxx(s) {     // internal dev/debug logging\n    var args = ['XX' + 'X: '+s].concat(\n        Array.prototype.slice.call(arguments, 1));\n    console.error.apply(this, args);\n};\nvar xxx = function xxx() {};  // comment out to turn on debug logging\n\n\n/*\n * Runtime environment notes:\n *\n * Bunyan is intended to run in a number of runtime environments. Here are\n * some notes on differences for those envs and how the code copes.\n *\n * - node.js: The primary target environment.\n * - NW.js: http://nwjs.io/  An *app* environment that feels like both a\n *   node env -- it has node-like globals (`process`, `global`) and\n *   browser-like globals (`window`, `navigator`). My *understanding* is that\n *   bunyan can operate as if this is vanilla node.js.\n * - browser: Failing the above, we sniff using the `window` global\n *   <https://developer.mozilla.org/en-US/docs/Web/API/Window/window>.\n *      - browserify: http://browserify.org/  A browser-targetting bundler of\n *        node.js deps. The runtime is a browser env, so can't use fs access,\n *        etc. Browserify's build looks for `require(<single-string>)` imports\n *        to bundle. For some imports it won't be able to handle, we \"hide\"\n *        from browserify with `require('frobshizzle' + '')`.\n * - Other? Please open issues if things are broken.\n */\nvar runtimeEnv;\nif (typeof (process) !== 'undefined' && process.versions) {\n    if (process.versions.nw) {\n        runtimeEnv = 'nw';\n    } else if (process.versions.node) {\n        runtimeEnv = 'node';\n    }\n}\nif (!runtimeEnv && typeof (window) !== 'undefined' &&\n    window.window === window) {\n    runtimeEnv = 'browser';\n}\nif (!runtimeEnv) {\n    throw new Error('unknown runtime environment');\n}\n\n\nvar os, fs, dtrace;\nif (runtimeEnv === 'browser') {\n    os = {\n        hostname: function () {\n            return window.location.host;\n        }\n    };\n    fs = {};\n    dtrace = null;\n} else {\n    os = __webpack_require__(/*! os */ \"os\");\n    fs = __webpack_require__(/*! fs */ \"fs\");\n    try {\n        dtrace = __webpack_require__(/*! dtrace-provider */ \"../shared/node_modules/dtrace-provider/dtrace-provider.js\");\n    } catch (e) {\n        dtrace = null;\n    }\n}\nvar util = __webpack_require__(/*! util */ \"util\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar stream = __webpack_require__(/*! stream */ \"stream\");\n\ntry {\n    var safeJsonStringify = __webpack_require__(/*! safe-json-stringify */ \"../shared/node_modules/safe-json-stringify/index.js\");\n} catch (e) {\n    safeJsonStringify = null;\n}\nif (process.env.BUNYAN_TEST_NO_SAFE_JSON_STRINGIFY) {\n    safeJsonStringify = null;\n}\n\n// The 'mv' module is required for rotating-file stream support.\ntry {\n    var mv = __webpack_require__(/*! mv */ \"../shared/node_modules/mv/index.js\");\n} catch (e) {\n    mv = null;\n}\n\ntry {\n    var sourceMapSupport = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'source-map-support'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n} catch (_) {\n    sourceMapSupport = null;\n}\n\n\n//---- Internal support stuff\n\n/**\n * A shallow copy of an object. Bunyan logging attempts to never cause\n * exceptions, so this function attempts to handle non-objects gracefully.\n */\nfunction objCopy(obj) {\n    if (obj == null) {  // null or undefined\n        return obj;\n    } else if (Array.isArray(obj)) {\n        return obj.slice();\n    } else if (typeof (obj) === 'object') {\n        var copy = {};\n        Object.keys(obj).forEach(function (k) {\n            copy[k] = obj[k];\n        });\n        return copy;\n    } else {\n        return obj;\n    }\n}\n\nvar format = util.format;\nif (!format) {\n    // If node < 0.6, then use its `util.format`:\n    // <https://github.com/joyent/node/blob/master/lib/util.js#L22>:\n    var inspect = util.inspect;\n    var formatRegExp = /%[sdj%]/g;\n    format = function format(f) {\n        if (typeof (f) !== 'string') {\n            var objects = [];\n            for (var i = 0; i < arguments.length; i++) {\n                objects.push(inspect(arguments[i]));\n            }\n            return objects.join(' ');\n        }\n\n        var i = 1;\n        var args = arguments;\n        var len = args.length;\n        var str = String(f).replace(formatRegExp, function (x) {\n            if (i >= len)\n                return x;\n            switch (x) {\n                case '%s': return String(args[i++]);\n                case '%d': return Number(args[i++]);\n                case '%j': return fastAndSafeJsonStringify(args[i++]);\n                case '%%': return '%';\n                default:\n                    return x;\n            }\n        });\n        for (var x = args[i]; i < len; x = args[++i]) {\n            if (x === null || typeof (x) !== 'object') {\n                str += ' ' + x;\n            } else {\n                str += ' ' + inspect(x);\n            }\n        }\n        return str;\n    };\n}\n\n\n/**\n * Gather some caller info 3 stack levels up.\n * See <http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi>.\n */\nfunction getCaller3Info() {\n    if (this === undefined) {\n        // Cannot access caller info in 'strict' mode.\n        return;\n    }\n    var obj = {};\n    var saveLimit = Error.stackTraceLimit;\n    var savePrepare = Error.prepareStackTrace;\n    Error.stackTraceLimit = 3;\n\n    Error.prepareStackTrace = function (_, stack) {\n        var caller = stack[2];\n        if (sourceMapSupport) {\n            caller = sourceMapSupport.wrapCallSite(caller);\n        }\n        obj.file = caller.getFileName();\n        obj.line = caller.getLineNumber();\n        var func = caller.getFunctionName();\n        if (func)\n            obj.func = func;\n    };\n    Error.captureStackTrace(this, getCaller3Info);\n    this.stack;\n\n    Error.stackTraceLimit = saveLimit;\n    Error.prepareStackTrace = savePrepare;\n    return obj;\n}\n\n\nfunction _indent(s, indent) {\n    if (!indent) indent = '    ';\n    var lines = s.split(/\\r?\\n/g);\n    return indent + lines.join('\\n' + indent);\n}\n\n\n/**\n * Warn about an bunyan processing error.\n *\n * @param msg {String} Message with which to warn.\n * @param dedupKey {String} Optional. A short string key for this warning to\n *      have its warning only printed once.\n */\nfunction _warn(msg, dedupKey) {\n    assert.ok(msg);\n    if (dedupKey) {\n        if (_warned[dedupKey]) {\n            return;\n        }\n        _warned[dedupKey] = true;\n    }\n    process.stderr.write(msg + '\\n');\n}\nfunction _haveWarned(dedupKey) {\n    return _warned[dedupKey];\n}\nvar _warned = {};\n\n\nfunction ConsoleRawStream() {}\nConsoleRawStream.prototype.write = function (rec) {\n    if (rec.level < INFO) {\n        console.log(rec);\n    } else if (rec.level < WARN) {\n        console.info(rec);\n    } else if (rec.level < ERROR) {\n        console.warn(rec);\n    } else {\n        console.error(rec);\n    }\n};\n\n\n//---- Levels\n\nvar TRACE = 10;\nvar DEBUG = 20;\nvar INFO = 30;\nvar WARN = 40;\nvar ERROR = 50;\nvar FATAL = 60;\n\nvar levelFromName = {\n    'trace': TRACE,\n    'debug': DEBUG,\n    'info': INFO,\n    'warn': WARN,\n    'error': ERROR,\n    'fatal': FATAL\n};\nvar nameFromLevel = {};\nObject.keys(levelFromName).forEach(function (name) {\n    nameFromLevel[levelFromName[name]] = name;\n});\n\n// Dtrace probes.\nvar dtp = undefined;\nvar probes = dtrace && {};\n\n/**\n * Resolve a level number, name (upper or lowercase) to a level number value.\n *\n * @param nameOrNum {String|Number} A level name (case-insensitive) or positive\n *      integer level.\n * @api public\n */\nfunction resolveLevel(nameOrNum) {\n    var level;\n    var type = typeof (nameOrNum);\n    if (type === 'string') {\n        level = levelFromName[nameOrNum.toLowerCase()];\n        if (!level) {\n            throw new Error(format('unknown level name: \"%s\"', nameOrNum));\n        }\n    } else if (type !== 'number') {\n        throw new TypeError(format('cannot resolve level: invalid arg (%s):',\n            type, nameOrNum));\n    } else if (nameOrNum < 0 || Math.floor(nameOrNum) !== nameOrNum) {\n        throw new TypeError(format('level is not a positive integer: %s',\n            nameOrNum));\n    } else {\n        level = nameOrNum;\n    }\n    return level;\n}\n\n\nfunction isWritable(obj) {\n    if (obj instanceof stream.Writable) {\n        return true;\n    }\n    return typeof (obj.write) === 'function';\n}\n\n\n//---- Logger class\n\n/**\n * Create a Logger instance.\n *\n * @param options {Object} See documentation for full details. At minimum\n *    this must include a 'name' string key. Configuration keys:\n *      - `streams`: specify the logger output streams. This is an array of\n *        objects with these fields:\n *          - `type`: The stream type. See README.md for full details.\n *            Often this is implied by the other fields. Examples are\n *            'file', 'stream' and \"raw\".\n *          - `level`: Defaults to 'info'.\n *          - `path` or `stream`: The specify the file path or writeable\n *            stream to which log records are written. E.g.\n *            `stream: process.stdout`.\n *          - `closeOnExit` (boolean): Optional. Default is true for a\n *            'file' stream when `path` is given, false otherwise.\n *        See README.md for full details.\n *      - `level`: set the level for a single output stream (cannot be used\n *        with `streams`)\n *      - `stream`: the output stream for a logger with just one, e.g.\n *        `process.stdout` (cannot be used with `streams`)\n *      - `serializers`: object mapping log record field names to\n *        serializing functions. See README.md for details.\n *      - `src`: Boolean (default false). Set true to enable 'src' automatic\n *        field with log call source info.\n *    All other keys are log record fields.\n *\n * An alternative *internal* call signature is used for creating a child:\n *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);\n *\n * @param _childSimple (Boolean) An assertion that the given `_childOptions`\n *    (a) only add fields (no config) and (b) no serialization handling is\n *    required for them. IOW, this is a fast path for frequent child\n *    creation.\n */\nfunction Logger(options, _childOptions, _childSimple) {\n    xxx('Logger start:', options)\n    if (!(this instanceof Logger)) {\n        return new Logger(options, _childOptions);\n    }\n\n    // Input arg validation.\n    var parent;\n    if (_childOptions !== undefined) {\n        parent = options;\n        options = _childOptions;\n        if (!(parent instanceof Logger)) {\n            throw new TypeError(\n                'invalid Logger creation: do not pass a second arg');\n        }\n    }\n    if (!options) {\n        throw new TypeError('options (object) is required');\n    }\n    if (!parent) {\n        if (!options.name) {\n            throw new TypeError('options.name (string) is required');\n        }\n    } else {\n        if (options.name) {\n            throw new TypeError(\n                'invalid options.name: child cannot set logger name');\n        }\n    }\n    if (options.stream && options.streams) {\n        throw new TypeError('cannot mix \"streams\" and \"stream\" options');\n    }\n    if (options.streams && !Array.isArray(options.streams)) {\n        throw new TypeError('invalid options.streams: must be an array')\n    }\n    if (options.serializers && (typeof (options.serializers) !== 'object' ||\n            Array.isArray(options.serializers))) {\n        throw new TypeError('invalid options.serializers: must be an object')\n    }\n\n    EventEmitter.call(this);\n\n    // Fast path for simple child creation.\n    if (parent && _childSimple) {\n        // `_isSimpleChild` is a signal to stream close handling that this child\n        // owns none of its streams.\n        this._isSimpleChild = true;\n\n        this._level = parent._level;\n        this.streams = parent.streams;\n        this.serializers = parent.serializers;\n        this.src = parent.src;\n        var fields = this.fields = {};\n        var parentFieldNames = Object.keys(parent.fields);\n        for (var i = 0; i < parentFieldNames.length; i++) {\n            var name = parentFieldNames[i];\n            fields[name] = parent.fields[name];\n        }\n        var names = Object.keys(options);\n        for (var i = 0; i < names.length; i++) {\n            var name = names[i];\n            fields[name] = options[name];\n        }\n        return;\n    }\n\n    // Start values.\n    var self = this;\n    if (parent) {\n        this._level = parent._level;\n        this.streams = [];\n        for (var i = 0; i < parent.streams.length; i++) {\n            var s = objCopy(parent.streams[i]);\n            s.closeOnExit = false; // Don't own parent stream.\n            this.streams.push(s);\n        }\n        this.serializers = objCopy(parent.serializers);\n        this.src = parent.src;\n        this.fields = objCopy(parent.fields);\n        if (options.level) {\n            this.level(options.level);\n        }\n    } else {\n        this._level = Number.POSITIVE_INFINITY;\n        this.streams = [];\n        this.serializers = null;\n        this.src = false;\n        this.fields = {};\n    }\n\n    if (!dtp && dtrace) {\n        dtp = dtrace.createDTraceProvider('bunyan');\n\n        for (var level in levelFromName) {\n            var probe;\n\n            probes[levelFromName[level]] = probe =\n                dtp.addProbe('log-' + level, 'char *');\n\n            // Explicitly add a reference to dtp to prevent it from being GC'd\n            probe.dtp = dtp;\n        }\n\n        dtp.enable();\n    }\n\n    // Handle *config* options (i.e. options that are not just plain data\n    // for log records).\n    if (options.stream) {\n        self.addStream({\n            type: 'stream',\n            stream: options.stream,\n            closeOnExit: false,\n            level: options.level\n        });\n    } else if (options.streams) {\n        options.streams.forEach(function (s) {\n            self.addStream(s, options.level);\n        });\n    } else if (parent && options.level) {\n        this.level(options.level);\n    } else if (!parent) {\n        if (runtimeEnv === 'browser') {\n            /*\n             * In the browser we'll be emitting to console.log by default.\n             * Any console.log worth its salt these days can nicely render\n             * and introspect objects (e.g. the Firefox and Chrome console)\n             * so let's emit the raw log record. Are there browsers for which\n             * that breaks things?\n             */\n            self.addStream({\n                type: 'raw',\n                stream: new ConsoleRawStream(),\n                closeOnExit: false,\n                level: options.level\n            });\n        } else {\n            self.addStream({\n                type: 'stream',\n                stream: process.stdout,\n                closeOnExit: false,\n                level: options.level\n            });\n        }\n    }\n    if (options.serializers) {\n        self.addSerializers(options.serializers);\n    }\n    if (options.src) {\n        this.src = true;\n    }\n    xxx('Logger: ', self)\n\n    // Fields.\n    // These are the default fields for log records (minus the attributes\n    // removed in this constructor). To allow storing raw log records\n    // (unrendered), `this.fields` must never be mutated. Create a copy for\n    // any changes.\n    var fields = objCopy(options);\n    delete fields.stream;\n    delete fields.level;\n    delete fields.streams;\n    delete fields.serializers;\n    delete fields.src;\n    if (this.serializers) {\n        this._applySerializers(fields);\n    }\n    if (!fields.hostname && !self.fields.hostname) {\n        fields.hostname = os.hostname();\n    }\n    if (!fields.pid) {\n        fields.pid = process.pid;\n    }\n    Object.keys(fields).forEach(function (k) {\n        self.fields[k] = fields[k];\n    });\n}\n\nutil.inherits(Logger, EventEmitter);\n\n\n/**\n * Add a stream\n *\n * @param stream {Object}. Object with these fields:\n *    - `type`: The stream type. See README.md for full details.\n *      Often this is implied by the other fields. Examples are\n *      'file', 'stream' and \"raw\".\n *    - `path` or `stream`: The specify the file path or writeable\n *      stream to which log records are written. E.g.\n *      `stream: process.stdout`.\n *    - `level`: Optional. Falls back to `defaultLevel`.\n *    - `closeOnExit` (boolean): Optional. Default is true for a\n *      'file' stream when `path` is given, false otherwise.\n *    See README.md for full details.\n * @param defaultLevel {Number|String} Optional. A level to use if\n *      `stream.level` is not set. If neither is given, this defaults to INFO.\n */\nLogger.prototype.addStream = function addStream(s, defaultLevel) {\n    var self = this;\n    if (defaultLevel === null || defaultLevel === undefined) {\n        defaultLevel = INFO;\n    }\n\n    s = objCopy(s);\n\n    // Implicit 'type' from other args.\n    if (!s.type) {\n        if (s.stream) {\n            s.type = 'stream';\n        } else if (s.path) {\n            s.type = 'file'\n        }\n    }\n    s.raw = (s.type === 'raw');  // PERF: Allow for faster check in `_emit`.\n\n    if (s.level !== undefined) {\n        s.level = resolveLevel(s.level);\n    } else {\n        s.level = resolveLevel(defaultLevel);\n    }\n    if (s.level < self._level) {\n        self._level = s.level;\n    }\n\n    switch (s.type) {\n    case 'stream':\n        assert.ok(isWritable(s.stream),\n                  '\"stream\" stream is not writable: ' + util.inspect(s.stream));\n\n        if (!s.closeOnExit) {\n            s.closeOnExit = false;\n        }\n        break;\n    case 'file':\n        if (s.reemitErrorEvents === undefined) {\n            s.reemitErrorEvents = true;\n        }\n        if (!s.stream) {\n            s.stream = fs.createWriteStream(s.path,\n                                            {flags: 'a', encoding: 'utf8'});\n            if (!s.closeOnExit) {\n                s.closeOnExit = true;\n            }\n        } else {\n            if (!s.closeOnExit) {\n                s.closeOnExit = false;\n            }\n        }\n        break;\n    case 'rotating-file':\n        assert.ok(!s.stream,\n                  '\"rotating-file\" stream should not give a \"stream\"');\n        assert.ok(s.path);\n        assert.ok(mv, '\"rotating-file\" stream type is not supported: '\n                      + 'missing \"mv\" module');\n        s.stream = new RotatingFileStream(s);\n        if (!s.closeOnExit) {\n            s.closeOnExit = true;\n        }\n        break;\n    case 'raw':\n        if (!s.closeOnExit) {\n            s.closeOnExit = false;\n        }\n        break;\n    default:\n        throw new TypeError('unknown stream type \"' + s.type + '\"');\n    }\n\n    if (s.reemitErrorEvents && typeof (s.stream.on) === 'function') {\n        // TODO: When we have `<logger>.close()`, it should remove event\n        //      listeners to not leak Logger instances.\n        s.stream.on('error', function onStreamError(err) {\n            self.emit('error', err, s);\n        });\n    }\n\n    self.streams.push(s);\n    delete self.haveNonRawStreams;  // reset\n}\n\n\n/**\n * Add serializers\n *\n * @param serializers {Object} Optional. Object mapping log record field names\n *    to serializing functions. See README.md for details.\n */\nLogger.prototype.addSerializers = function addSerializers(serializers) {\n    var self = this;\n\n    if (!self.serializers) {\n        self.serializers = {};\n    }\n    Object.keys(serializers).forEach(function (field) {\n        var serializer = serializers[field];\n        if (typeof (serializer) !== 'function') {\n            throw new TypeError(format(\n                'invalid serializer for \"%s\" field: must be a function',\n                field));\n        } else {\n            self.serializers[field] = serializer;\n        }\n    });\n}\n\n\n\n/**\n * Create a child logger, typically to add a few log record fields.\n *\n * This can be useful when passing a logger to a sub-component, e.g. a\n * 'wuzzle' component of your service:\n *\n *    var wuzzleLog = log.child({component: 'wuzzle'})\n *    var wuzzle = new Wuzzle({..., log: wuzzleLog})\n *\n * Then log records from the wuzzle code will have the same structure as\n * the app log, *plus the component='wuzzle' field*.\n *\n * @param options {Object} Optional. Set of options to apply to the child.\n *    All of the same options for a new Logger apply here. Notes:\n *      - The parent's streams are inherited and cannot be removed in this\n *        call. Any given `streams` are *added* to the set inherited from\n *        the parent.\n *      - The parent's serializers are inherited, though can effectively be\n *        overwritten by using duplicate keys.\n *      - Can use `level` to set the level of the streams inherited from\n *        the parent. The level for the parent is NOT affected.\n * @param simple {Boolean} Optional. Set to true to assert that `options`\n *    (a) only add fields (no config) and (b) no serialization handling is\n *    required for them. IOW, this is a fast path for frequent child\n *    creation. See 'tools/timechild.js' for numbers.\n */\nLogger.prototype.child = function (options, simple) {\n    return new (this.constructor)(this, options || {}, simple);\n}\n\n\n/**\n * A convenience method to reopen 'file' streams on a logger. This can be\n * useful with external log rotation utilities that move and re-open log files\n * (e.g. logrotate on Linux, logadm on SmartOS/Illumos). Those utilities\n * typically have rotation options to copy-and-truncate the log file, but\n * you may not want to use that. An alternative is to do this in your\n * application:\n *\n *      var log = bunyan.createLogger(...);\n *      ...\n *      process.on('SIGUSR2', function () {\n *          log.reopenFileStreams();\n *      });\n *      ...\n *\n * See <https://github.com/trentm/node-bunyan/issues/104>.\n */\nLogger.prototype.reopenFileStreams = function () {\n    var self = this;\n    self.streams.forEach(function (s) {\n        if (s.type === 'file') {\n            if (s.stream) {\n                // Not sure if typically would want this, or more immediate\n                // `s.stream.destroy()`.\n                s.stream.end();\n                s.stream.destroySoon();\n                delete s.stream;\n            }\n            s.stream = fs.createWriteStream(s.path,\n                {flags: 'a', encoding: 'utf8'});\n            s.stream.on('error', function (err) {\n                self.emit('error', err, s);\n            });\n        }\n    });\n};\n\n\n/* BEGIN JSSTYLED */\n/**\n * Close this logger.\n *\n * This closes streams (that it owns, as per 'endOnClose' attributes on\n * streams), etc. Typically you **don't** need to bother calling this.\nLogger.prototype.close = function () {\n    if (this._closed) {\n        return;\n    }\n    if (!this._isSimpleChild) {\n        self.streams.forEach(function (s) {\n            if (s.endOnClose) {\n                xxx('closing stream s:', s);\n                s.stream.end();\n                s.endOnClose = false;\n            }\n        });\n    }\n    this._closed = true;\n}\n */\n/* END JSSTYLED */\n\n\n/**\n * Get/set the level of all streams on this logger.\n *\n * Get Usage:\n *    // Returns the current log level (lowest level of all its streams).\n *    log.level() -> INFO\n *\n * Set Usage:\n *    log.level(INFO)       // set all streams to level INFO\n *    log.level('info')     // can use 'info' et al aliases\n */\nLogger.prototype.level = function level(value) {\n    if (value === undefined) {\n        return this._level;\n    }\n    var newLevel = resolveLevel(value);\n    var len = this.streams.length;\n    for (var i = 0; i < len; i++) {\n        this.streams[i].level = newLevel;\n    }\n    this._level = newLevel;\n}\n\n\n/**\n * Get/set the level of a particular stream on this logger.\n *\n * Get Usage:\n *    // Returns an array of the levels of each stream.\n *    log.levels() -> [TRACE, INFO]\n *\n *    // Returns a level of the identified stream.\n *    log.levels(0) -> TRACE      // level of stream at index 0\n *    log.levels('foo')           // level of stream with name 'foo'\n *\n * Set Usage:\n *    log.levels(0, INFO)         // set level of stream 0 to INFO\n *    log.levels(0, 'info')       // can use 'info' et al aliases\n *    log.levels('foo', WARN)     // set stream named 'foo' to WARN\n *\n * Stream names: When streams are defined, they can optionally be given\n * a name. For example,\n *       log = new Logger({\n *         streams: [\n *           {\n *             name: 'foo',\n *             path: '/var/log/my-service/foo.log'\n *             level: 'trace'\n *           },\n *         ...\n *\n * @param name {String|Number} The stream index or name.\n * @param value {Number|String} The level value (INFO) or alias ('info').\n *    If not given, this is a 'get' operation.\n * @throws {Error} If there is no stream with the given name.\n */\nLogger.prototype.levels = function levels(name, value) {\n    if (name === undefined) {\n        assert.equal(value, undefined);\n        return this.streams.map(\n            function (s) { return s.level });\n    }\n    var stream;\n    if (typeof (name) === 'number') {\n        stream = this.streams[name];\n        if (stream === undefined) {\n            throw new Error('invalid stream index: ' + name);\n        }\n    } else {\n        var len = this.streams.length;\n        for (var i = 0; i < len; i++) {\n            var s = this.streams[i];\n            if (s.name === name) {\n                stream = s;\n                break;\n            }\n        }\n        if (!stream) {\n            throw new Error(format('no stream with name \"%s\"', name));\n        }\n    }\n    if (value === undefined) {\n        return stream.level;\n    } else {\n        var newLevel = resolveLevel(value);\n        stream.level = newLevel;\n        if (newLevel < this._level) {\n            this._level = newLevel;\n        }\n    }\n}\n\n\n/**\n * Apply registered serializers to the appropriate keys in the given fields.\n *\n * Pre-condition: This is only called if there is at least one serializer.\n *\n * @param fields (Object) The log record fields.\n * @param excludeFields (Object) Optional mapping of keys to `true` for\n *    keys to NOT apply a serializer.\n */\nLogger.prototype._applySerializers = function (fields, excludeFields) {\n    var self = this;\n\n    xxx('_applySerializers: excludeFields', excludeFields);\n\n    // Check each serializer against these (presuming number of serializers\n    // is typically less than number of fields).\n    Object.keys(this.serializers).forEach(function (name) {\n        if (fields[name] === undefined ||\n            (excludeFields && excludeFields[name]))\n        {\n            return;\n        }\n        xxx('_applySerializers; apply to \"%s\" key', name)\n        try {\n            fields[name] = self.serializers[name](fields[name]);\n        } catch (err) {\n            _warn(format('bunyan: ERROR: Exception thrown from the \"%s\" '\n                + 'Bunyan serializer. This should never happen. This is a bug '\n                + 'in that serializer function.\\n%s',\n                name, err.stack || err));\n            fields[name] = format('(Error in Bunyan log \"%s\" serializer '\n                + 'broke field. See stderr for details.)', name);\n        }\n    });\n}\n\n\n/**\n * Emit a log record.\n *\n * @param rec {log record}\n * @param noemit {Boolean} Optional. Set to true to skip emission\n *      and just return the JSON string.\n */\nLogger.prototype._emit = function (rec, noemit) {\n    var i;\n\n    // Lazily determine if this Logger has non-'raw' streams. If there are\n    // any, then we need to stringify the log record.\n    if (this.haveNonRawStreams === undefined) {\n        this.haveNonRawStreams = false;\n        for (i = 0; i < this.streams.length; i++) {\n            if (!this.streams[i].raw) {\n                this.haveNonRawStreams = true;\n                break;\n            }\n        }\n    }\n\n    // Stringify the object (creates a warning str on error).\n    var str;\n    if (noemit || this.haveNonRawStreams) {\n        str = fastAndSafeJsonStringify(rec) + os.EOL;\n    }\n\n    if (noemit)\n        return str;\n\n    var level = rec.level;\n    for (i = 0; i < this.streams.length; i++) {\n        var s = this.streams[i];\n        if (s.level <= level) {\n            xxx('writing log rec \"%s\" to \"%s\" stream (%d <= %d): %j',\n                rec.msg, s.type, s.level, level, rec);\n            s.stream.write(s.raw ? rec : str);\n        }\n    };\n\n    return str;\n}\n\n\n/**\n * Build a record object suitable for emitting from the arguments\n * provided to the a log emitter.\n */\nfunction mkRecord(log, minLevel, args) {\n    var excludeFields, fields, msgArgs;\n    if (args[0] instanceof Error) {\n        // `log.<level>(err, ...)`\n        fields = {\n            // Use this Logger's err serializer, if defined.\n            err: (log.serializers && log.serializers.err\n                ? log.serializers.err(args[0])\n                : Logger.stdSerializers.err(args[0]))\n        };\n        excludeFields = {err: true};\n        if (args.length === 1) {\n            msgArgs = [fields.err.message];\n        } else {\n            msgArgs = args.slice(1);\n        }\n    } else if (typeof (args[0]) !== 'object' || Array.isArray(args[0])) {\n        // `log.<level>(msg, ...)`\n        fields = null;\n        msgArgs = args.slice();\n    } else if (Buffer.isBuffer(args[0])) {  // `log.<level>(buf, ...)`\n        // Almost certainly an error, show `inspect(buf)`. See bunyan\n        // issue #35.\n        fields = null;\n        msgArgs = args.slice();\n        msgArgs[0] = util.inspect(msgArgs[0]);\n    } else {  // `log.<level>(fields, msg, ...)`\n        fields = args[0];\n        if (fields && args.length === 1 && fields.err &&\n            fields.err instanceof Error)\n        {\n            msgArgs = [fields.err.message];\n        } else {\n            msgArgs = args.slice(1);\n        }\n    }\n\n    // Build up the record object.\n    var rec = objCopy(log.fields);\n    var level = rec.level = minLevel;\n    var recFields = (fields ? objCopy(fields) : null);\n    if (recFields) {\n        if (log.serializers) {\n            log._applySerializers(recFields, excludeFields);\n        }\n        Object.keys(recFields).forEach(function (k) {\n            rec[k] = recFields[k];\n        });\n    }\n    rec.msg = format.apply(log, msgArgs);\n    if (!rec.time) {\n        rec.time = (new Date());\n    }\n    // Get call source info\n    if (log.src && !rec.src) {\n        rec.src = getCaller3Info()\n    }\n    rec.v = LOG_VERSION;\n\n    return rec;\n};\n\n\n/**\n * Build an array that dtrace-provider can use to fire a USDT probe. If we've\n * already built the appropriate string, we use it. Otherwise, build the\n * record object and stringify it.\n */\nfunction mkProbeArgs(str, log, minLevel, msgArgs) {\n    return [ str || log._emit(mkRecord(log, minLevel, msgArgs), true) ];\n}\n\n\n/**\n * Build a log emitter function for level minLevel. I.e. this is the\n * creator of `log.info`, `log.error`, etc.\n */\nfunction mkLogEmitter(minLevel) {\n    return function () {\n        var log = this;\n        var str = null;\n        var rec = null;\n\n        if (!this._emit) {\n            /*\n             * Show this invalid Bunyan usage warning *once*.\n             *\n             * See <https://github.com/trentm/node-bunyan/issues/100> for\n             * an example of how this can happen.\n             */\n            var dedupKey = 'unbound';\n            if (!_haveWarned[dedupKey]) {\n                var caller = getCaller3Info();\n                _warn(format('bunyan usage error: %s:%s: attempt to log '\n                    + 'with an unbound log method: `this` is: %s',\n                    caller.file, caller.line, util.inspect(this)),\n                    dedupKey);\n            }\n            return;\n        } else if (arguments.length === 0) {   // `log.<level>()`\n            return (this._level <= minLevel);\n        }\n\n        var msgArgs = new Array(arguments.length);\n        for (var i = 0; i < msgArgs.length; ++i) {\n            msgArgs[i] = arguments[i];\n        }\n\n        if (this._level <= minLevel) {\n            rec = mkRecord(log, minLevel, msgArgs);\n            str = this._emit(rec);\n        }\n\n        if (probes) {\n            probes[minLevel].fire(mkProbeArgs, str, log, minLevel, msgArgs);\n        }\n    }\n}\n\n\n/**\n * The functions below log a record at a specific level.\n *\n * Usages:\n *    log.<level>()  -> boolean is-trace-enabled\n *    log.<level>(<Error> err, [<string> msg, ...])\n *    log.<level>(<string> msg, ...)\n *    log.<level>(<object> fields, <string> msg, ...)\n *\n * where <level> is the lowercase version of the log level. E.g.:\n *\n *    log.info()\n *\n * @params fields {Object} Optional set of additional fields to log.\n * @params msg {String} Log message. This can be followed by additional\n *    arguments that are handled like\n *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).\n */\nLogger.prototype.trace = mkLogEmitter(TRACE);\nLogger.prototype.debug = mkLogEmitter(DEBUG);\nLogger.prototype.info = mkLogEmitter(INFO);\nLogger.prototype.warn = mkLogEmitter(WARN);\nLogger.prototype.error = mkLogEmitter(ERROR);\nLogger.prototype.fatal = mkLogEmitter(FATAL);\n\n\n\n//---- Standard serializers\n// A serializer is a function that serializes a JavaScript object to a\n// JSON representation for logging. There is a standard set of presumed\n// interesting objects in node.js-land.\n\nLogger.stdSerializers = {};\n\n// Serialize an HTTP request.\nLogger.stdSerializers.req = function (req) {\n    if (!req || !req.connection)\n        return req;\n    return {\n        method: req.method,\n        url: req.url,\n        headers: req.headers,\n        remoteAddress: req.connection.remoteAddress,\n        remotePort: req.connection.remotePort\n    };\n    // Trailers: Skipping for speed. If you need trailers in your app, then\n    // make a custom serializer.\n    //if (Object.keys(trailers).length > 0) {\n    //  obj.trailers = req.trailers;\n    //}\n};\n\n// Serialize an HTTP response.\nLogger.stdSerializers.res = function (res) {\n    if (!res || !res.statusCode)\n        return res;\n    return {\n        statusCode: res.statusCode,\n        header: res._header\n    }\n};\n\n\n/*\n * This function dumps long stack traces for exceptions having a cause()\n * method. The error classes from\n * [verror](https://github.com/davepacheco/node-verror) and\n * [restify v2.0](https://github.com/mcavage/node-restify) are examples.\n *\n * Based on `dumpException` in\n * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js\n */\nfunction getFullErrorStack(ex)\n{\n    var ret = ex.stack || ex.toString();\n    if (ex.cause && typeof (ex.cause) === 'function') {\n        var cex = ex.cause();\n        if (cex) {\n            ret += '\\nCaused by: ' + getFullErrorStack(cex);\n        }\n    }\n    return (ret);\n}\n\n// Serialize an Error object\n// (Core error properties are enumerable in node 0.4, not in 0.6).\nvar errSerializer = Logger.stdSerializers.err = function (err) {\n    if (!err || !err.stack)\n        return err;\n    var obj = {\n        message: err.message,\n        name: err.name,\n        stack: getFullErrorStack(err),\n        code: err.code,\n        signal: err.signal\n    }\n    return obj;\n};\n\n\n// A JSON stringifier that handles cycles safely - tracks seen values in a Set.\nfunction safeCyclesSet() {\n    var seen = new Set();\n    return function (key, val) {\n        if (!val || typeof (val) !== 'object') {\n            return val;\n        }\n        if (seen.has(val)) {\n            return '[Circular]';\n        }\n        seen.add(val);\n        return val;\n    };\n}\n\n/**\n * A JSON stringifier that handles cycles safely - tracks seen vals in an Array.\n *\n * Note: This approach has performance problems when dealing with large objects,\n * see trentm/node-bunyan#445, but since this is the only option for node 0.10\n * and earlier (as Set was introduced in Node 0.12), it's used as a fallback\n * when Set is not available.\n */\nfunction safeCyclesArray() {\n    var seen = [];\n    return function (key, val) {\n        if (!val || typeof (val) !== 'object') {\n            return val;\n        }\n        if (seen.indexOf(val) !== -1) {\n            return '[Circular]';\n        }\n        seen.push(val);\n        return val;\n    };\n}\n\n/**\n * A JSON stringifier that handles cycles safely.\n *\n * Usage: JSON.stringify(obj, safeCycles())\n *\n * Choose the best safe cycle function from what is available - see\n * trentm/node-bunyan#445.\n */\nvar safeCycles = typeof (Set) !== 'undefined' ? safeCyclesSet : safeCyclesArray;\n\n/**\n * A fast JSON.stringify that handles cycles and getter exceptions (when\n * safeJsonStringify is installed).\n *\n * This function attempts to use the regular JSON.stringify for speed, but on\n * error (e.g. JSON cycle detection exception) it falls back to safe stringify\n * handlers that can deal with cycles and/or getter exceptions.\n */\nfunction fastAndSafeJsonStringify(rec) {\n    try {\n        return JSON.stringify(rec);\n    } catch (ex) {\n        try {\n            return JSON.stringify(rec, safeCycles());\n        } catch (e) {\n            if (safeJsonStringify) {\n                return safeJsonStringify(rec);\n            } else {\n                var dedupKey = e.stack.split(/\\n/g, 3).join('\\n');\n                _warn('bunyan: ERROR: Exception in '\n                    + '`JSON.stringify(rec)`. You can install the '\n                    + '\"safe-json-stringify\" module to have Bunyan fallback '\n                    + 'to safer stringification. Record:\\n'\n                    + _indent(format('%s\\n%s', util.inspect(rec), e.stack)),\n                    dedupKey);\n                return format('(Exception in JSON.stringify(rec): %j. '\n                    + 'See stderr for details.)', e.message);\n            }\n        }\n    }\n}\n\n\nvar RotatingFileStream = null;\nif (mv) {\n\nRotatingFileStream = function RotatingFileStream(options) {\n    this.path = options.path;\n\n    this.count = (options.count == null ? 10 : options.count);\n    assert.equal(typeof (this.count), 'number',\n        format('rotating-file stream \"count\" is not a number: %j (%s) in %j',\n            this.count, typeof (this.count), this));\n    assert.ok(this.count >= 0,\n        format('rotating-file stream \"count\" is not >= 0: %j in %j',\n            this.count, this));\n\n    // Parse `options.period`.\n    if (options.period) {\n        // <number><scope> where scope is:\n        //    h   hours (at the start of the hour)\n        //    d   days (at the start of the day, i.e. just after midnight)\n        //    w   weeks (at the start of Sunday)\n        //    m   months (on the first of the month)\n        //    y   years (at the start of Jan 1st)\n        // with special values 'hourly' (1h), 'daily' (1d), \"weekly\" (1w),\n        // 'monthly' (1m) and 'yearly' (1y)\n        var period = {\n            'hourly': '1h',\n            'daily': '1d',\n            'weekly': '1w',\n            'monthly': '1m',\n            'yearly': '1y'\n        }[options.period] || options.period;\n        var m = /^([1-9][0-9]*)([hdwmy]|ms)$/.exec(period);\n        if (!m) {\n            throw new Error(format('invalid period: \"%s\"', options.period));\n        }\n        this.periodNum = Number(m[1]);\n        this.periodScope = m[2];\n    } else {\n        this.periodNum = 1;\n        this.periodScope = 'd';\n    }\n\n    var lastModified = null;\n    try {\n        var fileInfo = fs.statSync(this.path);\n        lastModified = fileInfo.mtime.getTime();\n    }\n    catch (err) {\n        // file doesn't exist\n    }\n    var rotateAfterOpen = false;\n    if (lastModified) {\n        var lastRotTime = this._calcRotTime(0);\n        if (lastModified < lastRotTime) {\n            rotateAfterOpen = true;\n        }\n    }\n\n    // TODO: template support for backup files\n    // template: <path to which to rotate>\n    //      default is %P.%n\n    //      '/var/log/archive/foo.log'  -> foo.log.%n\n    //      '/var/log/archive/foo.log.%n'\n    //      codes:\n    //          XXX support strftime codes (per node version of those)\n    //              or whatever module. Pick non-colliding for extra\n    //              codes\n    //          %P      `path` base value\n    //          %n      integer number of rotated log (1,2,3,...)\n    //          %d      datetime in YYYY-MM-DD_HH-MM-SS\n    //                      XXX what should default date format be?\n    //                          prior art? Want to avoid ':' in\n    //                          filenames (illegal on Windows for one).\n\n    this.stream = fs.createWriteStream(this.path,\n        {flags: 'a', encoding: 'utf8'});\n\n    this.rotQueue = [];\n    this.rotating = false;\n    if (rotateAfterOpen) {\n        this._debug('rotateAfterOpen -> call rotate()');\n        this.rotate();\n    } else {\n        this._setupNextRot();\n    }\n}\n\nutil.inherits(RotatingFileStream, EventEmitter);\n\nRotatingFileStream.prototype._debug = function () {\n    // Set this to `true` to add debug logging.\n    if (false) { var args; } else {\n        return false;\n    }\n};\n\nRotatingFileStream.prototype._setupNextRot = function () {\n    this.rotAt = this._calcRotTime(1);\n    this._setRotationTimer();\n}\n\nRotatingFileStream.prototype._setRotationTimer = function () {\n    var self = this;\n    var delay = this.rotAt - Date.now();\n    // Cap timeout to Node's max setTimeout, see\n    // <https://github.com/joyent/node/issues/8656>.\n    var TIMEOUT_MAX = 2147483647; // 2^31-1\n    if (delay > TIMEOUT_MAX) {\n        delay = TIMEOUT_MAX;\n    }\n    this.timeout = setTimeout(\n        function () {\n            self._debug('_setRotationTimer timeout -> call rotate()');\n            self.rotate();\n        },\n        delay);\n    if (typeof (this.timeout.unref) === 'function') {\n        this.timeout.unref();\n    }\n}\n\nRotatingFileStream.prototype._calcRotTime =\nfunction _calcRotTime(periodOffset) {\n    this._debug('_calcRotTime: %s%s', this.periodNum, this.periodScope);\n    var d = new Date();\n\n    this._debug('  now local: %s', d);\n    this._debug('    now utc: %s', d.toISOString());\n    var rotAt;\n    switch (this.periodScope) {\n    case 'ms':\n        // Hidden millisecond period for debugging.\n        if (this.rotAt) {\n            rotAt = this.rotAt + this.periodNum * periodOffset;\n        } else {\n            rotAt = Date.now() + this.periodNum * periodOffset;\n        }\n        break;\n    case 'h':\n        if (this.rotAt) {\n            rotAt = this.rotAt + this.periodNum * 60 * 60 * 1000 * periodOffset;\n        } else {\n            // First time: top of the next hour.\n            rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(),\n                d.getUTCDate(), d.getUTCHours() + periodOffset);\n        }\n        break;\n    case 'd':\n        if (this.rotAt) {\n            rotAt = this.rotAt + this.periodNum * 24 * 60 * 60 * 1000\n                * periodOffset;\n        } else {\n            // First time: start of tomorrow (i.e. at the coming midnight) UTC.\n            rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(),\n                d.getUTCDate() + periodOffset);\n        }\n        break;\n    case 'w':\n        // Currently, always on Sunday morning at 00:00:00 (UTC).\n        if (this.rotAt) {\n            rotAt = this.rotAt + this.periodNum * 7 * 24 * 60 * 60 * 1000\n                * periodOffset;\n        } else {\n            // First time: this coming Sunday.\n            var dayOffset = (7 - d.getUTCDay());\n            if (periodOffset < 1) {\n                dayOffset = -d.getUTCDay();\n            }\n            if (periodOffset > 1 || periodOffset < -1) {\n                dayOffset += 7 * periodOffset;\n            }\n            rotAt = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(),\n                d.getUTCDate() + dayOffset);\n        }\n        break;\n    case 'm':\n        if (this.rotAt) {\n            rotAt = Date.UTC(d.getUTCFullYear(),\n                d.getUTCMonth() + this.periodNum * periodOffset, 1);\n        } else {\n            // First time: the start of the next month.\n            rotAt = Date.UTC(d.getUTCFullYear(),\n                d.getUTCMonth() + periodOffset, 1);\n        }\n        break;\n    case 'y':\n        if (this.rotAt) {\n            rotAt = Date.UTC(d.getUTCFullYear() + this.periodNum * periodOffset,\n                0, 1);\n        } else {\n            // First time: the start of the next year.\n            rotAt = Date.UTC(d.getUTCFullYear() + periodOffset, 0, 1);\n        }\n        break;\n    default:\n        assert.fail(format('invalid period scope: \"%s\"', this.periodScope));\n    }\n\n    if (this._debug()) {\n        this._debug('  **rotAt**: %s (utc: %s)', rotAt,\n            new Date(rotAt).toUTCString());\n        var now = Date.now();\n        this._debug('        now: %s (%sms == %smin == %sh to go)',\n            now,\n            rotAt - now,\n            (rotAt-now)/1000/60,\n            (rotAt-now)/1000/60/60);\n    }\n    return rotAt;\n};\n\nRotatingFileStream.prototype.rotate = function rotate() {\n    // XXX What about shutdown?\n    var self = this;\n\n    // If rotation period is > ~25 days, we have to break into multiple\n    // setTimeout's. See <https://github.com/joyent/node/issues/8656>.\n    if (self.rotAt && self.rotAt > Date.now()) {\n        return self._setRotationTimer();\n    }\n\n    this._debug('rotate');\n    if (self.rotating) {\n        throw new TypeError('cannot start a rotation when already rotating');\n    }\n    self.rotating = true;\n\n    self.stream.end();  // XXX can do moves sync after this? test at high rate\n\n    function del() {\n        var toDel = self.path + '.' + String(n - 1);\n        if (n === 0) {\n            toDel = self.path;\n        }\n        n -= 1;\n        self._debug('  rm %s', toDel);\n        fs.unlink(toDel, function (delErr) {\n            //XXX handle err other than not exists\n            moves();\n        });\n    }\n\n    function moves() {\n        if (self.count === 0 || n < 0) {\n            return finish();\n        }\n        var before = self.path;\n        var after = self.path + '.' + String(n);\n        if (n > 0) {\n            before += '.' + String(n - 1);\n        }\n        n -= 1;\n        fs.exists(before, function (exists) {\n            if (!exists) {\n                moves();\n            } else {\n                self._debug('  mv %s %s', before, after);\n                mv(before, after, function (mvErr) {\n                    if (mvErr) {\n                        self.emit('error', mvErr);\n                        finish(); // XXX finish here?\n                    } else {\n                        moves();\n                    }\n                });\n            }\n        })\n    }\n\n    function finish() {\n        self._debug('  open %s', self.path);\n        self.stream = fs.createWriteStream(self.path,\n            {flags: 'a', encoding: 'utf8'});\n        var q = self.rotQueue, len = q.length;\n        for (var i = 0; i < len; i++) {\n            self.stream.write(q[i]);\n        }\n        self.rotQueue = [];\n        self.rotating = false;\n        self.emit('drain');\n        self._setupNextRot();\n    }\n\n    var n = this.count;\n    del();\n};\n\nRotatingFileStream.prototype.write = function write(s) {\n    if (this.rotating) {\n        this.rotQueue.push(s);\n        return false;\n    } else {\n        return this.stream.write(s);\n    }\n};\n\nRotatingFileStream.prototype.end = function end(s) {\n    this.stream.end();\n};\n\nRotatingFileStream.prototype.destroy = function destroy(s) {\n    this.stream.destroy();\n};\n\nRotatingFileStream.prototype.destroySoon = function destroySoon(s) {\n    this.stream.destroySoon();\n};\n\n} /* if (mv) */\n\n\n\n/**\n * RingBuffer is a Writable Stream that just stores the last N records in\n * memory.\n *\n * @param options {Object}, with the following fields:\n *\n *    - limit: number of records to keep in memory\n */\nfunction RingBuffer(options) {\n    this.limit = options && options.limit ? options.limit : 100;\n    this.writable = true;\n    this.records = [];\n    EventEmitter.call(this);\n}\n\nutil.inherits(RingBuffer, EventEmitter);\n\nRingBuffer.prototype.write = function (record) {\n    if (!this.writable)\n        throw (new Error('RingBuffer has been ended already'));\n\n    this.records.push(record);\n\n    if (this.records.length > this.limit)\n        this.records.shift();\n\n    return (true);\n};\n\nRingBuffer.prototype.end = function () {\n    if (arguments.length > 0)\n        this.write.apply(this, Array.prototype.slice.call(arguments));\n    this.writable = false;\n};\n\nRingBuffer.prototype.destroy = function () {\n    this.writable = false;\n    this.emit('close');\n};\n\nRingBuffer.prototype.destroySoon = function () {\n    this.destroy();\n};\n\n\n//---- Exports\n\nmodule.exports = Logger;\n\nmodule.exports.TRACE = TRACE;\nmodule.exports.DEBUG = DEBUG;\nmodule.exports.INFO = INFO;\nmodule.exports.WARN = WARN;\nmodule.exports.ERROR = ERROR;\nmodule.exports.FATAL = FATAL;\nmodule.exports.resolveLevel = resolveLevel;\nmodule.exports.levelFromName = levelFromName;\nmodule.exports.nameFromLevel = nameFromLevel;\n\nmodule.exports.VERSION = VERSION;\nmodule.exports.LOG_VERSION = LOG_VERSION;\n\nmodule.exports.createLogger = function createLogger(options) {\n    return new Logger(options);\n};\n\nmodule.exports.RingBuffer = RingBuffer;\nmodule.exports.RotatingFileStream = RotatingFileStream;\n\n// Useful for custom `type == 'raw'` streams that may do JSON stringification\n// of log records themselves. Usage:\n//    var str = JSON.stringify(rec, bunyan.safeCycles());\nmodule.exports.safeCycles = safeCycles;\n\n\n//# sourceURL=webpack:///../shared/node_modules/bunyan/lib/bunyan.js?");

/***/ }),

/***/ "../shared/node_modules/concat-map/index.js":
/*!**************************************************!*\
  !*** ../shared/node_modules/concat-map/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/concat-map/index.js?");

/***/ }),

/***/ "../shared/node_modules/dtrace-provider/dtrace-provider.js":
/*!*****************************************************************!*\
  !*** ../shared/node_modules/dtrace-provider/dtrace-provider.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var DTraceProvider;\n\nfunction DTraceProviderStub() {}\nDTraceProviderStub.prototype.addProbe = function(name) {\n    var p = { 'fire': function () {} };\n    this[name] = p;\n    return (p);\n};\nDTraceProviderStub.prototype.enable = function() {};\nDTraceProviderStub.prototype.fire = function() {};\nDTraceProviderStub.prototype.disable = function() {};\n\nvar builds = ['Release', 'default', 'Debug'];\nvar err = null;\n\nfor (var i = 0; i < builds.length; i++) {\n    try {\n        var binding = __webpack_require__(\"../shared/node_modules/dtrace-provider/src/build sync recursive ^\\\\.\\\\/.*\\\\/DTraceProviderBindings$\")(\"./\" + builds[i] + \"/DTraceProviderBindings\");\n        DTraceProvider = binding.DTraceProvider;\n        break;\n    } catch (e) {\n        if (err === null) {\n            err = e;\n        }\n    }\n}\n\nif (!DTraceProvider) {\n    if (process.env.NODE_DTRACE_PROVIDER_REQUIRE === 'hard') {\n        throw err;\n    } else {\n        DTraceProvider = DTraceProviderStub;\n    }\n}\n\nexports.DTraceProvider = DTraceProvider;\nexports.createDTraceProvider = function(name, module) {\n    if (arguments.length == 2)\n        return (new exports.DTraceProvider(name, module));\n    return (new exports.DTraceProvider(name));\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/dtrace-provider/dtrace-provider.js?");

/***/ }),

/***/ "../shared/node_modules/dtrace-provider/src/build sync recursive ^\\.\\/.*\\/DTraceProviderBindings$":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/dtrace-provider/src/build sync ^\.\/.*\/DTraceProviderBindings$ ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../shared/node_modules/dtrace-provider/src/build sync recursive ^\\\\.\\\\/.*\\\\/DTraceProviderBindings$\";\n\n//# sourceURL=webpack:///../shared/node_modules/dtrace-provider/src/build_sync_^\\.\\/.*\\/DTraceProviderBindings$?");

/***/ }),

/***/ "../shared/node_modules/glob/common.js":
/*!*********************************************!*\
  !*** ../shared/node_modules/glob/common.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = __webpack_require__(/*! path */ \"path\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../shared/node_modules/minimatch/minimatch.js\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../shared/node_modules/path-is-absolute/index.js\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = options.cwd\n    self.changedCwd = path.resolve(options.cwd) !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        return !(/\\/$/.test(e))\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/glob/common.js?");

/***/ }),

/***/ "../shared/node_modules/glob/glob.js":
/*!*******************************************!*\
  !*** ../shared/node_modules/glob/glob.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../shared/node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(/*! inherits */ \"../shared/node_modules/inherits/inherits.js\")\nvar EE = __webpack_require__(/*! events */ \"events\").EventEmitter\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../shared/node_modules/path-is-absolute/index.js\")\nvar globSync = __webpack_require__(/*! ./sync.js */ \"../shared/node_modules/glob/sync.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"../shared/node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(/*! inflight */ \"../shared/node_modules/inflight/inflight.js\")\nvar util = __webpack_require__(/*! util */ \"util\")\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(/*! once */ \"../shared/node_modules/once/once.js\")\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  var n = this.minimatch.set.length\n  this._processing = 0\n  this.matches = new Array(n)\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    fs.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (this.matches[index][e])\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = this._makeAbs(e)\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  if (this.mark)\n    e = this._mark(e)\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er)\n      return cb()\n\n    var isSym = lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      this.cache[this._makeAbs(f)] = 'FILE'\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c !== 'DIR')\n    return cb()\n\n  return cb(null, c, stat)\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/glob/glob.js?");

/***/ }),

/***/ "../shared/node_modules/glob/sync.js":
/*!*******************************************!*\
  !*** ../shared/node_modules/glob/sync.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar minimatch = __webpack_require__(/*! minimatch */ \"../shared/node_modules/minimatch/minimatch.js\")\nvar Minimatch = minimatch.Minimatch\nvar Glob = __webpack_require__(/*! ./glob.js */ \"../shared/node_modules/glob/glob.js\").Glob\nvar util = __webpack_require__(/*! util */ \"util\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"../shared/node_modules/path-is-absolute/index.js\")\nvar common = __webpack_require__(/*! ./common.js */ \"../shared/node_modules/glob/common.js\")\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = fs.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this.matches[index][e] = true\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  var abs = this._makeAbs(e)\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[this._makeAbs(e)]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    // lstat failed, doesn't exist\n    return null\n  }\n\n  var isSym = lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      this.cache[this._makeAbs(f)] = 'FILE'\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this.matches[index][prefix] = true\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      return false\n    }\n\n    if (lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c !== 'DIR')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/glob/sync.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/BuildInfo.js":
/*!****************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/BuildInfo.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BuildInfo = void 0;\nconst clientVersion = __webpack_require__(/*! ../package.json */ \"../shared/node_modules/hazelcast-client/package.json\").version;\n/** @internal */\nclass BuildInfo {\n    static calculateServerVersionFromString(versionString) {\n        if (versionString == null) {\n            return BuildInfo.UNKNOWN_VERSION_ID;\n        }\n        const info = BuildInfo.PATTERN.exec(versionString);\n        if (info == null) {\n            return -1;\n        }\n        const major = Number.parseInt(info[1]);\n        const minor = Number.parseInt(info[2]);\n        let patch;\n        if (info[3] == null) {\n            patch = 0;\n        }\n        else {\n            patch = Number.parseInt(info[3]);\n        }\n        return this.calculateServerVersion(major, minor, patch);\n    }\n    static calculateServerVersion(major, minor, patch) {\n        return BuildInfo.MAJOR_VERSION_MULTIPLIER * major + BuildInfo.MINOR_VERSION_MULTIPLIER * minor + patch;\n    }\n    static getClientVersion() {\n        return clientVersion;\n    }\n}\nexports.BuildInfo = BuildInfo;\nBuildInfo.UNKNOWN_VERSION_ID = -1;\nBuildInfo.MAJOR_VERSION_MULTIPLIER = 10000;\nBuildInfo.MINOR_VERSION_MULTIPLIER = 100;\nBuildInfo.PATTERN = /^([\\d]+)\\.([\\d]+)(?:\\.([\\d]+))?(-[\\w]+)?(-SNAPSHOT)?(-BETA-.)?$/;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/BuildInfo.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/HazelcastClient.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/HazelcastClient.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HazelcastClient = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst ClientGetDistributedObjectsCodec_1 = __webpack_require__(/*! ./codec/ClientGetDistributedObjectsCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientGetDistributedObjectsCodec.js\");\nconst ConfigBuilder_1 = __webpack_require__(/*! ./config/ConfigBuilder */ \"../shared/node_modules/hazelcast-client/lib/config/ConfigBuilder.js\");\nconst ClientConnectionManager_1 = __webpack_require__(/*! ./network/ClientConnectionManager */ \"../shared/node_modules/hazelcast-client/lib/network/ClientConnectionManager.js\");\nconst ClusterService_1 = __webpack_require__(/*! ./invocation/ClusterService */ \"../shared/node_modules/hazelcast-client/lib/invocation/ClusterService.js\");\nconst InvocationService_1 = __webpack_require__(/*! ./invocation/InvocationService */ \"../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js\");\nconst LifecycleService_1 = __webpack_require__(/*! ./LifecycleService */ \"../shared/node_modules/hazelcast-client/lib/LifecycleService.js\");\nconst ListenerService_1 = __webpack_require__(/*! ./listener/ListenerService */ \"../shared/node_modules/hazelcast-client/lib/listener/ListenerService.js\");\nconst LoggingService_1 = __webpack_require__(/*! ./logging/LoggingService */ \"../shared/node_modules/hazelcast-client/lib/logging/LoggingService.js\");\nconst RepairingTask_1 = __webpack_require__(/*! ./nearcache/RepairingTask */ \"../shared/node_modules/hazelcast-client/lib/nearcache/RepairingTask.js\");\nconst PartitionService_1 = __webpack_require__(/*! ./PartitionService */ \"../shared/node_modules/hazelcast-client/lib/PartitionService.js\");\nconst ErrorFactory_1 = __webpack_require__(/*! ./protocol/ErrorFactory */ \"../shared/node_modules/hazelcast-client/lib/protocol/ErrorFactory.js\");\nconst ProxyManager_1 = __webpack_require__(/*! ./proxy/ProxyManager */ \"../shared/node_modules/hazelcast-client/lib/proxy/ProxyManager.js\");\nconst CPProxyManager_1 = __webpack_require__(/*! ./proxy/cpsubsystem/CPProxyManager */ \"../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/CPProxyManager.js\");\nconst LockReferenceIdGenerator_1 = __webpack_require__(/*! ./proxy/LockReferenceIdGenerator */ \"../shared/node_modules/hazelcast-client/lib/proxy/LockReferenceIdGenerator.js\");\nconst SerializationService_1 = __webpack_require__(/*! ./serialization/SerializationService */ \"../shared/node_modules/hazelcast-client/lib/serialization/SerializationService.js\");\nconst HazelcastCloudAddressProvider_1 = __webpack_require__(/*! ./discovery/HazelcastCloudAddressProvider */ \"../shared/node_modules/hazelcast-client/lib/discovery/HazelcastCloudAddressProvider.js\");\nconst DefaultAddressProvider_1 = __webpack_require__(/*! ./connection/DefaultAddressProvider */ \"../shared/node_modules/hazelcast-client/lib/connection/DefaultAddressProvider.js\");\nconst HazelcastCloudDiscovery_1 = __webpack_require__(/*! ./discovery/HazelcastCloudDiscovery */ \"../shared/node_modules/hazelcast-client/lib/discovery/HazelcastCloudDiscovery.js\");\nconst Statistics_1 = __webpack_require__(/*! ./statistics/Statistics */ \"../shared/node_modules/hazelcast-client/lib/statistics/Statistics.js\");\nconst NearCacheManager_1 = __webpack_require__(/*! ./nearcache/NearCacheManager */ \"../shared/node_modules/hazelcast-client/lib/nearcache/NearCacheManager.js\");\nconst LoadBalancerConfig_1 = __webpack_require__(/*! ./config/LoadBalancerConfig */ \"../shared/node_modules/hazelcast-client/lib/config/LoadBalancerConfig.js\");\nconst RandomLB_1 = __webpack_require__(/*! ./util/RandomLB */ \"../shared/node_modules/hazelcast-client/lib/util/RandomLB.js\");\nconst RoundRobinLB_1 = __webpack_require__(/*! ./util/RoundRobinLB */ \"../shared/node_modules/hazelcast-client/lib/util/RoundRobinLB.js\");\nconst ClusterViewListenerService_1 = __webpack_require__(/*! ./listener/ClusterViewListenerService */ \"../shared/node_modules/hazelcast-client/lib/listener/ClusterViewListenerService.js\");\n/**\n * Hazelcast client instance. When you want to use Hazelcast's distributed\n * data structures, you must first create a client instance. Multiple\n * instances can be created on a single Node.js process.\n *\n * Client instances should be shut down explicitly.\n */\nclass HazelcastClient {\n    /** @internal */\n    constructor(config) {\n        /** @internal */\n        this.id = HazelcastClient.CLIENT_ID++;\n        this.config = config;\n        this.instanceName = config.instanceName || 'hz.client_' + this.id;\n        this.loggingService = new LoggingService_1.LoggingService(this.config.customLogger, this.config.properties['hazelcast.logging.level']);\n        this.loadBalancer = this.initLoadBalancer();\n        this.listenerService = new ListenerService_1.ListenerService(this);\n        this.serializationService = new SerializationService_1.SerializationServiceV1(this.config.serialization);\n        this.nearCacheManager = new NearCacheManager_1.NearCacheManager(this);\n        this.partitionService = new PartitionService_1.PartitionServiceImpl(this);\n        this.addressProvider = this.createAddressProvider();\n        this.connectionManager = new ClientConnectionManager_1.ClientConnectionManager(this);\n        this.invocationService = new InvocationService_1.InvocationService(this);\n        this.cpProxyManager = new CPProxyManager_1.CPProxyManager(this);\n        this.proxyManager = new ProxyManager_1.ProxyManager(this);\n        this.clusterService = new ClusterService_1.ClusterService(this);\n        this.lifecycleService = new LifecycleService_1.LifecycleServiceImpl(this);\n        this.lockReferenceIdGenerator = new LockReferenceIdGenerator_1.LockReferenceIdGenerator();\n        this.errorFactory = new ErrorFactory_1.ClientErrorFactory();\n        this.statistics = new Statistics_1.Statistics(this);\n        this.clusterViewListenerService = new ClusterViewListenerService_1.ClusterViewListenerService(this);\n    }\n    /**\n     * Creates a new client object and automatically connects to cluster.\n     * @param config Default {@link ClientConfig} is used when this parameter is absent.\n     * @returns a new client instance\n     */\n    static newHazelcastClient(config) {\n        const configBuilder = new ConfigBuilder_1.ConfigBuilder(config);\n        const effectiveConfig = configBuilder.build();\n        const client = new HazelcastClient(effectiveConfig);\n        return client.init();\n    }\n    /**\n     * Returns the name of this Hazelcast instance.\n     *\n     * @return name of this Hazelcast instance\n     */\n    getName() {\n        return this.instanceName;\n    }\n    /**\n     * Gathers information of this local client.\n     * @returns {ClientInfo}\n     */\n    getLocalEndpoint() {\n        return this.clusterService.getLocalClient();\n    }\n    /**\n     * Gives all known distributed objects in cluster.\n     * @returns {Promise<DistributedObject[]>|Promise<T>}\n     */\n    getDistributedObjects() {\n        const clientMessage = ClientGetDistributedObjectsCodec_1.ClientGetDistributedObjectsCodec.encodeRequest();\n        let localDistributedObjects;\n        let responseMessage;\n        return this.invocationService.invokeOnRandomTarget(clientMessage)\n            .then((resp) => {\n            responseMessage = resp;\n            return this.proxyManager.getDistributedObjects();\n        })\n            .then((distributedObjects) => {\n            localDistributedObjects = new Set();\n            distributedObjects.forEach((obj) => {\n                localDistributedObjects.add(obj.getServiceName() + ProxyManager_1.NAMESPACE_SEPARATOR + obj.getName());\n            });\n            const newDistributedObjectInfos = ClientGetDistributedObjectsCodec_1.ClientGetDistributedObjectsCodec.decodeResponse(responseMessage).response;\n            const createLocalProxiesPromise = newDistributedObjectInfos.map((doi) => {\n                return this.proxyManager.getOrCreateProxy(doi.name, doi.serviceName, false)\n                    .then(() => localDistributedObjects.delete(doi.serviceName + ProxyManager_1.NAMESPACE_SEPARATOR + doi.name));\n            });\n            return Promise.all(createLocalProxiesPromise);\n        })\n            .then(() => {\n            const destroyLocalProxiesPromises = new Array(localDistributedObjects.size);\n            let index = 0;\n            localDistributedObjects.forEach((namespace) => {\n                destroyLocalProxiesPromises[index++] = this.proxyManager.destroyProxyLocally(namespace);\n            });\n            return Promise.all(destroyLocalProxiesPromises);\n        })\n            .then(() => {\n            return this.proxyManager.getDistributedObjects();\n        });\n    }\n    /**\n     * Returns the distributed map instance with given name.\n     * @param name\n     * @returns {Promise<IMap<K, V>>}\n     */\n    getMap(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.MAP_SERVICE);\n    }\n    /**\n     * Returns the distributed set instance with given name.\n     * @param name\n     * @returns {Promise<ISet<E>>}\n     */\n    getSet(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.SET_SERVICE);\n    }\n    /**\n     * Returns the distributed queue instance with given name.\n     * @param name\n     * @returns {Promise<IQueue<E>>}\n     */\n    getQueue(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.QUEUE_SERVICE);\n    }\n    /**\n     * Returns the distributed list instance with given name.\n     * @param name\n     * @returns {Promise<IList<E>>}\n     */\n    getList(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.LIST_SERVICE);\n    }\n    /**\n     * Returns the distributed multi-map instance with given name.\n     * @param name\n     * @returns {Promise<MultiMap<K, V>>}\n     */\n    getMultiMap(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.MULTIMAP_SERVICE);\n    }\n    /**\n     * Returns a distributed ringbuffer instance with the given name.\n     * @param name\n     * @returns {Promise<Ringbuffer<E>>}\n     */\n    getRingbuffer(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.RINGBUFFER_SERVICE);\n    }\n    /**\n     * Returns a distributed reliable topic instance with the given name.\n     * @param name\n     * @returns {Promise<ITopic<E>>}\n     */\n    getReliableTopic(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.RELIABLETOPIC_SERVICE);\n    }\n    /**\n     * Returns the distributed replicated-map instance with given name.\n     * @param name\n     * @returns {Promise<ReplicatedMap<K, V>>}\n     */\n    getReplicatedMap(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.REPLICATEDMAP_SERVICE);\n    }\n    /**\n     * Returns the distributed flake ID generator instance with given name.\n     * @param name\n     * @returns {Promise<FlakeIdGenerator>}\n     */\n    getFlakeIdGenerator(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.FLAKEID_SERVICE);\n    }\n    /**\n     * Returns the distributed PN Counter instance with given name.\n     * @param name\n     * @returns {Promise<PNCounter>}\n     */\n    getPNCounter(name) {\n        return this.proxyManager.getOrCreateProxy(name, ProxyManager_1.ProxyManager.PNCOUNTER_SERVICE);\n    }\n    /**\n     * Returns the distributed AtomicLong instance with given name.\n     * The instance is created on CP Subsystem.\n     *\n     * If no group name is given within the `name` argument, then the\n     * AtomicLong instance will be created on the DEFAULT CP group.\n     * If a group name is given, like `.getAtomicLong('myLong@group1')`,\n     * the given group will be initialized first, if not initialized\n     * already, and then the instance will be created on this group.\n     * @param name\n     * @returns {Promise<PNCounter>}\n     */\n    getAtomicLong(name) {\n        return this.cpProxyManager.getOrCreateProxy(name, CPProxyManager_1.CPProxyManager.ATOMIC_LONG_SERVICE);\n    }\n    /**\n     * Returns configuration that this instance started with.\n     * Returned configuration object should not be modified.\n     * @returns {ClientConfig} configuration object\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Returns the Cluster to which this client is connected.\n     */\n    getCluster() {\n        return this.clusterService;\n    }\n    /**\n     * Returns the lifecycle service for this client.\n     */\n    getLifecycleService() {\n        return this.lifecycleService;\n    }\n    /**\n     * Returns the partition service of this client.\n     */\n    getPartitionService() {\n        return this.partitionService;\n    }\n    /** @internal */\n    getSerializationService() {\n        return this.serializationService;\n    }\n    /** @internal */\n    getInvocationService() {\n        return this.invocationService;\n    }\n    /** @internal */\n    getListenerService() {\n        return this.listenerService;\n    }\n    /** @internal */\n    getConnectionManager() {\n        return this.connectionManager;\n    }\n    /** @internal */\n    getProxyManager() {\n        return this.proxyManager;\n    }\n    /** @internal */\n    getNearCacheManager() {\n        return this.nearCacheManager;\n    }\n    /** @internal */\n    getClusterService() {\n        return this.clusterService;\n    }\n    /** @internal */\n    getRepairingTask() {\n        if (this.mapRepairingTask == null) {\n            this.mapRepairingTask = new RepairingTask_1.RepairingTask(this);\n        }\n        return this.mapRepairingTask;\n    }\n    /** @internal */\n    getLoggingService() {\n        return this.loggingService;\n    }\n    /**\n     * Registers a distributed object listener to cluster.\n     * @param listener distributed object listener function.\n     * @returns registration id of the listener.\n     */\n    addDistributedObjectListener(listener) {\n        return this.proxyManager.addDistributedObjectListener(listener);\n    }\n    /**\n     * Removes a distributed object listener from cluster.\n     * @param listenerId id of the listener to be removed.\n     * @returns `true` if registration was removed, `false` otherwise.\n     */\n    removeDistributedObjectListener(listenerId) {\n        return this.proxyManager.removeDistributedObjectListener(listenerId);\n    }\n    /** @internal */\n    getLockReferenceIdGenerator() {\n        return this.lockReferenceIdGenerator;\n    }\n    /** @internal */\n    getErrorFactory() {\n        return this.errorFactory;\n    }\n    /** @internal */\n    getAddressProvider() {\n        return this.addressProvider;\n    }\n    /** @internal */\n    getLoadBalancer() {\n        return this.loadBalancer;\n    }\n    /** @internal */\n    doShutdown() {\n        if (this.mapRepairingTask !== undefined) {\n            this.mapRepairingTask.shutdown();\n        }\n        this.nearCacheManager.destroyAllNearCaches();\n        this.proxyManager.destroy();\n        this.connectionManager.shutdown();\n        this.invocationService.shutdown();\n        this.statistics.stop();\n    }\n    /**\n     * Shuts down this client instance.\n     */\n    shutdown() {\n        this.getLifecycleService().shutdown();\n    }\n    /** @internal */\n    onClusterRestart() {\n        this.getLoggingService().getLogger()\n            .info('HazelcastClient', 'Clearing local state of the client, because of a cluster restart');\n        this.nearCacheManager.clearAllNearCaches();\n        this.clusterService.clearMemberListVersion();\n    }\n    /** @internal */\n    sendStateToCluster() {\n        return this.proxyManager.createDistributedObjectsOnCluster();\n    }\n    /** @internal */\n    init() {\n        try {\n            this.lifecycleService.start();\n            const configuredMembershipListeners = this.config.membershipListeners;\n            this.clusterService.start(configuredMembershipListeners);\n            this.clusterViewListenerService.start();\n        }\n        catch (e) {\n            this.loggingService.getLogger().error('HazelcastClient', 'Client failed to start', e);\n            throw e;\n        }\n        return this.connectionManager.start()\n            .then(() => {\n            const connectionStrategyConfig = this.config.connectionStrategy;\n            if (!connectionStrategyConfig.asyncStart) {\n                return this.clusterService.waitInitialMemberListFetched()\n                    .then(() => this.connectionManager.connectToAllClusterMembers());\n            }\n        })\n            .then(() => {\n            this.listenerService.start();\n            this.proxyManager.init();\n            this.invocationService.start();\n            this.loadBalancer.initLoadBalancer(this.clusterService, this.config);\n            this.statistics.start();\n            return this.sendStateToCluster();\n        })\n            .then(() => {\n            return this;\n        })\n            .catch((e) => {\n            this.loggingService.getLogger().error('HazelcastClient', 'Client failed to start', e);\n            throw e;\n        });\n    }\n    /** @internal */\n    initLoadBalancer() {\n        let lb = this.config.loadBalancer.customLoadBalancer;\n        if (lb == null) {\n            if (this.config.loadBalancer.type === LoadBalancerConfig_1.LoadBalancerType.ROUND_ROBIN) {\n                lb = new RoundRobinLB_1.RoundRobinLB();\n            }\n            else if (this.config.loadBalancer.type === LoadBalancerConfig_1.LoadBalancerType.RANDOM) {\n                lb = new RandomLB_1.RandomLB();\n            }\n            else {\n                throw new core_1.IllegalStateError('Load balancer type ' + this.config.loadBalancer.type\n                    + ' is not supported.');\n            }\n        }\n        return lb;\n    }\n    /** @internal */\n    createAddressProvider() {\n        const networkConfig = this.config.network;\n        const addressListProvided = networkConfig.clusterMembers.length !== 0;\n        const hazelcastCloudToken = networkConfig.hazelcastCloud.discoveryToken;\n        if (addressListProvided && hazelcastCloudToken != null) {\n            throw new core_1.IllegalStateError('Only one discovery method can be enabled at a time. '\n                + 'Cluster members given explicitly: ' + addressListProvided\n                + ', hazelcastCloud enabled');\n        }\n        const cloudAddressProvider = this.initCloudAddressProvider();\n        if (cloudAddressProvider != null) {\n            return cloudAddressProvider;\n        }\n        return new DefaultAddressProvider_1.DefaultAddressProvider(networkConfig);\n    }\n    /** @internal */\n    initCloudAddressProvider() {\n        const cloudConfig = this.getConfig().network.hazelcastCloud;\n        const discoveryToken = cloudConfig.discoveryToken;\n        if (discoveryToken != null) {\n            const urlEndpoint = HazelcastCloudDiscovery_1.HazelcastCloudDiscovery.createUrlEndpoint(this.getConfig().properties, discoveryToken);\n            return new HazelcastCloudAddressProvider_1.HazelcastCloudAddressProvider(urlEndpoint, this.getConnectionTimeoutMillis(), this.loggingService.getLogger());\n        }\n        return null;\n    }\n    /** @internal */\n    getConnectionTimeoutMillis() {\n        const networkConfig = this.getConfig().network;\n        const connTimeout = networkConfig.connectionTimeout;\n        return connTimeout === 0 ? Number.MAX_VALUE : connTimeout;\n    }\n}\nexports.HazelcastClient = HazelcastClient;\n/** @internal */\nHazelcastClient.CLIENT_ID = 0;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/HazelcastClient.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/LifecycleService.js":
/*!***********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/LifecycleService.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LifecycleServiceImpl = exports.LifecycleState = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\n/**\n * Lifecycle states.\n */\nvar LifecycleState;\n(function (LifecycleState) {\n    /**\n     * Fired when the client is starting.\n     */\n    LifecycleState[\"STARTING\"] = \"STARTING\";\n    /**\n     * Fired when the client's start is completed.\n     */\n    LifecycleState[\"STARTED\"] = \"STARTED\";\n    /**\n     * Fired when the client is shutting down.\n     */\n    LifecycleState[\"SHUTTING_DOWN\"] = \"SHUTTING_DOWN\";\n    /**\n     * Fired when the client's shut down is completed.\n     */\n    LifecycleState[\"SHUTDOWN\"] = \"SHUTDOWN\";\n    /**\n     * Fired when the client is connected to the member.\n     */\n    LifecycleState[\"CONNECTED\"] = \"CONNECTED\";\n    /**\n     * Fired when the client is disconnected from the member.\n     */\n    LifecycleState[\"DISCONNECTED\"] = \"DISCONNECTED\";\n    /**\n     * Fired when the client is connected to a new cluster.\n     */\n    LifecycleState[\"CHANGED_CLUSTER\"] = \"CHANGED_CLUSTER\";\n})(LifecycleState = exports.LifecycleState || (exports.LifecycleState = {}));\nconst LIFECYCLE_EVENT_NAME = 'lifecycleEvent';\n/** @internal */\nclass LifecycleServiceImpl extends events_1.EventEmitter {\n    constructor(client) {\n        super();\n        this.setMaxListeners(0);\n        this.client = client;\n        this.logger = this.client.getLoggingService().getLogger();\n        const listeners = client.getConfig().lifecycleListeners;\n        listeners.forEach((listener) => {\n            this.on(LIFECYCLE_EVENT_NAME, listener);\n        });\n    }\n    /**\n     * Causes LifecycleService to emit given event to all registered listeners.\n     * @param state\n     */\n    emitLifecycleEvent(state) {\n        this.logger.info('LifecycleService', 'HazelcastClient is ' + state);\n        this.emit(LIFECYCLE_EVENT_NAME, state);\n    }\n    /**\n     * Returns the active state of the client.\n     * @returns {boolean}\n     */\n    isRunning() {\n        return this.active;\n    }\n    start() {\n        this.emitLifecycleEvent(LifecycleState.STARTING);\n        this.active = true;\n        this.emitLifecycleEvent(LifecycleState.STARTED);\n    }\n    shutdown() {\n        if (!this.active) {\n            return;\n        }\n        this.active = false;\n        this.emitLifecycleEvent(LifecycleState.SHUTTING_DOWN);\n        this.client.doShutdown();\n        this.emitLifecycleEvent(LifecycleState.SHUTDOWN);\n    }\n}\nexports.LifecycleServiceImpl = LifecycleServiceImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/LifecycleService.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/PartitionService.js":
/*!***********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/PartitionService.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PartitionServiceImpl = void 0;\nconst core_1 = __webpack_require__(/*! ./core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nclass PartitionTable {\n    constructor() {\n        this.partitionStateVersion = -1;\n        this.partitions = new Map();\n    }\n}\n/** @internal */\nclass PartitionServiceImpl {\n    constructor(client) {\n        this.partitionTable = new PartitionTable();\n        this.partitionCount = 0;\n        this.client = client;\n        this.logger = client.getLoggingService().getLogger();\n    }\n    /**\n     * The partitions can be empty on the response, client will not apply the empty partition table.\n     */\n    handlePartitionViewEvent(connection, partitions, partitionStateVersion) {\n        this.logger.debug('PartitionService', 'Handling new partition table with partitionStateVersion: ' + partitionStateVersion);\n        if (!this.shouldBeApplied(connection, partitions, partitionStateVersion, this.partitionTable)) {\n            return;\n        }\n        const newPartitions = this.convertToMap(partitions);\n        this.partitionTable.connection = connection;\n        this.partitionTable.partitionStateVersion = partitionStateVersion;\n        this.partitionTable.partitions = newPartitions;\n    }\n    getPartitionOwner(partitionId) {\n        return this.getPartitions().get(partitionId);\n    }\n    getPartitionId(key) {\n        if (this.partitionCount === 0) {\n            // Partition count can not be zero for the sync mode.\n            // On the sync mode, we are waiting for the first connection to be established.\n            // We are initializing the partition count with the value coming from the server with authentication.\n            // This exception is used only for async mode client.\n            throw new core_1.ClientOfflineError();\n        }\n        let partitionHash;\n        if (typeof key === 'object' && 'getPartitionHash' in key) {\n            partitionHash = key.getPartitionHash();\n        }\n        else {\n            partitionHash = this.client.getSerializationService().toData(key).getPartitionHash();\n        }\n        return Math.abs(partitionHash) % this.partitionCount;\n    }\n    getPartitionCount() {\n        return this.partitionCount;\n    }\n    /**\n     * @param newPartitionCount\n     * @return true if partition count can be set for the first time, or it is equal to\n     * one that is already available, returns false otherwise\n     */\n    checkAndSetPartitionCount(newPartitionCount) {\n        if (this.partitionCount === 0) {\n            this.partitionCount = newPartitionCount;\n            return true;\n        }\n        return this.partitionCount === newPartitionCount;\n    }\n    convertToMap(partitions) {\n        const newPartitions = new Map();\n        for (const entry of partitions) {\n            const uuid = entry[0];\n            const ownedPartitions = entry[1];\n            for (const ownedPartition of ownedPartitions) {\n                newPartitions.set(ownedPartition, uuid);\n            }\n        }\n        return newPartitions;\n    }\n    logFailure(connection, partitionStateVersion, current, cause) {\n        this.logger.debug('PartitionService', 'Response will not be applied since ' + cause\n            + '. Response is from ' + connection\n            + '. Current connection ' + current.connection\n            + '. Response state version ' + partitionStateVersion\n            + '. Current state version ' + current.partitionStateVersion);\n    }\n    getPartitions() {\n        return this.partitionTable.partitions;\n    }\n    shouldBeApplied(connection, partitions, partitionStateVersion, current) {\n        if (partitions.length === 0) {\n            this.logFailure(connection, partitionStateVersion, current, 'response is empty');\n            return false;\n        }\n        if (!connection.equals(current.connection)) {\n            this.logger.trace('PartitionService', 'Event coming from a new connection. Old connection: ' + current.connection\n                + ', new connection ' + connection);\n            return true;\n        }\n        if (partitionStateVersion <= current.partitionStateVersion) {\n            this.logFailure(connection, partitionStateVersion, current, 'response state version is old');\n            return false;\n        }\n        return true;\n    }\n}\nexports.PartitionServiceImpl = PartitionServiceImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/PartitionService.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/aggregation/Aggregator.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/aggregation/Aggregator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LongSumAggregator = exports.LongAverageAggregator = exports.IntegerSumAggregator = exports.IntegerAverageAggregator = exports.MinAggregator = exports.MaxAggregator = exports.FloatingPointSumAggregator = exports.FixedPointSumAggregator = exports.NumberAverageAggregator = exports.DoubleSumAggregator = exports.DoubleAverageAggregator = exports.CountAggregator = exports.AbstractAggregator = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst AggregatorFactory = __webpack_require__(/*! ./AggregatorFactory */ \"../shared/node_modules/hazelcast-client/lib/aggregation/AggregatorFactory.js\");\n/** @internal */\nclass AbstractAggregator {\n    constructor(attributePath) {\n        this.factoryId = AggregatorFactory.AGGREGATOR_FACTORY_ID;\n        this.attributePath = attributePath;\n    }\n}\nexports.AbstractAggregator = AbstractAggregator;\n/** @internal */\nclass CountAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.COUNT;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        // member side field, not used in client\n        input.readLong();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        // member side field, not used in client\n        output.writeLong(Long.ZERO);\n    }\n}\nexports.CountAggregator = CountAggregator;\n/** @internal */\nclass DoubleAverageAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.DOUBLE_AVG;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readDouble();\n        input.readLong();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeDouble(0);\n        output.writeLong(Long.ZERO);\n    }\n}\nexports.DoubleAverageAggregator = DoubleAverageAggregator;\n/** @internal */\nclass DoubleSumAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.DOUBLE_SUM;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readDouble();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeDouble(0);\n    }\n}\nexports.DoubleSumAggregator = DoubleSumAggregator;\n/** @internal */\nclass NumberAverageAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.NUMBER_AVG;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readDouble();\n        input.readLong();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeDouble(0);\n        output.writeLong(Long.ZERO);\n    }\n}\nexports.NumberAverageAggregator = NumberAverageAggregator;\n/** @internal */\nclass FixedPointSumAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.FIXED_SUM;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readLong();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeLong(Long.ZERO);\n    }\n}\nexports.FixedPointSumAggregator = FixedPointSumAggregator;\n/** @internal */\nclass FloatingPointSumAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.FLOATING_POINT_SUM;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readDouble();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeDouble(0);\n    }\n}\nexports.FloatingPointSumAggregator = FloatingPointSumAggregator;\n/** @internal */\nclass MaxAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.MAX;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readObject();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeObject(null);\n    }\n}\nexports.MaxAggregator = MaxAggregator;\n/** @internal */\nclass MinAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.MIN;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readObject();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeObject(null);\n    }\n}\nexports.MinAggregator = MinAggregator;\n/** @internal */\nclass IntegerAverageAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.INT_AVG;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readLong();\n        input.readLong();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeLong(Long.ZERO);\n        output.writeLong(Long.ZERO);\n    }\n}\nexports.IntegerAverageAggregator = IntegerAverageAggregator;\n/** @internal */\nclass IntegerSumAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.INT_SUM;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readLong();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeLong(Long.ZERO);\n    }\n}\nexports.IntegerSumAggregator = IntegerSumAggregator;\n/** @internal */\nclass LongAverageAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.LONG_AVG;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readLong();\n        input.readLong();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeLong(Long.ZERO);\n        output.writeLong(Long.ZERO);\n    }\n}\nexports.LongAverageAggregator = LongAverageAggregator;\n/** @internal */\nclass LongSumAggregator extends AbstractAggregator {\n    constructor() {\n        super(...arguments);\n        this.classId = AggregatorFactory.LONG_SUM;\n    }\n    readData(input) {\n        this.attributePath = input.readUTF();\n        input.readLong();\n    }\n    writeData(output) {\n        output.writeUTF(this.attributePath);\n        output.writeLong(Long.ZERO);\n    }\n}\nexports.LongSumAggregator = LongSumAggregator;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/aggregation/Aggregator.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/aggregation/AggregatorFactory.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/aggregation/AggregatorFactory.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.aggregatorFactory = exports.NUMBER_AVG = exports.MIN = exports.MAX = exports.LONG_SUM = exports.LONG_AVG = exports.INT_SUM = exports.INT_AVG = exports.FLOATING_POINT_SUM = exports.FIXED_SUM = exports.DOUBLE_SUM = exports.DOUBLE_AVG = exports.COUNT = exports.AGGREGATOR_FACTORY_ID = void 0;\nconst Aggregator_1 = __webpack_require__(/*! ./Aggregator */ \"../shared/node_modules/hazelcast-client/lib/aggregation/Aggregator.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\n/** @internal */\nexports.AGGREGATOR_FACTORY_ID = -29;\n// export const BIG_DECIMAL_AVG = 0; // not implemented in node.js\n// export const BIG_DECIMAL_SUM = 1; // not implemented in node.js\n// export const BIG_INT_AVG = 2; // not implemented in node.js\n// export const BIG_INT_SUM = 3; // not implemented in node.js\n/** @internal */\nexports.COUNT = 4;\n// export const DISTINCT = 5; // returns java serializable, not usable in node.js\n/** @internal */\nexports.DOUBLE_AVG = 6;\n/** @internal */\nexports.DOUBLE_SUM = 7;\n/** @internal */\nexports.FIXED_SUM = 8;\n/** @internal */\nexports.FLOATING_POINT_SUM = 9;\n/** @internal */\nexports.INT_AVG = 10;\n/** @internal */\nexports.INT_SUM = 11;\n/** @internal */\nexports.LONG_AVG = 12;\n/** @internal */\nexports.LONG_SUM = 13;\n/** @internal */\nexports.MAX = 14;\n/** @internal */\nexports.MIN = 15;\n/** @internal */\nexports.NUMBER_AVG = 16;\n// export const MAX_BY = 17; // needs object to implement Java's Comparable interface\n// export const MIN_BY = 18; // needs object to implement Java's Comparable interface\nconst idToConstructor = {\n    [exports.COUNT]: Aggregator_1.CountAggregator,\n    [exports.DOUBLE_AVG]: Aggregator_1.DoubleAverageAggregator,\n    [exports.DOUBLE_SUM]: Aggregator_1.DoubleSumAggregator,\n    [exports.FIXED_SUM]: Aggregator_1.FixedPointSumAggregator,\n    [exports.FLOATING_POINT_SUM]: Aggregator_1.FloatingPointSumAggregator,\n    [exports.INT_AVG]: Aggregator_1.IntegerAverageAggregator,\n    [exports.INT_SUM]: Aggregator_1.IntegerSumAggregator,\n    [exports.LONG_AVG]: Aggregator_1.LongAverageAggregator,\n    [exports.LONG_SUM]: Aggregator_1.LongSumAggregator,\n    [exports.MAX]: Aggregator_1.MaxAggregator,\n    [exports.MIN]: Aggregator_1.MinAggregator,\n    [exports.NUMBER_AVG]: Aggregator_1.NumberAverageAggregator,\n};\n/** @internal */\nfunction aggregatorFactory(classId) {\n    try {\n        return new idToConstructor[classId]();\n    }\n    catch (e) {\n        throw new core_1.HazelcastError('There is no known aggregator with type id ' + classId, e);\n    }\n}\nexports.aggregatorFactory = aggregatorFactory;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/aggregation/AggregatorFactory.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/aggregation/Aggregators.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/aggregation/Aggregators.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.longSum = exports.longAvg = exports.integerSum = exports.integerAvg = exports.min = exports.max = exports.floatingPointSum = exports.fixedPointSum = exports.numberAvg = exports.doubleSum = exports.doubleAvg = exports.count = void 0;\nconst Aggregator_1 = __webpack_require__(/*! ./Aggregator */ \"../shared/node_modules/hazelcast-client/lib/aggregation/Aggregator.js\");\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that counts the input values.\n * Accepts nulls as input values.\n * Aggregation result type `Long`.\n */\nfunction count(attributePath) {\n    return new Aggregator_1.CountAggregator(attributePath);\n}\nexports.count = count;\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that calculates the average of the input values.\n * Does NOT accept `null` input values.\n * Accepts only Double input values (primitive and boxed).\n * Aggregation result type is `number`.\n */\nfunction doubleAvg(attributePath) {\n    return new Aggregator_1.DoubleAverageAggregator(attributePath);\n}\nexports.doubleAvg = doubleAvg;\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that calculates the sum of the input values.\n * Does NOT accept `null` input values.\n * Accepts only Double input values (primitive and boxed).\n * Aggregation result type is `number`.\n */\nfunction doubleSum(attributePath) {\n    return new Aggregator_1.DoubleSumAggregator(attributePath);\n}\nexports.doubleSum = doubleSum;\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that calculates the average of the input values.\n * Does NOT accept `null` input values.\n * Accepts generic Number input values.\n * Aggregation result type is `number`.\n */\nfunction numberAvg(attributePath) {\n    return new Aggregator_1.NumberAverageAggregator(attributePath);\n}\nexports.numberAvg = numberAvg;\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that calculates the sum of the input values.\n * Does NOT accept `null` input values.\n * Accepts generic Number input values.\n * Aggregation result type is `Long`.\n */\nfunction fixedPointSum(attributePath) {\n    return new Aggregator_1.FixedPointSumAggregator(attributePath);\n}\nexports.fixedPointSum = fixedPointSum;\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that calculates the sum of the input values.\n * Does NOT accept `null` input values.\n * Accepts generic Number input values.\n * Aggregation result type is `number`.\n */\nfunction floatingPointSum(attributePath) {\n    return new Aggregator_1.FloatingPointSumAggregator(attributePath);\n}\nexports.floatingPointSum = floatingPointSum;\n/**\n * @param attributePath extracts values from this path if given\n * @param <R> type of the input object.\n * @return an aggregator that calculates the max of the input values.\n * Accepts `null` input values.\n * Aggregation result type is `R`.\n */\nfunction max(attributePath) {\n    return new Aggregator_1.MaxAggregator(attributePath);\n}\nexports.max = max;\n/**\n * @param attributePath extracts values from this path if given\n * @param <R> type of the input object.\n * @return an aggregator that calculates the min of the input values.\n * Accepts `null` input values.\n * Aggregation result type is `R`.\n */\nfunction min(attributePath) {\n    return new Aggregator_1.MinAggregator(attributePath);\n}\nexports.min = min;\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that calculates the average of the input values.\n * Does NOT accept `null` input values.\n * Accepts only Integer input values (primitive and boxed).\n * Aggregation result type is `number`.\n */\nfunction integerAvg(attributePath) {\n    return new Aggregator_1.IntegerAverageAggregator(attributePath);\n}\nexports.integerAvg = integerAvg;\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that calculates the sum of the input values.\n * Does NOT accept `null` input values.\n * Accepts only Integer input values (primitive and boxed).\n * Aggregation result type is `Long`.\n */\nfunction integerSum(attributePath) {\n    return new Aggregator_1.IntegerSumAggregator(attributePath);\n}\nexports.integerSum = integerSum;\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that calculates the average of the input values.\n * Does NOT accept `null` input values.\n * Accepts only Long input values (primitive and boxed).\n * Aggregation result type is `number`.\n */\nfunction longAvg(attributePath) {\n    return new Aggregator_1.LongAverageAggregator(attributePath);\n}\nexports.longAvg = longAvg;\n/**\n * @param attributePath extracts values from this path if given\n * @return an aggregator that calculates the sum of the input values.\n * Does NOT accept `null` input values.\n * Accepts only Long input values (primitive and boxed).\n * Aggregation result type is `Long`.\n */\nfunction longSum(attributePath) {\n    return new Aggregator_1.LongSumAggregator(attributePath);\n}\nexports.longSum = longSum;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/aggregation/Aggregators.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/aggregation/index.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/aggregation/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Public API re-exports.\n */\n__exportStar(__webpack_require__(/*! ./Aggregator */ \"../shared/node_modules/hazelcast-client/lib/aggregation/Aggregator.js\"), exports);\nexports.Aggregators = __webpack_require__(/*! ./Aggregators */ \"../shared/node_modules/hazelcast-client/lib/aggregation/Aggregators.js\");\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/aggregation/index.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/AtomicLongAddAndGetCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/AtomicLongAddAndGetCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AtomicLongAddAndGetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst RaftGroupIdCodec_1 = __webpack_require__(/*! ./custom/RaftGroupIdCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x090300\nconst REQUEST_MESSAGE_TYPE = 590592;\n// hex: 0x090301\n// RESPONSE_MESSAGE_TYPE = 590593\nconst REQUEST_DELTA_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_DELTA_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass AtomicLongAddAndGetCodec {\n    static encodeRequest(groupId, name, delta) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_DELTA_OFFSET, delta);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        RaftGroupIdCodec_1.RaftGroupIdCodec.encode(clientMessage, groupId);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.AtomicLongAddAndGetCodec = AtomicLongAddAndGetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/AtomicLongAddAndGetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/AtomicLongCompareAndSetCodec.js":
/*!*****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/AtomicLongCompareAndSetCodec.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AtomicLongCompareAndSetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst RaftGroupIdCodec_1 = __webpack_require__(/*! ./custom/RaftGroupIdCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x090400\nconst REQUEST_MESSAGE_TYPE = 590848;\n// hex: 0x090401\n// RESPONSE_MESSAGE_TYPE = 590849\nconst REQUEST_EXPECTED_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_UPDATED_OFFSET = REQUEST_EXPECTED_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_UPDATED_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass AtomicLongCompareAndSetCodec {\n    static encodeRequest(groupId, name, expected, updated) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_EXPECTED_OFFSET, expected);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_UPDATED_OFFSET, updated);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        RaftGroupIdCodec_1.RaftGroupIdCodec.encode(clientMessage, groupId);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.AtomicLongCompareAndSetCodec = AtomicLongCompareAndSetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/AtomicLongCompareAndSetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetAndAddCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetAndAddCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AtomicLongGetAndAddCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst RaftGroupIdCodec_1 = __webpack_require__(/*! ./custom/RaftGroupIdCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x090600\nconst REQUEST_MESSAGE_TYPE = 591360;\n// hex: 0x090601\n// RESPONSE_MESSAGE_TYPE = 591361\nconst REQUEST_DELTA_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_DELTA_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass AtomicLongGetAndAddCodec {\n    static encodeRequest(groupId, name, delta) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_DELTA_OFFSET, delta);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        RaftGroupIdCodec_1.RaftGroupIdCodec.encode(clientMessage, groupId);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.AtomicLongGetAndAddCodec = AtomicLongGetAndAddCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetAndAddCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetAndSetCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetAndSetCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AtomicLongGetAndSetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst RaftGroupIdCodec_1 = __webpack_require__(/*! ./custom/RaftGroupIdCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x090700\nconst REQUEST_MESSAGE_TYPE = 591616;\n// hex: 0x090701\n// RESPONSE_MESSAGE_TYPE = 591617\nconst REQUEST_NEW_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_NEW_VALUE_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass AtomicLongGetAndSetCodec {\n    static encodeRequest(groupId, name, newValue) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_NEW_VALUE_OFFSET, newValue);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        RaftGroupIdCodec_1.RaftGroupIdCodec.encode(clientMessage, groupId);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.AtomicLongGetAndSetCodec = AtomicLongGetAndSetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetAndSetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetCodec.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetCodec.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AtomicLongGetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst RaftGroupIdCodec_1 = __webpack_require__(/*! ./custom/RaftGroupIdCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x090500\nconst REQUEST_MESSAGE_TYPE = 591104;\n// hex: 0x090501\n// RESPONSE_MESSAGE_TYPE = 591105\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass AtomicLongGetCodec {\n    static encodeRequest(groupId, name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        RaftGroupIdCodec_1.RaftGroupIdCodec.encode(clientMessage, groupId);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.AtomicLongGetCodec = AtomicLongGetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/CPGroupCreateCPGroupCodec.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/CPGroupCreateCPGroupCodec.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CPGroupCreateCPGroupCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst RaftGroupIdCodec_1 = __webpack_require__(/*! ./custom/RaftGroupIdCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js\");\n// hex: 0x1E0100\nconst REQUEST_MESSAGE_TYPE = 1966336;\n// hex: 0x1E0101\n// RESPONSE_MESSAGE_TYPE = 1966337\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass CPGroupCreateCPGroupCodec {\n    static encodeRequest(proxyName) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, proxyName);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.groupId = RaftGroupIdCodec_1.RaftGroupIdCodec.decode(clientMessage);\n        return response;\n    }\n}\nexports.CPGroupCreateCPGroupCodec = CPGroupCreateCPGroupCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/CPGroupCreateCPGroupCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/CPGroupDestroyCPObjectCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/CPGroupDestroyCPObjectCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CPGroupDestroyCPObjectCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst RaftGroupIdCodec_1 = __webpack_require__(/*! ./custom/RaftGroupIdCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x1E0200\nconst REQUEST_MESSAGE_TYPE = 1966592;\n// hex: 0x1E0201\n// RESPONSE_MESSAGE_TYPE = 1966593\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass CPGroupDestroyCPObjectCodec {\n    static encodeRequest(groupId, serviceName, objectName) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        RaftGroupIdCodec_1.RaftGroupIdCodec.encode(clientMessage, groupId);\n        StringCodec_1.StringCodec.encode(clientMessage, serviceName);\n        StringCodec_1.StringCodec.encode(clientMessage, objectName);\n        return clientMessage;\n    }\n}\nexports.CPGroupDestroyCPObjectCodec = CPGroupDestroyCPObjectCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/CPGroupDestroyCPObjectCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientAddClusterViewListenerCodec.js":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientAddClusterViewListenerCodec.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientAddClusterViewListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst MemberInfoCodec_1 = __webpack_require__(/*! ./custom/MemberInfoCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/MemberInfoCodec.js\");\nconst EntryListUUIDListIntegerCodec_1 = __webpack_require__(/*! ./builtin/EntryListUUIDListIntegerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListUUIDListIntegerCodec.js\");\n// hex: 0x000300\nconst REQUEST_MESSAGE_TYPE = 768;\n// hex: 0x000301\n// RESPONSE_MESSAGE_TYPE = 769\n// hex: 0x000302\nconst EVENT_MEMBERS_VIEW_MESSAGE_TYPE = 770;\n// hex: 0x000303\nconst EVENT_PARTITIONS_VIEW_MESSAGE_TYPE = 771;\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_MEMBERS_VIEW_VERSION_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_PARTITIONS_VIEW_VERSION_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ClientAddClusterViewListenerCodec {\n    static encodeRequest() {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        return clientMessage;\n    }\n    static handle(clientMessage, handleMembersViewEvent = null, handlePartitionsViewEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_MEMBERS_VIEW_MESSAGE_TYPE && handleMembersViewEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const version = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_MEMBERS_VIEW_VERSION_OFFSET);\n            const memberInfos = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, MemberInfoCodec_1.MemberInfoCodec.decode);\n            handleMembersViewEvent(version, memberInfos);\n            return;\n        }\n        if (messageType === EVENT_PARTITIONS_VIEW_MESSAGE_TYPE && handlePartitionsViewEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const version = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_PARTITIONS_VIEW_VERSION_OFFSET);\n            const partitions = EntryListUUIDListIntegerCodec_1.EntryListUUIDListIntegerCodec.decode(clientMessage);\n            handlePartitionsViewEvent(version, partitions);\n            return;\n        }\n    }\n}\nexports.ClientAddClusterViewListenerCodec = ClientAddClusterViewListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientAddClusterViewListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientAddDistributedObjectListenerCodec.js":
/*!****************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientAddDistributedObjectListenerCodec.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientAddDistributedObjectListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x000900\nconst REQUEST_MESSAGE_TYPE = 2304;\n// hex: 0x000901\n// RESPONSE_MESSAGE_TYPE = 2305\n// hex: 0x000902\nconst EVENT_DISTRIBUTED_OBJECT_MESSAGE_TYPE = 2306;\nconst REQUEST_LOCAL_ONLY_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_DISTRIBUTED_OBJECT_SOURCE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ClientAddDistributedObjectListenerCodec {\n    static encodeRequest(localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleDistributedObjectEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_DISTRIBUTED_OBJECT_MESSAGE_TYPE && handleDistributedObjectEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const source = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_DISTRIBUTED_OBJECT_SOURCE_OFFSET);\n            const name = StringCodec_1.StringCodec.decode(clientMessage);\n            const serviceName = StringCodec_1.StringCodec.decode(clientMessage);\n            const eventType = StringCodec_1.StringCodec.decode(clientMessage);\n            handleDistributedObjectEvent(name, serviceName, eventType, source);\n            return;\n        }\n    }\n}\nexports.ClientAddDistributedObjectListenerCodec = ClientAddDistributedObjectListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientAddDistributedObjectListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientAuthenticationCodec.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientAuthenticationCodec.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientAuthenticationCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst AddressCodec_1 = __webpack_require__(/*! ./custom/AddressCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/AddressCodec.js\");\n// hex: 0x000100\nconst REQUEST_MESSAGE_TYPE = 256;\n// hex: 0x000101\n// RESPONSE_MESSAGE_TYPE = 257\nconst REQUEST_UUID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_SERIALIZATION_VERSION_OFFSET = REQUEST_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_SERIALIZATION_VERSION_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_STATUS_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_MEMBER_UUID_OFFSET = RESPONSE_STATUS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_SERIALIZATION_VERSION_OFFSET = RESPONSE_MEMBER_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_PARTITION_COUNT_OFFSET = RESPONSE_SERIALIZATION_VERSION_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_CLUSTER_ID_OFFSET = RESPONSE_PARTITION_COUNT_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_FAILOVER_SUPPORTED_OFFSET = RESPONSE_CLUSTER_ID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass ClientAuthenticationCodec {\n    static encodeRequest(clusterName, username, password, uuid, clientType, serializationVersion, clientHazelcastVersion, clientName, labels) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_UUID_OFFSET, uuid);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeByte(initialFrame.content, REQUEST_SERIALIZATION_VERSION_OFFSET, serializationVersion);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, clusterName);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, username, StringCodec_1.StringCodec.encode);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, password, StringCodec_1.StringCodec.encode);\n        StringCodec_1.StringCodec.encode(clientMessage, clientType);\n        StringCodec_1.StringCodec.encode(clientMessage, clientHazelcastVersion);\n        StringCodec_1.StringCodec.encode(clientMessage, clientName);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, labels, StringCodec_1.StringCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.status = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeByte(initialFrame.content, RESPONSE_STATUS_OFFSET);\n        response.memberUuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_MEMBER_UUID_OFFSET);\n        response.serializationVersion = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeByte(initialFrame.content, RESPONSE_SERIALIZATION_VERSION_OFFSET);\n        response.partitionCount = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_PARTITION_COUNT_OFFSET);\n        response.clusterId = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_CLUSTER_ID_OFFSET);\n        response.failoverSupported = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_FAILOVER_SUPPORTED_OFFSET);\n        response.address = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, AddressCodec_1.AddressCodec.decode);\n        response.serverHazelcastVersion = StringCodec_1.StringCodec.decode(clientMessage);\n        return response;\n    }\n}\nexports.ClientAuthenticationCodec = ClientAuthenticationCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientAuthenticationCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientAuthenticationCustomCodec.js":
/*!********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientAuthenticationCustomCodec.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientAuthenticationCustomCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ByteArrayCodec_1 = __webpack_require__(/*! ./builtin/ByteArrayCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ByteArrayCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst AddressCodec_1 = __webpack_require__(/*! ./custom/AddressCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/AddressCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x000200\nconst REQUEST_MESSAGE_TYPE = 512;\n// hex: 0x000201\n// RESPONSE_MESSAGE_TYPE = 513\nconst REQUEST_UUID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_SERIALIZATION_VERSION_OFFSET = REQUEST_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_SERIALIZATION_VERSION_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_STATUS_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_MEMBER_UUID_OFFSET = RESPONSE_STATUS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_SERIALIZATION_VERSION_OFFSET = RESPONSE_MEMBER_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_PARTITION_COUNT_OFFSET = RESPONSE_SERIALIZATION_VERSION_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_CLUSTER_ID_OFFSET = RESPONSE_PARTITION_COUNT_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_FAILOVER_SUPPORTED_OFFSET = RESPONSE_CLUSTER_ID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass ClientAuthenticationCustomCodec {\n    static encodeRequest(clusterName, credentials, uuid, clientType, serializationVersion, clientHazelcastVersion, clientName, labels) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_UUID_OFFSET, uuid);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeByte(initialFrame.content, REQUEST_SERIALIZATION_VERSION_OFFSET, serializationVersion);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, clusterName);\n        ByteArrayCodec_1.ByteArrayCodec.encode(clientMessage, credentials);\n        StringCodec_1.StringCodec.encode(clientMessage, clientType);\n        StringCodec_1.StringCodec.encode(clientMessage, clientHazelcastVersion);\n        StringCodec_1.StringCodec.encode(clientMessage, clientName);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, labels, StringCodec_1.StringCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.status = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeByte(initialFrame.content, RESPONSE_STATUS_OFFSET);\n        response.memberUuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_MEMBER_UUID_OFFSET);\n        response.serializationVersion = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeByte(initialFrame.content, RESPONSE_SERIALIZATION_VERSION_OFFSET);\n        response.partitionCount = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_PARTITION_COUNT_OFFSET);\n        response.clusterId = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_CLUSTER_ID_OFFSET);\n        response.failoverSupported = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_FAILOVER_SUPPORTED_OFFSET);\n        response.address = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, AddressCodec_1.AddressCodec.decode);\n        response.serverHazelcastVersion = StringCodec_1.StringCodec.decode(clientMessage);\n        return response;\n    }\n}\nexports.ClientAuthenticationCustomCodec = ClientAuthenticationCustomCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientAuthenticationCustomCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientCreateProxiesCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientCreateProxiesCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientCreateProxiesCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x000E00\nconst REQUEST_MESSAGE_TYPE = 3584;\n// hex: 0x000E01\n// RESPONSE_MESSAGE_TYPE = 3585\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ClientCreateProxiesCodec {\n    static encodeRequest(proxies) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        EntryListCodec_1.EntryListCodec.encode(clientMessage, proxies, StringCodec_1.StringCodec.encode, StringCodec_1.StringCodec.encode);\n        return clientMessage;\n    }\n}\nexports.ClientCreateProxiesCodec = ClientCreateProxiesCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientCreateProxiesCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientCreateProxyCodec.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientCreateProxyCodec.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientCreateProxyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x000400\nconst REQUEST_MESSAGE_TYPE = 1024;\n// hex: 0x000401\n// RESPONSE_MESSAGE_TYPE = 1025\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ClientCreateProxyCodec {\n    static encodeRequest(name, serviceName) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        StringCodec_1.StringCodec.encode(clientMessage, serviceName);\n        return clientMessage;\n    }\n}\nexports.ClientCreateProxyCodec = ClientCreateProxyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientCreateProxyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientDestroyProxyCodec.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientDestroyProxyCodec.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientDestroyProxyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x000500\nconst REQUEST_MESSAGE_TYPE = 1280;\n// hex: 0x000501\n// RESPONSE_MESSAGE_TYPE = 1281\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ClientDestroyProxyCodec {\n    static encodeRequest(name, serviceName) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        StringCodec_1.StringCodec.encode(clientMessage, serviceName);\n        return clientMessage;\n    }\n}\nexports.ClientDestroyProxyCodec = ClientDestroyProxyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientDestroyProxyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientGetDistributedObjectsCodec.js":
/*!*********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientGetDistributedObjectsCodec.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientGetDistributedObjectsCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DistributedObjectInfoCodec_1 = __webpack_require__(/*! ./custom/DistributedObjectInfoCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/DistributedObjectInfoCodec.js\");\n// hex: 0x000800\nconst REQUEST_MESSAGE_TYPE = 2048;\n// hex: 0x000801\n// RESPONSE_MESSAGE_TYPE = 2049\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ClientGetDistributedObjectsCodec {\n    static encodeRequest() {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DistributedObjectInfoCodec_1.DistributedObjectInfoCodec.decode);\n        return response;\n    }\n}\nexports.ClientGetDistributedObjectsCodec = ClientGetDistributedObjectsCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientGetDistributedObjectsCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientLocalBackupListenerCodec.js":
/*!*******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientLocalBackupListenerCodec.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientLocalBackupListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\n// hex: 0x000F00\nconst REQUEST_MESSAGE_TYPE = 3840;\n// hex: 0x000F01\n// RESPONSE_MESSAGE_TYPE = 3841\n// hex: 0x000F02\nconst EVENT_BACKUP_MESSAGE_TYPE = 3842;\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_BACKUP_SOURCE_INVOCATION_CORRELATION_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ClientLocalBackupListenerCodec {\n    static encodeRequest() {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleBackupEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_BACKUP_MESSAGE_TYPE && handleBackupEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const sourceInvocationCorrelationId = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, EVENT_BACKUP_SOURCE_INVOCATION_CORRELATION_ID_OFFSET);\n            handleBackupEvent(sourceInvocationCorrelationId);\n            return;\n        }\n    }\n}\nexports.ClientLocalBackupListenerCodec = ClientLocalBackupListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientLocalBackupListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientPingCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientPingCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientPingCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\n// hex: 0x000B00\nconst REQUEST_MESSAGE_TYPE = 2816;\n// hex: 0x000B01\n// RESPONSE_MESSAGE_TYPE = 2817\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ClientPingCodec {\n    static encodeRequest() {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        return clientMessage;\n    }\n}\nexports.ClientPingCodec = ClientPingCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientPingCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientRemoveDistributedObjectListenerCodec.js":
/*!*******************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientRemoveDistributedObjectListenerCodec.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientRemoveDistributedObjectListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\n// hex: 0x000A00\nconst REQUEST_MESSAGE_TYPE = 2560;\n// hex: 0x000A01\n// RESPONSE_MESSAGE_TYPE = 2561\nconst REQUEST_REGISTRATION_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REGISTRATION_ID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ClientRemoveDistributedObjectListenerCodec {\n    static encodeRequest(registrationId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_REGISTRATION_ID_OFFSET, registrationId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ClientRemoveDistributedObjectListenerCodec = ClientRemoveDistributedObjectListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientRemoveDistributedObjectListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ClientStatisticsCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ClientStatisticsCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientStatisticsCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ByteArrayCodec_1 = __webpack_require__(/*! ./builtin/ByteArrayCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ByteArrayCodec.js\");\n// hex: 0x000C00\nconst REQUEST_MESSAGE_TYPE = 3072;\n// hex: 0x000C01\n// RESPONSE_MESSAGE_TYPE = 3073\nconst REQUEST_TIMESTAMP_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TIMESTAMP_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass ClientStatisticsCodec {\n    static encodeRequest(timestamp, clientAttributes, metricsBlob) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TIMESTAMP_OFFSET, timestamp);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, clientAttributes);\n        ByteArrayCodec_1.ByteArrayCodec.encode(clientMessage, metricsBlob);\n        return clientMessage;\n    }\n}\nexports.ClientStatisticsCodec = ClientStatisticsCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ClientStatisticsCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/FlakeIdGeneratorNewIdBatchCodec.js":
/*!********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/FlakeIdGeneratorNewIdBatchCodec.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlakeIdGeneratorNewIdBatchCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x1C0100\nconst REQUEST_MESSAGE_TYPE = 1835264;\n// hex: 0x1C0101\n// RESPONSE_MESSAGE_TYPE = 1835265\nconst REQUEST_BATCH_SIZE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_BATCH_SIZE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_BASE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_INCREMENT_OFFSET = RESPONSE_BASE_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_BATCH_SIZE_OFFSET = RESPONSE_INCREMENT_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass FlakeIdGeneratorNewIdBatchCodec {\n    static encodeRequest(name, batchSize) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_BATCH_SIZE_OFFSET, batchSize);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.base = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_BASE_OFFSET);\n        response.increment = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_INCREMENT_OFFSET);\n        response.batchSize = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_BATCH_SIZE_OFFSET);\n        return response;\n    }\n}\nexports.FlakeIdGeneratorNewIdBatchCodec = FlakeIdGeneratorNewIdBatchCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/FlakeIdGeneratorNewIdBatchCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListAddAllCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListAddAllCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListAddAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x050600\nconst REQUEST_MESSAGE_TYPE = 329216;\n// hex: 0x050601\n// RESPONSE_MESSAGE_TYPE = 329217\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListAddAllCodec {\n    static encodeRequest(name, valueList) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, valueList, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListAddAllCodec = ListAddAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListAddAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListAddAllWithIndexCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListAddAllWithIndexCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListAddAllWithIndexCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x050E00\nconst REQUEST_MESSAGE_TYPE = 331264;\n// hex: 0x050E01\n// RESPONSE_MESSAGE_TYPE = 331265\nconst REQUEST_INDEX_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_INDEX_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListAddAllWithIndexCodec {\n    static encodeRequest(name, index, valueList) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_INDEX_OFFSET, index);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, valueList, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListAddAllWithIndexCodec = ListAddAllWithIndexCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListAddAllWithIndexCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListAddCodec.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListAddCodec.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListAddCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x050400\nconst REQUEST_MESSAGE_TYPE = 328704;\n// hex: 0x050401\n// RESPONSE_MESSAGE_TYPE = 328705\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListAddCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListAddCodec = ListAddCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListAddCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListAddListenerCodec.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListAddListenerCodec.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListAddListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x050B00\nconst REQUEST_MESSAGE_TYPE = 330496;\n// hex: 0x050B01\n// RESPONSE_MESSAGE_TYPE = 330497\n// hex: 0x050B02\nconst EVENT_ITEM_MESSAGE_TYPE = 330498;\nconst REQUEST_INCLUDE_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_INCLUDE_VALUE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ITEM_UUID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ITEM_EVENT_TYPE_OFFSET = EVENT_ITEM_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass ListAddListenerCodec {\n    static encodeRequest(name, includeValue, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_INCLUDE_VALUE_OFFSET, includeValue);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleItemEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ITEM_MESSAGE_TYPE && handleItemEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ITEM_UUID_OFFSET);\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ITEM_EVENT_TYPE_OFFSET);\n            const item = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleItemEvent(item, uuid, eventType);\n            return;\n        }\n    }\n}\nexports.ListAddListenerCodec = ListAddListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListAddListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListAddWithIndexCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListAddWithIndexCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListAddWithIndexCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x051100\nconst REQUEST_MESSAGE_TYPE = 332032;\n// hex: 0x051101\n// RESPONSE_MESSAGE_TYPE = 332033\nconst REQUEST_INDEX_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_INDEX_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ListAddWithIndexCodec {\n    static encodeRequest(name, index, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_INDEX_OFFSET, index);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n}\nexports.ListAddWithIndexCodec = ListAddWithIndexCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListAddWithIndexCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListClearCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListClearCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListClearCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x050900\nconst REQUEST_MESSAGE_TYPE = 329984;\n// hex: 0x050901\n// RESPONSE_MESSAGE_TYPE = 329985\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ListClearCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n}\nexports.ListClearCodec = ListClearCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListClearCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListCompareAndRemoveAllCodec.js":
/*!*****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListCompareAndRemoveAllCodec.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListCompareAndRemoveAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x050700\nconst REQUEST_MESSAGE_TYPE = 329472;\n// hex: 0x050701\n// RESPONSE_MESSAGE_TYPE = 329473\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListCompareAndRemoveAllCodec {\n    static encodeRequest(name, values) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, values, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListCompareAndRemoveAllCodec = ListCompareAndRemoveAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListCompareAndRemoveAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListCompareAndRetainAllCodec.js":
/*!*****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListCompareAndRetainAllCodec.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListCompareAndRetainAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x050800\nconst REQUEST_MESSAGE_TYPE = 329728;\n// hex: 0x050801\n// RESPONSE_MESSAGE_TYPE = 329729\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListCompareAndRetainAllCodec {\n    static encodeRequest(name, values) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, values, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListCompareAndRetainAllCodec = ListCompareAndRetainAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListCompareAndRetainAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListContainsAllCodec.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListContainsAllCodec.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListContainsAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x050300\nconst REQUEST_MESSAGE_TYPE = 328448;\n// hex: 0x050301\n// RESPONSE_MESSAGE_TYPE = 328449\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListContainsAllCodec {\n    static encodeRequest(name, values) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, values, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListContainsAllCodec = ListContainsAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListContainsAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListContainsCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListContainsCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListContainsCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x050200\nconst REQUEST_MESSAGE_TYPE = 328192;\n// hex: 0x050201\n// RESPONSE_MESSAGE_TYPE = 328193\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListContainsCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListContainsCodec = ListContainsCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListContainsCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListGetAllCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListGetAllCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListGetAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x050A00\nconst REQUEST_MESSAGE_TYPE = 330240;\n// hex: 0x050A01\n// RESPONSE_MESSAGE_TYPE = 330241\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ListGetAllCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ListGetAllCodec = ListGetAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListGetAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListGetCodec.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListGetCodec.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListGetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x050F00\nconst REQUEST_MESSAGE_TYPE = 331520;\n// hex: 0x050F01\n// RESPONSE_MESSAGE_TYPE = 331521\nconst REQUEST_INDEX_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_INDEX_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ListGetCodec {\n    static encodeRequest(name, index) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_INDEX_OFFSET, index);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ListGetCodec = ListGetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListGetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListIndexOfCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListIndexOfCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListIndexOfCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x051400\nconst REQUEST_MESSAGE_TYPE = 332800;\n// hex: 0x051401\n// RESPONSE_MESSAGE_TYPE = 332801\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListIndexOfCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListIndexOfCodec = ListIndexOfCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListIndexOfCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListIsEmptyCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListIsEmptyCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListIsEmptyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x050D00\nconst REQUEST_MESSAGE_TYPE = 331008;\n// hex: 0x050D01\n// RESPONSE_MESSAGE_TYPE = 331009\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListIsEmptyCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListIsEmptyCodec = ListIsEmptyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListIsEmptyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListLastIndexOfCodec.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListLastIndexOfCodec.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListLastIndexOfCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x051300\nconst REQUEST_MESSAGE_TYPE = 332544;\n// hex: 0x051301\n// RESPONSE_MESSAGE_TYPE = 332545\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListLastIndexOfCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListLastIndexOfCodec = ListLastIndexOfCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListLastIndexOfCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListRemoveCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListRemoveCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListRemoveCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x050500\nconst REQUEST_MESSAGE_TYPE = 328960;\n// hex: 0x050501\n// RESPONSE_MESSAGE_TYPE = 328961\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListRemoveCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListRemoveCodec = ListRemoveCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListRemoveCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListRemoveListenerCodec.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListRemoveListenerCodec.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListRemoveListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x050C00\nconst REQUEST_MESSAGE_TYPE = 330752;\n// hex: 0x050C01\n// RESPONSE_MESSAGE_TYPE = 330753\nconst REQUEST_REGISTRATION_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REGISTRATION_ID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListRemoveListenerCodec {\n    static encodeRequest(name, registrationId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_REGISTRATION_ID_OFFSET, registrationId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListRemoveListenerCodec = ListRemoveListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListRemoveListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListRemoveWithIndexCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListRemoveWithIndexCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListRemoveWithIndexCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x051200\nconst REQUEST_MESSAGE_TYPE = 332288;\n// hex: 0x051201\n// RESPONSE_MESSAGE_TYPE = 332289\nconst REQUEST_INDEX_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_INDEX_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ListRemoveWithIndexCodec {\n    static encodeRequest(name, index) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_INDEX_OFFSET, index);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ListRemoveWithIndexCodec = ListRemoveWithIndexCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListRemoveWithIndexCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListSetCodec.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListSetCodec.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListSetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x051000\nconst REQUEST_MESSAGE_TYPE = 331776;\n// hex: 0x051001\n// RESPONSE_MESSAGE_TYPE = 331777\nconst REQUEST_INDEX_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_INDEX_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ListSetCodec {\n    static encodeRequest(name, index, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_INDEX_OFFSET, index);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ListSetCodec = ListSetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListSetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListSizeCodec.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListSizeCodec.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListSizeCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x050100\nconst REQUEST_MESSAGE_TYPE = 327936;\n// hex: 0x050101\n// RESPONSE_MESSAGE_TYPE = 327937\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ListSizeCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ListSizeCodec = ListSizeCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListSizeCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ListSubCodec.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ListSubCodec.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListSubCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x051500\nconst REQUEST_MESSAGE_TYPE = 333056;\n// hex: 0x051501\n// RESPONSE_MESSAGE_TYPE = 333057\nconst REQUEST_FROM_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_TO_OFFSET = REQUEST_FROM_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TO_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ListSubCodec {\n    static encodeRequest(name, from, to) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_FROM_OFFSET, from);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_TO_OFFSET, to);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ListSubCodec = ListSubCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ListSubCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapAddEntryListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x011900\nconst REQUEST_MESSAGE_TYPE = 71936;\n// hex: 0x011901\n// RESPONSE_MESSAGE_TYPE = 71937\n// hex: 0x011902\nconst EVENT_ENTRY_MESSAGE_TYPE = 71938;\nconst REQUEST_INCLUDE_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LISTENER_FLAGS_OFFSET = REQUEST_INCLUDE_VALUE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_LISTENER_FLAGS_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass MapAddEntryListenerCodec {\n    static encodeRequest(name, includeValue, listenerFlags, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_INCLUDE_VALUE_OFFSET, includeValue);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_LISTENER_FLAGS_OFFSET, listenerFlags);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.MapAddEntryListenerCodec = MapAddEntryListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerToKeyCodec.js":
/*!******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerToKeyCodec.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapAddEntryListenerToKeyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x011800\nconst REQUEST_MESSAGE_TYPE = 71680;\n// hex: 0x011801\n// RESPONSE_MESSAGE_TYPE = 71681\n// hex: 0x011802\nconst EVENT_ENTRY_MESSAGE_TYPE = 71682;\nconst REQUEST_INCLUDE_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LISTENER_FLAGS_OFFSET = REQUEST_INCLUDE_VALUE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_LISTENER_FLAGS_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass MapAddEntryListenerToKeyCodec {\n    static encodeRequest(name, key, includeValue, listenerFlags, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_INCLUDE_VALUE_OFFSET, includeValue);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_LISTENER_FLAGS_OFFSET, listenerFlags);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.MapAddEntryListenerToKeyCodec = MapAddEntryListenerToKeyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerToKeyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerToKeyWithPredicateCodec.js":
/*!*******************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerToKeyWithPredicateCodec.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapAddEntryListenerToKeyWithPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x011600\nconst REQUEST_MESSAGE_TYPE = 71168;\n// hex: 0x011601\n// RESPONSE_MESSAGE_TYPE = 71169\n// hex: 0x011602\nconst EVENT_ENTRY_MESSAGE_TYPE = 71170;\nconst REQUEST_INCLUDE_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LISTENER_FLAGS_OFFSET = REQUEST_INCLUDE_VALUE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_LISTENER_FLAGS_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass MapAddEntryListenerToKeyWithPredicateCodec {\n    static encodeRequest(name, key, predicate, includeValue, listenerFlags, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_INCLUDE_VALUE_OFFSET, includeValue);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_LISTENER_FLAGS_OFFSET, listenerFlags);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.MapAddEntryListenerToKeyWithPredicateCodec = MapAddEntryListenerToKeyWithPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerToKeyWithPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerWithPredicateCodec.js":
/*!**************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerWithPredicateCodec.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapAddEntryListenerWithPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x011700\nconst REQUEST_MESSAGE_TYPE = 71424;\n// hex: 0x011701\n// RESPONSE_MESSAGE_TYPE = 71425\n// hex: 0x011702\nconst EVENT_ENTRY_MESSAGE_TYPE = 71426;\nconst REQUEST_INCLUDE_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LISTENER_FLAGS_OFFSET = REQUEST_INCLUDE_VALUE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_LISTENER_FLAGS_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass MapAddEntryListenerWithPredicateCodec {\n    static encodeRequest(name, predicate, includeValue, listenerFlags, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_INCLUDE_VALUE_OFFSET, includeValue);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_LISTENER_FLAGS_OFFSET, listenerFlags);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.MapAddEntryListenerWithPredicateCodec = MapAddEntryListenerWithPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerWithPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapAddIndexCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapAddIndexCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapAddIndexCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst IndexConfigCodec_1 = __webpack_require__(/*! ./custom/IndexConfigCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/IndexConfigCodec.js\");\n// hex: 0x012900\nconst REQUEST_MESSAGE_TYPE = 76032;\n// hex: 0x012901\n// RESPONSE_MESSAGE_TYPE = 76033\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapAddIndexCodec {\n    static encodeRequest(name, indexConfig) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        IndexConfigCodec_1.IndexConfigCodec.encode(clientMessage, indexConfig);\n        return clientMessage;\n    }\n}\nexports.MapAddIndexCodec = MapAddIndexCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapAddIndexCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapAddNearCacheInvalidationListenerCodec.js":
/*!*****************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapAddNearCacheInvalidationListenerCodec.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapAddNearCacheInvalidationListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst ListUUIDCodec_1 = __webpack_require__(/*! ./builtin/ListUUIDCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListUUIDCodec.js\");\nconst ListLongCodec_1 = __webpack_require__(/*! ./builtin/ListLongCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListLongCodec.js\");\n// hex: 0x013F00\nconst REQUEST_MESSAGE_TYPE = 81664;\n// hex: 0x013F01\n// RESPONSE_MESSAGE_TYPE = 81665\n// hex: 0x013F02\nconst EVENT_I_MAP_INVALIDATION_MESSAGE_TYPE = 81666;\n// hex: 0x013F03\nconst EVENT_I_MAP_BATCH_INVALIDATION_MESSAGE_TYPE = 81667;\nconst REQUEST_LISTENER_FLAGS_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_LISTENER_FLAGS_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_I_MAP_INVALIDATION_SOURCE_UUID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_I_MAP_INVALIDATION_PARTITION_UUID_OFFSET = EVENT_I_MAP_INVALIDATION_SOURCE_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst EVENT_I_MAP_INVALIDATION_SEQUENCE_OFFSET = EVENT_I_MAP_INVALIDATION_PARTITION_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass MapAddNearCacheInvalidationListenerCodec {\n    static encodeRequest(name, listenerFlags, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_LISTENER_FLAGS_OFFSET, listenerFlags);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleIMapInvalidationEvent = null, handleIMapBatchInvalidationEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_I_MAP_INVALIDATION_MESSAGE_TYPE && handleIMapInvalidationEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const sourceUuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_I_MAP_INVALIDATION_SOURCE_UUID_OFFSET);\n            const partitionUuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_I_MAP_INVALIDATION_PARTITION_UUID_OFFSET);\n            const sequence = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, EVENT_I_MAP_INVALIDATION_SEQUENCE_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleIMapInvalidationEvent(key, sourceUuid, partitionUuid, sequence);\n            return;\n        }\n        if (messageType === EVENT_I_MAP_BATCH_INVALIDATION_MESSAGE_TYPE && handleIMapBatchInvalidationEvent !== null) {\n            // empty initial frame\n            clientMessage.nextFrame();\n            const keys = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n            const sourceUuids = ListUUIDCodec_1.ListUUIDCodec.decode(clientMessage);\n            const partitionUuids = ListUUIDCodec_1.ListUUIDCodec.decode(clientMessage);\n            const sequences = ListLongCodec_1.ListLongCodec.decode(clientMessage);\n            handleIMapBatchInvalidationEvent(keys, sourceUuids, partitionUuids, sequences);\n            return;\n        }\n    }\n}\nexports.MapAddNearCacheInvalidationListenerCodec = MapAddNearCacheInvalidationListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapAddNearCacheInvalidationListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapAggregateCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapAggregateCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapAggregateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x013900\nconst REQUEST_MESSAGE_TYPE = 80128;\n// hex: 0x013901\n// RESPONSE_MESSAGE_TYPE = 80129\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapAggregateCodec {\n    static encodeRequest(name, aggregator) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, aggregator);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapAggregateCodec = MapAggregateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapAggregateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapAggregateWithPredicateCodec.js":
/*!*******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapAggregateWithPredicateCodec.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapAggregateWithPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x013A00\nconst REQUEST_MESSAGE_TYPE = 80384;\n// hex: 0x013A01\n// RESPONSE_MESSAGE_TYPE = 80385\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapAggregateWithPredicateCodec {\n    static encodeRequest(name, aggregator, predicate) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, aggregator);\n        DataCodec_1.DataCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapAggregateWithPredicateCodec = MapAggregateWithPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapAggregateWithPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapClearCodec.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapClearCodec.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapClearCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x012D00\nconst REQUEST_MESSAGE_TYPE = 77056;\n// hex: 0x012D01\n// RESPONSE_MESSAGE_TYPE = 77057\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapClearCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n}\nexports.MapClearCodec = MapClearCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapClearCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapContainsKeyCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapContainsKeyCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapContainsKeyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x010600\nconst REQUEST_MESSAGE_TYPE = 67072;\n// hex: 0x010601\n// RESPONSE_MESSAGE_TYPE = 67073\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapContainsKeyCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapContainsKeyCodec = MapContainsKeyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapContainsKeyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapContainsValueCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapContainsValueCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapContainsValueCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x010700\nconst REQUEST_MESSAGE_TYPE = 67328;\n// hex: 0x010701\n// RESPONSE_MESSAGE_TYPE = 67329\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapContainsValueCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapContainsValueCodec = MapContainsValueCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapContainsValueCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapDeleteCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapDeleteCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapDeleteCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x010900\nconst REQUEST_MESSAGE_TYPE = 67840;\n// hex: 0x010901\n// RESPONSE_MESSAGE_TYPE = 67841\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapDeleteCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n}\nexports.MapDeleteCodec = MapDeleteCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapDeleteCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapEntriesWithPagingPredicateCodec.js":
/*!***********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapEntriesWithPagingPredicateCodec.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapEntriesWithPagingPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst PagingPredicateHolderCodec_1 = __webpack_require__(/*! ./custom/PagingPredicateHolderCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/PagingPredicateHolderCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst AnchorDataListHolderCodec_1 = __webpack_require__(/*! ./custom/AnchorDataListHolderCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/AnchorDataListHolderCodec.js\");\n// hex: 0x013600\nconst REQUEST_MESSAGE_TYPE = 79360;\n// hex: 0x013601\n// RESPONSE_MESSAGE_TYPE = 79361\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapEntriesWithPagingPredicateCodec {\n    static encodeRequest(name, predicate) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        PagingPredicateHolderCodec_1.PagingPredicateHolderCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        response.anchorDataList = AnchorDataListHolderCodec_1.AnchorDataListHolderCodec.decode(clientMessage);\n        return response;\n    }\n}\nexports.MapEntriesWithPagingPredicateCodec = MapEntriesWithPagingPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapEntriesWithPagingPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapEntriesWithPredicateCodec.js":
/*!*****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapEntriesWithPredicateCodec.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapEntriesWithPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\n// hex: 0x012800\nconst REQUEST_MESSAGE_TYPE = 75776;\n// hex: 0x012801\n// RESPONSE_MESSAGE_TYPE = 75777\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapEntriesWithPredicateCodec {\n    static encodeRequest(name, predicate) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapEntriesWithPredicateCodec = MapEntriesWithPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapEntriesWithPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapEntrySetCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapEntrySetCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapEntrySetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x012500\nconst REQUEST_MESSAGE_TYPE = 75008;\n// hex: 0x012501\n// RESPONSE_MESSAGE_TYPE = 75009\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapEntrySetCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapEntrySetCodec = MapEntrySetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapEntrySetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapEvictAllCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapEvictAllCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapEvictAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x011F00\nconst REQUEST_MESSAGE_TYPE = 73472;\n// hex: 0x011F01\n// RESPONSE_MESSAGE_TYPE = 73473\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapEvictAllCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n}\nexports.MapEvictAllCodec = MapEvictAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapEvictAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapEvictCodec.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapEvictCodec.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapEvictCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x011E00\nconst REQUEST_MESSAGE_TYPE = 73216;\n// hex: 0x011E01\n// RESPONSE_MESSAGE_TYPE = 73217\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapEvictCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapEvictCodec = MapEvictCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapEvictCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnAllKeysCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnAllKeysCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapExecuteOnAllKeysCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\n// hex: 0x013000\nconst REQUEST_MESSAGE_TYPE = 77824;\n// hex: 0x013001\n// RESPONSE_MESSAGE_TYPE = 77825\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapExecuteOnAllKeysCodec {\n    static encodeRequest(name, entryProcessor) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, entryProcessor);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapExecuteOnAllKeysCodec = MapExecuteOnAllKeysCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnAllKeysCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnKeyCodec.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnKeyCodec.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapExecuteOnKeyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x012E00\nconst REQUEST_MESSAGE_TYPE = 77312;\n// hex: 0x012E01\n// RESPONSE_MESSAGE_TYPE = 77313\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapExecuteOnKeyCodec {\n    static encodeRequest(name, entryProcessor, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, entryProcessor);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapExecuteOnKeyCodec = MapExecuteOnKeyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnKeyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnKeysCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnKeysCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapExecuteOnKeysCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\n// hex: 0x013200\nconst REQUEST_MESSAGE_TYPE = 78336;\n// hex: 0x013201\n// RESPONSE_MESSAGE_TYPE = 78337\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapExecuteOnKeysCodec {\n    static encodeRequest(name, entryProcessor, keys) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, entryProcessor);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, keys, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapExecuteOnKeysCodec = MapExecuteOnKeysCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnKeysCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapExecuteWithPredicateCodec.js":
/*!*****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapExecuteWithPredicateCodec.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapExecuteWithPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\n// hex: 0x013100\nconst REQUEST_MESSAGE_TYPE = 78080;\n// hex: 0x013101\n// RESPONSE_MESSAGE_TYPE = 78081\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapExecuteWithPredicateCodec {\n    static encodeRequest(name, entryProcessor, predicate) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, entryProcessor);\n        DataCodec_1.DataCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapExecuteWithPredicateCodec = MapExecuteWithPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapExecuteWithPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapFetchNearCacheInvalidationMetadataCodec.js":
/*!*******************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapFetchNearCacheInvalidationMetadataCodec.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapFetchNearCacheInvalidationMetadataCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst EntryListIntegerLongCodec_1 = __webpack_require__(/*! ./builtin/EntryListIntegerLongCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListIntegerLongCodec.js\");\nconst EntryListIntegerUUIDCodec_1 = __webpack_require__(/*! ./builtin/EntryListIntegerUUIDCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListIntegerUUIDCodec.js\");\n// hex: 0x013D00\nconst REQUEST_MESSAGE_TYPE = 81152;\n// hex: 0x013D01\n// RESPONSE_MESSAGE_TYPE = 81153\nconst REQUEST_UUID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass MapFetchNearCacheInvalidationMetadataCodec {\n    static encodeRequest(names, uuid) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_UUID_OFFSET, uuid);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, names, StringCodec_1.StringCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.namePartitionSequenceList = EntryListCodec_1.EntryListCodec.decode(clientMessage, StringCodec_1.StringCodec.decode, EntryListIntegerLongCodec_1.EntryListIntegerLongCodec.decode);\n        response.partitionUuidList = EntryListIntegerUUIDCodec_1.EntryListIntegerUUIDCodec.decode(clientMessage);\n        return response;\n    }\n}\nexports.MapFetchNearCacheInvalidationMetadataCodec = MapFetchNearCacheInvalidationMetadataCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapFetchNearCacheInvalidationMetadataCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapFlushCodec.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapFlushCodec.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapFlushCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x010A00\nconst REQUEST_MESSAGE_TYPE = 68096;\n// hex: 0x010A01\n// RESPONSE_MESSAGE_TYPE = 68097\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapFlushCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n}\nexports.MapFlushCodec = MapFlushCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapFlushCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapForceUnlockCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapForceUnlockCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapForceUnlockCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x013300\nconst REQUEST_MESSAGE_TYPE = 78592;\n// hex: 0x013301\n// RESPONSE_MESSAGE_TYPE = 78593\nconst REQUEST_REFERENCE_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REFERENCE_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapForceUnlockCodec {\n    static encodeRequest(name, key, referenceId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_REFERENCE_ID_OFFSET, referenceId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n}\nexports.MapForceUnlockCodec = MapForceUnlockCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapForceUnlockCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapGetAllCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapGetAllCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapGetAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\n// hex: 0x012300\nconst REQUEST_MESSAGE_TYPE = 74496;\n// hex: 0x012301\n// RESPONSE_MESSAGE_TYPE = 74497\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapGetAllCodec {\n    static encodeRequest(name, keys) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, keys, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapGetAllCodec = MapGetAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapGetAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapGetCodec.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapGetCodec.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapGetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x010200\nconst REQUEST_MESSAGE_TYPE = 66048;\n// hex: 0x010201\n// RESPONSE_MESSAGE_TYPE = 66049\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapGetCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapGetCodec = MapGetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapGetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapGetEntryViewCodec.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapGetEntryViewCodec.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapGetEntryViewCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst SimpleEntryViewCodec_1 = __webpack_require__(/*! ./custom/SimpleEntryViewCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/SimpleEntryViewCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x011D00\nconst REQUEST_MESSAGE_TYPE = 72960;\n// hex: 0x011D01\n// RESPONSE_MESSAGE_TYPE = 72961\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_MAX_IDLE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapGetEntryViewCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.maxIdle = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_MAX_IDLE_OFFSET);\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, SimpleEntryViewCodec_1.SimpleEntryViewCodec.decode);\n        return response;\n    }\n}\nexports.MapGetEntryViewCodec = MapGetEntryViewCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapGetEntryViewCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapIsEmptyCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapIsEmptyCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapIsEmptyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x012B00\nconst REQUEST_MESSAGE_TYPE = 76544;\n// hex: 0x012B01\n// RESPONSE_MESSAGE_TYPE = 76545\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapIsEmptyCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapIsEmptyCodec = MapIsEmptyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapIsEmptyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapIsLockedCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapIsLockedCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapIsLockedCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x011200\nconst REQUEST_MESSAGE_TYPE = 70144;\n// hex: 0x011201\n// RESPONSE_MESSAGE_TYPE = 70145\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapIsLockedCodec {\n    static encodeRequest(name, key) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapIsLockedCodec = MapIsLockedCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapIsLockedCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapKeySetCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapKeySetCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapKeySetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x012200\nconst REQUEST_MESSAGE_TYPE = 74240;\n// hex: 0x012201\n// RESPONSE_MESSAGE_TYPE = 74241\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapKeySetCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapKeySetCodec = MapKeySetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapKeySetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapKeySetWithPagingPredicateCodec.js":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapKeySetWithPagingPredicateCodec.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapKeySetWithPagingPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst PagingPredicateHolderCodec_1 = __webpack_require__(/*! ./custom/PagingPredicateHolderCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/PagingPredicateHolderCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst AnchorDataListHolderCodec_1 = __webpack_require__(/*! ./custom/AnchorDataListHolderCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/AnchorDataListHolderCodec.js\");\n// hex: 0x013400\nconst REQUEST_MESSAGE_TYPE = 78848;\n// hex: 0x013401\n// RESPONSE_MESSAGE_TYPE = 78849\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapKeySetWithPagingPredicateCodec {\n    static encodeRequest(name, predicate) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        PagingPredicateHolderCodec_1.PagingPredicateHolderCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        response.anchorDataList = AnchorDataListHolderCodec_1.AnchorDataListHolderCodec.decode(clientMessage);\n        return response;\n    }\n}\nexports.MapKeySetWithPagingPredicateCodec = MapKeySetWithPagingPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapKeySetWithPagingPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapKeySetWithPredicateCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapKeySetWithPredicateCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapKeySetWithPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\n// hex: 0x012600\nconst REQUEST_MESSAGE_TYPE = 75264;\n// hex: 0x012601\n// RESPONSE_MESSAGE_TYPE = 75265\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapKeySetWithPredicateCodec {\n    static encodeRequest(name, predicate) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapKeySetWithPredicateCodec = MapKeySetWithPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapKeySetWithPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapLoadAllCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapLoadAllCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapLoadAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x012000\nconst REQUEST_MESSAGE_TYPE = 73728;\n// hex: 0x012001\n// RESPONSE_MESSAGE_TYPE = 73729\nconst REQUEST_REPLACE_EXISTING_VALUES_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REPLACE_EXISTING_VALUES_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\n/** @internal */\nclass MapLoadAllCodec {\n    static encodeRequest(name, replaceExistingValues) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_REPLACE_EXISTING_VALUES_OFFSET, replaceExistingValues);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n}\nexports.MapLoadAllCodec = MapLoadAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapLoadAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapLoadGivenKeysCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapLoadGivenKeysCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapLoadGivenKeysCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x012100\nconst REQUEST_MESSAGE_TYPE = 73984;\n// hex: 0x012101\n// RESPONSE_MESSAGE_TYPE = 73985\nconst REQUEST_REPLACE_EXISTING_VALUES_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REPLACE_EXISTING_VALUES_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\n/** @internal */\nclass MapLoadGivenKeysCodec {\n    static encodeRequest(name, keys, replaceExistingValues) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_REPLACE_EXISTING_VALUES_OFFSET, replaceExistingValues);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, keys, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n}\nexports.MapLoadGivenKeysCodec = MapLoadGivenKeysCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapLoadGivenKeysCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapLockCodec.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapLockCodec.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapLockCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x011000\nconst REQUEST_MESSAGE_TYPE = 69632;\n// hex: 0x011001\n// RESPONSE_MESSAGE_TYPE = 69633\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_TTL_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_REFERENCE_ID_OFFSET = REQUEST_TTL_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REFERENCE_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapLockCodec {\n    static encodeRequest(name, key, threadId, ttl, referenceId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TTL_OFFSET, ttl);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_REFERENCE_ID_OFFSET, referenceId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n}\nexports.MapLockCodec = MapLockCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapLockCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapPutAllCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapPutAllCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapPutAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x012C00\nconst REQUEST_MESSAGE_TYPE = 76800;\n// hex: 0x012C01\n// RESPONSE_MESSAGE_TYPE = 76801\nconst REQUEST_TRIGGER_MAP_LOADER_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TRIGGER_MAP_LOADER_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\n/** @internal */\nclass MapPutAllCodec {\n    static encodeRequest(name, entries, triggerMapLoader) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_TRIGGER_MAP_LOADER_OFFSET, triggerMapLoader);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        EntryListCodec_1.EntryListCodec.encode(clientMessage, entries, DataCodec_1.DataCodec.encode, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n}\nexports.MapPutAllCodec = MapPutAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapPutAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapPutCodec.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapPutCodec.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapPutCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x010100\nconst REQUEST_MESSAGE_TYPE = 65792;\n// hex: 0x010101\n// RESPONSE_MESSAGE_TYPE = 65793\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_TTL_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TTL_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapPutCodec {\n    static encodeRequest(name, key, value, threadId, ttl) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TTL_OFFSET, ttl);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapPutCodec = MapPutCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapPutCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapPutIfAbsentCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapPutIfAbsentCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapPutIfAbsentCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x010E00\nconst REQUEST_MESSAGE_TYPE = 69120;\n// hex: 0x010E01\n// RESPONSE_MESSAGE_TYPE = 69121\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_TTL_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TTL_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapPutIfAbsentCodec {\n    static encodeRequest(name, key, value, threadId, ttl) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TTL_OFFSET, ttl);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapPutIfAbsentCodec = MapPutIfAbsentCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapPutIfAbsentCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapPutTransientCodec.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapPutTransientCodec.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapPutTransientCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x010D00\nconst REQUEST_MESSAGE_TYPE = 68864;\n// hex: 0x010D01\n// RESPONSE_MESSAGE_TYPE = 68865\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_TTL_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TTL_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapPutTransientCodec {\n    static encodeRequest(name, key, value, threadId, ttl) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TTL_OFFSET, ttl);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n}\nexports.MapPutTransientCodec = MapPutTransientCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapPutTransientCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapRemoveCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapRemoveCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapRemoveCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x010300\nconst REQUEST_MESSAGE_TYPE = 66304;\n// hex: 0x010301\n// RESPONSE_MESSAGE_TYPE = 66305\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapRemoveCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapRemoveCodec = MapRemoveCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapRemoveCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapRemoveEntryListenerCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapRemoveEntryListenerCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapRemoveEntryListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x011A00\nconst REQUEST_MESSAGE_TYPE = 72192;\n// hex: 0x011A01\n// RESPONSE_MESSAGE_TYPE = 72193\nconst REQUEST_REGISTRATION_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REGISTRATION_ID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapRemoveEntryListenerCodec {\n    static encodeRequest(name, registrationId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_REGISTRATION_ID_OFFSET, registrationId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapRemoveEntryListenerCodec = MapRemoveEntryListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapRemoveEntryListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapRemoveIfSameCodec.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapRemoveIfSameCodec.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapRemoveIfSameCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x010800\nconst REQUEST_MESSAGE_TYPE = 67584;\n// hex: 0x010801\n// RESPONSE_MESSAGE_TYPE = 67585\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapRemoveIfSameCodec {\n    static encodeRequest(name, key, value, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapRemoveIfSameCodec = MapRemoveIfSameCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapRemoveIfSameCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapReplaceCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapReplaceCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapReplaceCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x010400\nconst REQUEST_MESSAGE_TYPE = 66560;\n// hex: 0x010401\n// RESPONSE_MESSAGE_TYPE = 66561\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapReplaceCodec {\n    static encodeRequest(name, key, value, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapReplaceCodec = MapReplaceCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapReplaceCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapReplaceIfSameCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapReplaceIfSameCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapReplaceIfSameCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x010500\nconst REQUEST_MESSAGE_TYPE = 66816;\n// hex: 0x010501\n// RESPONSE_MESSAGE_TYPE = 66817\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapReplaceIfSameCodec {\n    static encodeRequest(name, key, testValue, value, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, testValue);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapReplaceIfSameCodec = MapReplaceIfSameCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapReplaceIfSameCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapSetCodec.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapSetCodec.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapSetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x010F00\nconst REQUEST_MESSAGE_TYPE = 69376;\n// hex: 0x010F01\n// RESPONSE_MESSAGE_TYPE = 69377\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_TTL_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TTL_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapSetCodec {\n    static encodeRequest(name, key, value, threadId, ttl) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TTL_OFFSET, ttl);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n}\nexports.MapSetCodec = MapSetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapSetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapSizeCodec.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapSizeCodec.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapSizeCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x012A00\nconst REQUEST_MESSAGE_TYPE = 76288;\n// hex: 0x012A01\n// RESPONSE_MESSAGE_TYPE = 76289\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapSizeCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapSizeCodec = MapSizeCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapSizeCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapTryLockCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapTryLockCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapTryLockCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x011100\nconst REQUEST_MESSAGE_TYPE = 69888;\n// hex: 0x011101\n// RESPONSE_MESSAGE_TYPE = 69889\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LEASE_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_TIMEOUT_OFFSET = REQUEST_LEASE_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_REFERENCE_ID_OFFSET = REQUEST_TIMEOUT_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REFERENCE_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapTryLockCodec {\n    static encodeRequest(name, key, threadId, lease, timeout, referenceId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_LEASE_OFFSET, lease);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TIMEOUT_OFFSET, timeout);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_REFERENCE_ID_OFFSET, referenceId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapTryLockCodec = MapTryLockCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapTryLockCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapTryPutCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapTryPutCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapTryPutCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x010C00\nconst REQUEST_MESSAGE_TYPE = 68608;\n// hex: 0x010C01\n// RESPONSE_MESSAGE_TYPE = 68609\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_TIMEOUT_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TIMEOUT_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapTryPutCodec {\n    static encodeRequest(name, key, value, threadId, timeout) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TIMEOUT_OFFSET, timeout);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapTryPutCodec = MapTryPutCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapTryPutCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapTryRemoveCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapTryRemoveCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapTryRemoveCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x010B00\nconst REQUEST_MESSAGE_TYPE = 68352;\n// hex: 0x010B01\n// RESPONSE_MESSAGE_TYPE = 68353\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_TIMEOUT_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TIMEOUT_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MapTryRemoveCodec {\n    static encodeRequest(name, key, threadId, timeout) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TIMEOUT_OFFSET, timeout);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MapTryRemoveCodec = MapTryRemoveCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapTryRemoveCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapUnlockCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapUnlockCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapUnlockCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x011300\nconst REQUEST_MESSAGE_TYPE = 70400;\n// hex: 0x011301\n// RESPONSE_MESSAGE_TYPE = 70401\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_REFERENCE_ID_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REFERENCE_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MapUnlockCodec {\n    static encodeRequest(name, key, threadId, referenceId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_REFERENCE_ID_OFFSET, referenceId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n}\nexports.MapUnlockCodec = MapUnlockCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapUnlockCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapValuesCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapValuesCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapValuesCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x012400\nconst REQUEST_MESSAGE_TYPE = 74752;\n// hex: 0x012401\n// RESPONSE_MESSAGE_TYPE = 74753\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapValuesCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapValuesCodec = MapValuesCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapValuesCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapValuesWithPagingPredicateCodec.js":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapValuesWithPagingPredicateCodec.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapValuesWithPagingPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst PagingPredicateHolderCodec_1 = __webpack_require__(/*! ./custom/PagingPredicateHolderCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/PagingPredicateHolderCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst AnchorDataListHolderCodec_1 = __webpack_require__(/*! ./custom/AnchorDataListHolderCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/AnchorDataListHolderCodec.js\");\n// hex: 0x013500\nconst REQUEST_MESSAGE_TYPE = 79104;\n// hex: 0x013501\n// RESPONSE_MESSAGE_TYPE = 79105\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapValuesWithPagingPredicateCodec {\n    static encodeRequest(name, predicate) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        PagingPredicateHolderCodec_1.PagingPredicateHolderCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        response.anchorDataList = AnchorDataListHolderCodec_1.AnchorDataListHolderCodec.decode(clientMessage);\n        return response;\n    }\n}\nexports.MapValuesWithPagingPredicateCodec = MapValuesWithPagingPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapValuesWithPagingPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MapValuesWithPredicateCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MapValuesWithPredicateCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapValuesWithPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\n// hex: 0x012700\nconst REQUEST_MESSAGE_TYPE = 75520;\n// hex: 0x012701\n// RESPONSE_MESSAGE_TYPE = 75521\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MapValuesWithPredicateCodec {\n    static encodeRequest(name, predicate) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MapValuesWithPredicateCodec = MapValuesWithPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MapValuesWithPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapAddEntryListenerCodec.js":
/*!******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapAddEntryListenerCodec.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapAddEntryListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x020E00\nconst REQUEST_MESSAGE_TYPE = 134656;\n// hex: 0x020E01\n// RESPONSE_MESSAGE_TYPE = 134657\n// hex: 0x020E02\nconst EVENT_ENTRY_MESSAGE_TYPE = 134658;\nconst REQUEST_INCLUDE_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_INCLUDE_VALUE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapAddEntryListenerCodec {\n    static encodeRequest(name, includeValue, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_INCLUDE_VALUE_OFFSET, includeValue);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.MultiMapAddEntryListenerCodec = MultiMapAddEntryListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapAddEntryListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapAddEntryListenerToKeyCodec.js":
/*!***********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapAddEntryListenerToKeyCodec.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapAddEntryListenerToKeyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x020D00\nconst REQUEST_MESSAGE_TYPE = 134400;\n// hex: 0x020D01\n// RESPONSE_MESSAGE_TYPE = 134401\n// hex: 0x020D02\nconst EVENT_ENTRY_MESSAGE_TYPE = 134402;\nconst REQUEST_INCLUDE_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_INCLUDE_VALUE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapAddEntryListenerToKeyCodec {\n    static encodeRequest(name, key, includeValue, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_INCLUDE_VALUE_OFFSET, includeValue);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.MultiMapAddEntryListenerToKeyCodec = MultiMapAddEntryListenerToKeyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapAddEntryListenerToKeyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapClearCodec.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapClearCodec.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapClearCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x020B00\nconst REQUEST_MESSAGE_TYPE = 133888;\n// hex: 0x020B01\n// RESPONSE_MESSAGE_TYPE = 133889\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapClearCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n}\nexports.MultiMapClearCodec = MultiMapClearCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapClearCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsEntryCodec.js":
/*!***************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsEntryCodec.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapContainsEntryCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x020900\nconst REQUEST_MESSAGE_TYPE = 133376;\n// hex: 0x020901\n// RESPONSE_MESSAGE_TYPE = 133377\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapContainsEntryCodec {\n    static encodeRequest(name, key, value, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapContainsEntryCodec = MultiMapContainsEntryCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsEntryCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsKeyCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsKeyCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapContainsKeyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x020700\nconst REQUEST_MESSAGE_TYPE = 132864;\n// hex: 0x020701\n// RESPONSE_MESSAGE_TYPE = 132865\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapContainsKeyCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapContainsKeyCodec = MultiMapContainsKeyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsKeyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsValueCodec.js":
/*!***************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsValueCodec.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapContainsValueCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x020800\nconst REQUEST_MESSAGE_TYPE = 133120;\n// hex: 0x020801\n// RESPONSE_MESSAGE_TYPE = 133121\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapContainsValueCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapContainsValueCodec = MultiMapContainsValueCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsValueCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapEntrySetCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapEntrySetCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapEntrySetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x020600\nconst REQUEST_MESSAGE_TYPE = 132608;\n// hex: 0x020601\n// RESPONSE_MESSAGE_TYPE = 132609\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapEntrySetCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MultiMapEntrySetCodec = MultiMapEntrySetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapEntrySetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapForceUnlockCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapForceUnlockCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapForceUnlockCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x021400\nconst REQUEST_MESSAGE_TYPE = 136192;\n// hex: 0x021401\n// RESPONSE_MESSAGE_TYPE = 136193\nconst REQUEST_REFERENCE_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REFERENCE_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapForceUnlockCodec {\n    static encodeRequest(name, key, referenceId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_REFERENCE_ID_OFFSET, referenceId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n}\nexports.MultiMapForceUnlockCodec = MultiMapForceUnlockCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapForceUnlockCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapGetCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapGetCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapGetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\n// hex: 0x020200\nconst REQUEST_MESSAGE_TYPE = 131584;\n// hex: 0x020201\n// RESPONSE_MESSAGE_TYPE = 131585\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapGetCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MultiMapGetCodec = MultiMapGetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapGetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapIsLockedCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapIsLockedCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapIsLockedCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x021200\nconst REQUEST_MESSAGE_TYPE = 135680;\n// hex: 0x021201\n// RESPONSE_MESSAGE_TYPE = 135681\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapIsLockedCodec {\n    static encodeRequest(name, key) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapIsLockedCodec = MultiMapIsLockedCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapIsLockedCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapKeySetCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapKeySetCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapKeySetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x020400\nconst REQUEST_MESSAGE_TYPE = 132096;\n// hex: 0x020401\n// RESPONSE_MESSAGE_TYPE = 132097\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapKeySetCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MultiMapKeySetCodec = MultiMapKeySetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapKeySetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapLockCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapLockCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapLockCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x021000\nconst REQUEST_MESSAGE_TYPE = 135168;\n// hex: 0x021001\n// RESPONSE_MESSAGE_TYPE = 135169\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_TTL_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_REFERENCE_ID_OFFSET = REQUEST_TTL_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REFERENCE_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapLockCodec {\n    static encodeRequest(name, key, threadId, ttl, referenceId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TTL_OFFSET, ttl);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_REFERENCE_ID_OFFSET, referenceId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n}\nexports.MultiMapLockCodec = MultiMapLockCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapLockCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapPutAllCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapPutAllCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapPutAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst ListDataCodec_1 = __webpack_require__(/*! ./builtin/ListDataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListDataCodec.js\");\n// hex: 0x021700\nconst REQUEST_MESSAGE_TYPE = 136960;\n// hex: 0x021701\n// RESPONSE_MESSAGE_TYPE = 136961\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapPutAllCodec {\n    static encodeRequest(name, entries) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        EntryListCodec_1.EntryListCodec.encode(clientMessage, entries, DataCodec_1.DataCodec.encode, ListDataCodec_1.ListDataCodec.encode);\n        return clientMessage;\n    }\n}\nexports.MultiMapPutAllCodec = MultiMapPutAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapPutAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapPutCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapPutCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapPutCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x020100\nconst REQUEST_MESSAGE_TYPE = 131328;\n// hex: 0x020101\n// RESPONSE_MESSAGE_TYPE = 131329\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapPutCodec {\n    static encodeRequest(name, key, value, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapPutCodec = MultiMapPutCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapPutCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapRemoveCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\n// hex: 0x020300\nconst REQUEST_MESSAGE_TYPE = 131840;\n// hex: 0x020301\n// RESPONSE_MESSAGE_TYPE = 131841\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapRemoveCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MultiMapRemoveCodec = MultiMapRemoveCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveEntryCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveEntryCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapRemoveEntryCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x021500\nconst REQUEST_MESSAGE_TYPE = 136448;\n// hex: 0x021501\n// RESPONSE_MESSAGE_TYPE = 136449\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapRemoveEntryCodec {\n    static encodeRequest(name, key, value, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapRemoveEntryCodec = MultiMapRemoveEntryCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveEntryCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveEntryListenerCodec.js":
/*!*********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveEntryListenerCodec.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapRemoveEntryListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x020F00\nconst REQUEST_MESSAGE_TYPE = 134912;\n// hex: 0x020F01\n// RESPONSE_MESSAGE_TYPE = 134913\nconst REQUEST_REGISTRATION_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REGISTRATION_ID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapRemoveEntryListenerCodec {\n    static encodeRequest(name, registrationId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_REGISTRATION_ID_OFFSET, registrationId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapRemoveEntryListenerCodec = MultiMapRemoveEntryListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveEntryListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapSizeCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapSizeCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapSizeCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x020A00\nconst REQUEST_MESSAGE_TYPE = 133632;\n// hex: 0x020A01\n// RESPONSE_MESSAGE_TYPE = 133633\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapSizeCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapSizeCodec = MultiMapSizeCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapSizeCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapTryLockCodec.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapTryLockCodec.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapTryLockCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x021100\nconst REQUEST_MESSAGE_TYPE = 135424;\n// hex: 0x021101\n// RESPONSE_MESSAGE_TYPE = 135425\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LEASE_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_TIMEOUT_OFFSET = REQUEST_LEASE_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_REFERENCE_ID_OFFSET = REQUEST_TIMEOUT_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REFERENCE_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapTryLockCodec {\n    static encodeRequest(name, key, threadId, lease, timeout, referenceId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_LEASE_OFFSET, lease);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TIMEOUT_OFFSET, timeout);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_REFERENCE_ID_OFFSET, referenceId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapTryLockCodec = MultiMapTryLockCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapTryLockCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapUnlockCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapUnlockCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapUnlockCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x021300\nconst REQUEST_MESSAGE_TYPE = 135936;\n// hex: 0x021301\n// RESPONSE_MESSAGE_TYPE = 135937\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_REFERENCE_ID_OFFSET = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REFERENCE_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapUnlockCodec {\n    static encodeRequest(name, key, threadId, referenceId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_REFERENCE_ID_OFFSET, referenceId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n}\nexports.MultiMapUnlockCodec = MultiMapUnlockCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapUnlockCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapValueCountCodec.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapValueCountCodec.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapValueCountCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x020C00\nconst REQUEST_MESSAGE_TYPE = 134144;\n// hex: 0x020C01\n// RESPONSE_MESSAGE_TYPE = 134145\nconst REQUEST_THREAD_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_THREAD_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapValueCountCodec {\n    static encodeRequest(name, key, threadId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_THREAD_ID_OFFSET, threadId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.MultiMapValueCountCodec = MultiMapValueCountCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapValueCountCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/MultiMapValuesCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/MultiMapValuesCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapValuesCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x020500\nconst REQUEST_MESSAGE_TYPE = 132352;\n// hex: 0x020501\n// RESPONSE_MESSAGE_TYPE = 132353\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass MultiMapValuesCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.MultiMapValuesCodec = MultiMapValuesCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/MultiMapValuesCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/PNCounterAddCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/PNCounterAddCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNCounterAddCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst EntryListUUIDLongCodec_1 = __webpack_require__(/*! ./builtin/EntryListUUIDLongCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListUUIDLongCodec.js\");\n// hex: 0x1D0200\nconst REQUEST_MESSAGE_TYPE = 1901056;\n// hex: 0x1D0201\n// RESPONSE_MESSAGE_TYPE = 1901057\nconst REQUEST_DELTA_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_GET_BEFORE_UPDATE_OFFSET = REQUEST_DELTA_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_TARGET_REPLICA_UUID_OFFSET = REQUEST_GET_BEFORE_UPDATE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TARGET_REPLICA_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_VALUE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_REPLICA_COUNT_OFFSET = RESPONSE_VALUE_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass PNCounterAddCodec {\n    static encodeRequest(name, delta, getBeforeUpdate, replicaTimestamps, targetReplicaUUID) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_DELTA_OFFSET, delta);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_GET_BEFORE_UPDATE_OFFSET, getBeforeUpdate);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_TARGET_REPLICA_UUID_OFFSET, targetReplicaUUID);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        EntryListUUIDLongCodec_1.EntryListUUIDLongCodec.encode(clientMessage, replicaTimestamps);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.value = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_VALUE_OFFSET);\n        response.replicaCount = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_REPLICA_COUNT_OFFSET);\n        response.replicaTimestamps = EntryListUUIDLongCodec_1.EntryListUUIDLongCodec.decode(clientMessage);\n        return response;\n    }\n}\nexports.PNCounterAddCodec = PNCounterAddCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/PNCounterAddCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/PNCounterGetCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/PNCounterGetCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNCounterGetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst EntryListUUIDLongCodec_1 = __webpack_require__(/*! ./builtin/EntryListUUIDLongCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListUUIDLongCodec.js\");\n// hex: 0x1D0100\nconst REQUEST_MESSAGE_TYPE = 1900800;\n// hex: 0x1D0101\n// RESPONSE_MESSAGE_TYPE = 1900801\nconst REQUEST_TARGET_REPLICA_UUID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TARGET_REPLICA_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_VALUE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_REPLICA_COUNT_OFFSET = RESPONSE_VALUE_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass PNCounterGetCodec {\n    static encodeRequest(name, replicaTimestamps, targetReplicaUUID) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_TARGET_REPLICA_UUID_OFFSET, targetReplicaUUID);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        EntryListUUIDLongCodec_1.EntryListUUIDLongCodec.encode(clientMessage, replicaTimestamps);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.value = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_VALUE_OFFSET);\n        response.replicaCount = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_REPLICA_COUNT_OFFSET);\n        response.replicaTimestamps = EntryListUUIDLongCodec_1.EntryListUUIDLongCodec.decode(clientMessage);\n        return response;\n    }\n}\nexports.PNCounterGetCodec = PNCounterGetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/PNCounterGetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/PNCounterGetConfiguredReplicaCountCodec.js":
/*!****************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/PNCounterGetConfiguredReplicaCountCodec.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNCounterGetConfiguredReplicaCountCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x1D0300\nconst REQUEST_MESSAGE_TYPE = 1901312;\n// hex: 0x1D0301\n// RESPONSE_MESSAGE_TYPE = 1901313\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass PNCounterGetConfiguredReplicaCountCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.PNCounterGetConfiguredReplicaCountCodec = PNCounterGetConfiguredReplicaCountCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/PNCounterGetConfiguredReplicaCountCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueAddAllCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueAddAllCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueAddAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x031000\nconst REQUEST_MESSAGE_TYPE = 200704;\n// hex: 0x031001\n// RESPONSE_MESSAGE_TYPE = 200705\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueAddAllCodec {\n    static encodeRequest(name, dataList) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, dataList, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueAddAllCodec = QueueAddAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueAddAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueAddListenerCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueAddListenerCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueAddListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x031100\nconst REQUEST_MESSAGE_TYPE = 200960;\n// hex: 0x031101\n// RESPONSE_MESSAGE_TYPE = 200961\n// hex: 0x031102\nconst EVENT_ITEM_MESSAGE_TYPE = 200962;\nconst REQUEST_INCLUDE_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_INCLUDE_VALUE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ITEM_UUID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ITEM_EVENT_TYPE_OFFSET = EVENT_ITEM_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass QueueAddListenerCodec {\n    static encodeRequest(name, includeValue, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_INCLUDE_VALUE_OFFSET, includeValue);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleItemEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ITEM_MESSAGE_TYPE && handleItemEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ITEM_UUID_OFFSET);\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ITEM_EVENT_TYPE_OFFSET);\n            const item = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleItemEvent(item, uuid, eventType);\n            return;\n        }\n    }\n}\nexports.QueueAddListenerCodec = QueueAddListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueAddListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueClearCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueClearCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueClearCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x030F00\nconst REQUEST_MESSAGE_TYPE = 200448;\n// hex: 0x030F01\n// RESPONSE_MESSAGE_TYPE = 200449\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass QueueClearCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n}\nexports.QueueClearCodec = QueueClearCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueClearCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueCompareAndRemoveAllCodec.js":
/*!******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueCompareAndRemoveAllCodec.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueCompareAndRemoveAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030D00\nconst REQUEST_MESSAGE_TYPE = 199936;\n// hex: 0x030D01\n// RESPONSE_MESSAGE_TYPE = 199937\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueCompareAndRemoveAllCodec {\n    static encodeRequest(name, dataList) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, dataList, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueCompareAndRemoveAllCodec = QueueCompareAndRemoveAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueCompareAndRemoveAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueCompareAndRetainAllCodec.js":
/*!******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueCompareAndRetainAllCodec.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueCompareAndRetainAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030E00\nconst REQUEST_MESSAGE_TYPE = 200192;\n// hex: 0x030E01\n// RESPONSE_MESSAGE_TYPE = 200193\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueCompareAndRetainAllCodec {\n    static encodeRequest(name, dataList) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, dataList, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueCompareAndRetainAllCodec = QueueCompareAndRetainAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueCompareAndRetainAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueContainsAllCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueContainsAllCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueContainsAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030C00\nconst REQUEST_MESSAGE_TYPE = 199680;\n// hex: 0x030C01\n// RESPONSE_MESSAGE_TYPE = 199681\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueContainsAllCodec {\n    static encodeRequest(name, dataList) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, dataList, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueContainsAllCodec = QueueContainsAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueContainsAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueContainsCodec.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueContainsCodec.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueContainsCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030B00\nconst REQUEST_MESSAGE_TYPE = 199424;\n// hex: 0x030B01\n// RESPONSE_MESSAGE_TYPE = 199425\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueContainsCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueContainsCodec = QueueContainsCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueContainsCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueDrainToCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueDrainToCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueDrainToCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030900\nconst REQUEST_MESSAGE_TYPE = 198912;\n// hex: 0x030901\n// RESPONSE_MESSAGE_TYPE = 198913\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass QueueDrainToCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.QueueDrainToCodec = QueueDrainToCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueDrainToCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueDrainToMaxSizeCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueDrainToMaxSizeCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueDrainToMaxSizeCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030A00\nconst REQUEST_MESSAGE_TYPE = 199168;\n// hex: 0x030A01\n// RESPONSE_MESSAGE_TYPE = 199169\nconst REQUEST_MAX_SIZE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_MAX_SIZE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass QueueDrainToMaxSizeCodec {\n    static encodeRequest(name, maxSize) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_MAX_SIZE_OFFSET, maxSize);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.QueueDrainToMaxSizeCodec = QueueDrainToMaxSizeCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueDrainToMaxSizeCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueIsEmptyCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueIsEmptyCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueIsEmptyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x031400\nconst REQUEST_MESSAGE_TYPE = 201728;\n// hex: 0x031401\n// RESPONSE_MESSAGE_TYPE = 201729\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueIsEmptyCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueIsEmptyCodec = QueueIsEmptyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueIsEmptyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueIteratorCodec.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueIteratorCodec.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueIteratorCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030800\nconst REQUEST_MESSAGE_TYPE = 198656;\n// hex: 0x030801\n// RESPONSE_MESSAGE_TYPE = 198657\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass QueueIteratorCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.QueueIteratorCodec = QueueIteratorCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueIteratorCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueOfferCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueOfferCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueOfferCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030100\nconst REQUEST_MESSAGE_TYPE = 196864;\n// hex: 0x030101\n// RESPONSE_MESSAGE_TYPE = 196865\nconst REQUEST_TIMEOUT_MILLIS_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TIMEOUT_MILLIS_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueOfferCodec {\n    static encodeRequest(name, value, timeoutMillis) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TIMEOUT_MILLIS_OFFSET, timeoutMillis);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueOfferCodec = QueueOfferCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueOfferCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueuePeekCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueuePeekCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueuePeekCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x030700\nconst REQUEST_MESSAGE_TYPE = 198400;\n// hex: 0x030701\n// RESPONSE_MESSAGE_TYPE = 198401\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass QueuePeekCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.QueuePeekCodec = QueuePeekCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueuePeekCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueuePollCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueuePollCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueuePollCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x030500\nconst REQUEST_MESSAGE_TYPE = 197888;\n// hex: 0x030501\n// RESPONSE_MESSAGE_TYPE = 197889\nconst REQUEST_TIMEOUT_MILLIS_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TIMEOUT_MILLIS_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass QueuePollCodec {\n    static encodeRequest(name, timeoutMillis) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TIMEOUT_MILLIS_OFFSET, timeoutMillis);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.QueuePollCodec = QueuePollCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueuePollCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueuePutCodec.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueuePutCodec.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueuePutCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030200\nconst REQUEST_MESSAGE_TYPE = 197120;\n// hex: 0x030201\n// RESPONSE_MESSAGE_TYPE = 197121\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass QueuePutCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n}\nexports.QueuePutCodec = QueuePutCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueuePutCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueRemainingCapacityCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueRemainingCapacityCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueRemainingCapacityCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x031300\nconst REQUEST_MESSAGE_TYPE = 201472;\n// hex: 0x031301\n// RESPONSE_MESSAGE_TYPE = 201473\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueRemainingCapacityCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueRemainingCapacityCodec = QueueRemainingCapacityCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueRemainingCapacityCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueRemoveCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueRemoveCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueRemoveCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x030400\nconst REQUEST_MESSAGE_TYPE = 197632;\n// hex: 0x030401\n// RESPONSE_MESSAGE_TYPE = 197633\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueRemoveCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueRemoveCodec = QueueRemoveCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueRemoveCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueRemoveListenerCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueRemoveListenerCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueRemoveListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x031200\nconst REQUEST_MESSAGE_TYPE = 201216;\n// hex: 0x031201\n// RESPONSE_MESSAGE_TYPE = 201217\nconst REQUEST_REGISTRATION_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REGISTRATION_ID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueRemoveListenerCodec {\n    static encodeRequest(name, registrationId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_REGISTRATION_ID_OFFSET, registrationId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueRemoveListenerCodec = QueueRemoveListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueRemoveListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueSizeCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueSizeCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueSizeCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x030300\nconst REQUEST_MESSAGE_TYPE = 197376;\n// hex: 0x030301\n// RESPONSE_MESSAGE_TYPE = 197377\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass QueueSizeCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.QueueSizeCodec = QueueSizeCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueSizeCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/QueueTakeCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/QueueTakeCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueTakeCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x030600\nconst REQUEST_MESSAGE_TYPE = 198144;\n// hex: 0x030601\n// RESPONSE_MESSAGE_TYPE = 198145\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass QueueTakeCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.QueueTakeCodec = QueueTakeCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/QueueTakeCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerCodec.js":
/*!***********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerCodec.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapAddEntryListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x0D0D00\nconst REQUEST_MESSAGE_TYPE = 855296;\n// hex: 0x0D0D01\n// RESPONSE_MESSAGE_TYPE = 855297\n// hex: 0x0D0D02\nconst EVENT_ENTRY_MESSAGE_TYPE = 855298;\nconst REQUEST_LOCAL_ONLY_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapAddEntryListenerCodec {\n    static encodeRequest(name, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.ReplicatedMapAddEntryListenerCodec = ReplicatedMapAddEntryListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerToKeyCodec.js":
/*!****************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerToKeyCodec.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapAddEntryListenerToKeyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x0D0C00\nconst REQUEST_MESSAGE_TYPE = 855040;\n// hex: 0x0D0C01\n// RESPONSE_MESSAGE_TYPE = 855041\n// hex: 0x0D0C02\nconst EVENT_ENTRY_MESSAGE_TYPE = 855042;\nconst REQUEST_LOCAL_ONLY_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapAddEntryListenerToKeyCodec {\n    static encodeRequest(name, key, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.ReplicatedMapAddEntryListenerToKeyCodec = ReplicatedMapAddEntryListenerToKeyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerToKeyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.js":
/*!*****************************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapAddEntryListenerToKeyWithPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x0D0A00\nconst REQUEST_MESSAGE_TYPE = 854528;\n// hex: 0x0D0A01\n// RESPONSE_MESSAGE_TYPE = 854529\n// hex: 0x0D0A02\nconst EVENT_ENTRY_MESSAGE_TYPE = 854530;\nconst REQUEST_LOCAL_ONLY_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapAddEntryListenerToKeyWithPredicateCodec {\n    static encodeRequest(name, key, predicate, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.ReplicatedMapAddEntryListenerToKeyWithPredicateCodec = ReplicatedMapAddEntryListenerToKeyWithPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerWithPredicateCodec.js":
/*!************************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerWithPredicateCodec.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapAddEntryListenerWithPredicateCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x0D0B00\nconst REQUEST_MESSAGE_TYPE = 854784;\n// hex: 0x0D0B01\n// RESPONSE_MESSAGE_TYPE = 854785\n// hex: 0x0D0B02\nconst EVENT_ENTRY_MESSAGE_TYPE = 854786;\nconst REQUEST_LOCAL_ONLY_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ENTRY_EVENT_TYPE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_UUID_OFFSET = EVENT_ENTRY_EVENT_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET = EVENT_ENTRY_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapAddEntryListenerWithPredicateCodec {\n    static encodeRequest(name, predicate, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, predicate);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleEntryEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ENTRY_MESSAGE_TYPE && handleEntryEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_EVENT_TYPE_OFFSET);\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ENTRY_UUID_OFFSET);\n            const numberOfAffectedEntries = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ENTRY_NUMBER_OF_AFFECTED_ENTRIES_OFFSET);\n            const key = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const value = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const oldValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            const mergingValue = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleEntryEvent(key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries);\n            return;\n        }\n    }\n}\nexports.ReplicatedMapAddEntryListenerWithPredicateCodec = ReplicatedMapAddEntryListenerWithPredicateCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerWithPredicateCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapClearCodec.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapClearCodec.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapClearCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x0D0900\nconst REQUEST_MESSAGE_TYPE = 854272;\n// hex: 0x0D0901\n// RESPONSE_MESSAGE_TYPE = 854273\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapClearCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n}\nexports.ReplicatedMapClearCodec = ReplicatedMapClearCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapClearCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapContainsKeyCodec.js":
/*!******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapContainsKeyCodec.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapContainsKeyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x0D0400\nconst REQUEST_MESSAGE_TYPE = 852992;\n// hex: 0x0D0401\n// RESPONSE_MESSAGE_TYPE = 852993\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapContainsKeyCodec {\n    static encodeRequest(name, key) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ReplicatedMapContainsKeyCodec = ReplicatedMapContainsKeyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapContainsKeyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapContainsValueCodec.js":
/*!********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapContainsValueCodec.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapContainsValueCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x0D0500\nconst REQUEST_MESSAGE_TYPE = 853248;\n// hex: 0x0D0501\n// RESPONSE_MESSAGE_TYPE = 853249\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapContainsValueCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ReplicatedMapContainsValueCodec = ReplicatedMapContainsValueCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapContainsValueCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapEntrySetCodec.js":
/*!***************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapEntrySetCodec.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapEntrySetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x0D1100\nconst REQUEST_MESSAGE_TYPE = 856320;\n// hex: 0x0D1101\n// RESPONSE_MESSAGE_TYPE = 856321\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapEntrySetCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ReplicatedMapEntrySetCodec = ReplicatedMapEntrySetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapEntrySetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapGetCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapGetCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapGetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x0D0600\nconst REQUEST_MESSAGE_TYPE = 853504;\n// hex: 0x0D0601\n// RESPONSE_MESSAGE_TYPE = 853505\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapGetCodec {\n    static encodeRequest(name, key) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ReplicatedMapGetCodec = ReplicatedMapGetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapGetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapIsEmptyCodec.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapIsEmptyCodec.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapIsEmptyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x0D0300\nconst REQUEST_MESSAGE_TYPE = 852736;\n// hex: 0x0D0301\n// RESPONSE_MESSAGE_TYPE = 852737\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapIsEmptyCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ReplicatedMapIsEmptyCodec = ReplicatedMapIsEmptyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapIsEmptyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapKeySetCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapKeySetCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapKeySetCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x0D0F00\nconst REQUEST_MESSAGE_TYPE = 855808;\n// hex: 0x0D0F01\n// RESPONSE_MESSAGE_TYPE = 855809\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapKeySetCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ReplicatedMapKeySetCodec = ReplicatedMapKeySetCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapKeySetCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapPutAllCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapPutAllCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapPutAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ./builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x0D0800\nconst REQUEST_MESSAGE_TYPE = 854016;\n// hex: 0x0D0801\n// RESPONSE_MESSAGE_TYPE = 854017\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapPutAllCodec {\n    static encodeRequest(name, entries) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        EntryListCodec_1.EntryListCodec.encode(clientMessage, entries, DataCodec_1.DataCodec.encode, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n}\nexports.ReplicatedMapPutAllCodec = ReplicatedMapPutAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapPutAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapPutCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapPutCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapPutCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x0D0100\nconst REQUEST_MESSAGE_TYPE = 852224;\n// hex: 0x0D0101\n// RESPONSE_MESSAGE_TYPE = 852225\nconst REQUEST_TTL_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_TTL_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapPutCodec {\n    static encodeRequest(name, key, value, ttl) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_TTL_OFFSET, ttl);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ReplicatedMapPutCodec = ReplicatedMapPutCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapPutCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapRemoveCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapRemoveCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapRemoveCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x0D0700\nconst REQUEST_MESSAGE_TYPE = 853760;\n// hex: 0x0D0701\n// RESPONSE_MESSAGE_TYPE = 853761\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapRemoveCodec {\n    static encodeRequest(name, key) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, key);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ReplicatedMapRemoveCodec = ReplicatedMapRemoveCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapRemoveCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapRemoveEntryListenerCodec.js":
/*!**************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapRemoveEntryListenerCodec.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapRemoveEntryListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x0D0E00\nconst REQUEST_MESSAGE_TYPE = 855552;\n// hex: 0x0D0E01\n// RESPONSE_MESSAGE_TYPE = 855553\nconst REQUEST_REGISTRATION_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REGISTRATION_ID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapRemoveEntryListenerCodec {\n    static encodeRequest(name, registrationId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_REGISTRATION_ID_OFFSET, registrationId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ReplicatedMapRemoveEntryListenerCodec = ReplicatedMapRemoveEntryListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapRemoveEntryListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapSizeCodec.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapSizeCodec.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapSizeCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x0D0200\nconst REQUEST_MESSAGE_TYPE = 852480;\n// hex: 0x0D0201\n// RESPONSE_MESSAGE_TYPE = 852481\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapSizeCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.ReplicatedMapSizeCodec = ReplicatedMapSizeCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapSizeCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapValuesCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapValuesCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapValuesCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x0D1000\nconst REQUEST_MESSAGE_TYPE = 856064;\n// hex: 0x0D1001\n// RESPONSE_MESSAGE_TYPE = 856065\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ReplicatedMapValuesCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.ReplicatedMapValuesCodec = ReplicatedMapValuesCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapValuesCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/RingbufferAddAllCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/RingbufferAddAllCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferAddAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x170800\nconst REQUEST_MESSAGE_TYPE = 1509376;\n// hex: 0x170801\n// RESPONSE_MESSAGE_TYPE = 1509377\nconst REQUEST_OVERFLOW_POLICY_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_OVERFLOW_POLICY_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass RingbufferAddAllCodec {\n    static encodeRequest(name, valueList, overflowPolicy) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_OVERFLOW_POLICY_OFFSET, overflowPolicy);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, valueList, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.RingbufferAddAllCodec = RingbufferAddAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/RingbufferAddAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/RingbufferAddCodec.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/RingbufferAddCodec.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferAddCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x170600\nconst REQUEST_MESSAGE_TYPE = 1508864;\n// hex: 0x170601\n// RESPONSE_MESSAGE_TYPE = 1508865\nconst REQUEST_OVERFLOW_POLICY_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_OVERFLOW_POLICY_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass RingbufferAddCodec {\n    static encodeRequest(name, overflowPolicy, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_OVERFLOW_POLICY_OFFSET, overflowPolicy);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.RingbufferAddCodec = RingbufferAddCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/RingbufferAddCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/RingbufferCapacityCodec.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/RingbufferCapacityCodec.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferCapacityCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x170400\nconst REQUEST_MESSAGE_TYPE = 1508352;\n// hex: 0x170401\n// RESPONSE_MESSAGE_TYPE = 1508353\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass RingbufferCapacityCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.RingbufferCapacityCodec = RingbufferCapacityCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/RingbufferCapacityCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/RingbufferHeadSequenceCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/RingbufferHeadSequenceCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferHeadSequenceCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x170300\nconst REQUEST_MESSAGE_TYPE = 1508096;\n// hex: 0x170301\n// RESPONSE_MESSAGE_TYPE = 1508097\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass RingbufferHeadSequenceCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.RingbufferHeadSequenceCodec = RingbufferHeadSequenceCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/RingbufferHeadSequenceCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/RingbufferReadManyCodec.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/RingbufferReadManyCodec.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferReadManyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst LongArrayCodec_1 = __webpack_require__(/*! ./builtin/LongArrayCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/LongArrayCodec.js\");\n// hex: 0x170900\nconst REQUEST_MESSAGE_TYPE = 1509632;\n// hex: 0x170901\n// RESPONSE_MESSAGE_TYPE = 1509633\nconst REQUEST_START_SEQUENCE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_MIN_COUNT_OFFSET = REQUEST_START_SEQUENCE_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst REQUEST_MAX_COUNT_OFFSET = REQUEST_MIN_COUNT_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_MAX_COUNT_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_READ_COUNT_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst RESPONSE_NEXT_SEQ_OFFSET = RESPONSE_READ_COUNT_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass RingbufferReadManyCodec {\n    static encodeRequest(name, startSequence, minCount, maxCount, filter) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_START_SEQUENCE_OFFSET, startSequence);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_MIN_COUNT_OFFSET, minCount);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, REQUEST_MAX_COUNT_OFFSET, maxCount);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, filter, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.readCount = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_READ_COUNT_OFFSET);\n        response.nextSeq = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_NEXT_SEQ_OFFSET);\n        response.items = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        response.itemSeqs = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, LongArrayCodec_1.LongArrayCodec.decode);\n        return response;\n    }\n}\nexports.RingbufferReadManyCodec = RingbufferReadManyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/RingbufferReadManyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/RingbufferReadOneCodec.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/RingbufferReadOneCodec.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferReadOneCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x170700\nconst REQUEST_MESSAGE_TYPE = 1509120;\n// hex: 0x170701\n// RESPONSE_MESSAGE_TYPE = 1509121\nconst REQUEST_SEQUENCE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_SEQUENCE_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass RingbufferReadOneCodec {\n    static encodeRequest(name, sequence) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, REQUEST_SEQUENCE_OFFSET, sequence);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.RingbufferReadOneCodec = RingbufferReadOneCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/RingbufferReadOneCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/RingbufferRemainingCapacityCodec.js":
/*!*********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/RingbufferRemainingCapacityCodec.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferRemainingCapacityCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x170500\nconst REQUEST_MESSAGE_TYPE = 1508608;\n// hex: 0x170501\n// RESPONSE_MESSAGE_TYPE = 1508609\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass RingbufferRemainingCapacityCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.RingbufferRemainingCapacityCodec = RingbufferRemainingCapacityCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/RingbufferRemainingCapacityCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/RingbufferSizeCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/RingbufferSizeCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferSizeCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x170100\nconst REQUEST_MESSAGE_TYPE = 1507584;\n// hex: 0x170101\n// RESPONSE_MESSAGE_TYPE = 1507585\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass RingbufferSizeCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.RingbufferSizeCodec = RingbufferSizeCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/RingbufferSizeCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/RingbufferTailSequenceCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/RingbufferTailSequenceCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferTailSequenceCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x170200\nconst REQUEST_MESSAGE_TYPE = 1507840;\n// hex: 0x170201\n// RESPONSE_MESSAGE_TYPE = 1507841\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass RingbufferTailSequenceCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.RingbufferTailSequenceCodec = RingbufferTailSequenceCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/RingbufferTailSequenceCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetAddAllCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetAddAllCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetAddAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x060600\nconst REQUEST_MESSAGE_TYPE = 394752;\n// hex: 0x060601\n// RESPONSE_MESSAGE_TYPE = 394753\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetAddAllCodec {\n    static encodeRequest(name, valueList) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, valueList, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetAddAllCodec = SetAddAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetAddAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetAddCodec.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetAddCodec.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetAddCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x060400\nconst REQUEST_MESSAGE_TYPE = 394240;\n// hex: 0x060401\n// RESPONSE_MESSAGE_TYPE = 394241\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetAddCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetAddCodec = SetAddCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetAddCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetAddListenerCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetAddListenerCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetAddListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n// hex: 0x060B00\nconst REQUEST_MESSAGE_TYPE = 396032;\n// hex: 0x060B01\n// RESPONSE_MESSAGE_TYPE = 396033\n// hex: 0x060B02\nconst EVENT_ITEM_MESSAGE_TYPE = 396034;\nconst REQUEST_INCLUDE_VALUE_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_LOCAL_ONLY_OFFSET = REQUEST_INCLUDE_VALUE_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_LOCAL_ONLY_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst EVENT_ITEM_UUID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst EVENT_ITEM_EVENT_TYPE_OFFSET = EVENT_ITEM_UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass SetAddListenerCodec {\n    static encodeRequest(name, includeValue, localOnly) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_INCLUDE_VALUE_OFFSET, includeValue);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, REQUEST_LOCAL_ONLY_OFFSET, localOnly);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n    static handle(clientMessage, handleItemEvent = null) {\n        const messageType = clientMessage.getMessageType();\n        if (messageType === EVENT_ITEM_MESSAGE_TYPE && handleItemEvent !== null) {\n            const initialFrame = clientMessage.nextFrame();\n            const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, EVENT_ITEM_UUID_OFFSET);\n            const eventType = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, EVENT_ITEM_EVENT_TYPE_OFFSET);\n            const item = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n            handleItemEvent(item, uuid, eventType);\n            return;\n        }\n    }\n}\nexports.SetAddListenerCodec = SetAddListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetAddListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetClearCodec.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetClearCodec.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetClearCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x060900\nconst REQUEST_MESSAGE_TYPE = 395520;\n// hex: 0x060901\n// RESPONSE_MESSAGE_TYPE = 395521\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass SetClearCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n}\nexports.SetClearCodec = SetClearCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetClearCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetCompareAndRemoveAllCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetCompareAndRemoveAllCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetCompareAndRemoveAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x060700\nconst REQUEST_MESSAGE_TYPE = 395008;\n// hex: 0x060701\n// RESPONSE_MESSAGE_TYPE = 395009\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetCompareAndRemoveAllCodec {\n    static encodeRequest(name, values) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, values, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetCompareAndRemoveAllCodec = SetCompareAndRemoveAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetCompareAndRemoveAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetCompareAndRetainAllCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetCompareAndRetainAllCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetCompareAndRetainAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x060800\nconst REQUEST_MESSAGE_TYPE = 395264;\n// hex: 0x060801\n// RESPONSE_MESSAGE_TYPE = 395265\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetCompareAndRetainAllCodec {\n    static encodeRequest(name, values) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, values, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetCompareAndRetainAllCodec = SetCompareAndRetainAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetCompareAndRetainAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetContainsAllCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetContainsAllCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetContainsAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x060300\nconst REQUEST_MESSAGE_TYPE = 393984;\n// hex: 0x060301\n// RESPONSE_MESSAGE_TYPE = 393985\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetContainsAllCodec {\n    static encodeRequest(name, items) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, items, DataCodec_1.DataCodec.encode);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetContainsAllCodec = SetContainsAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetContainsAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetContainsCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetContainsCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetContainsCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x060200\nconst REQUEST_MESSAGE_TYPE = 393728;\n// hex: 0x060201\n// RESPONSE_MESSAGE_TYPE = 393729\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetContainsCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetContainsCodec = SetContainsCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetContainsCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetGetAllCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetGetAllCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetGetAllCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x060A00\nconst REQUEST_MESSAGE_TYPE = 395776;\n// hex: 0x060A01\n// RESPONSE_MESSAGE_TYPE = 395777\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass SetGetAllCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        // empty initial frame\n        clientMessage.nextFrame();\n        const response = {};\n        response.response = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n        return response;\n    }\n}\nexports.SetGetAllCodec = SetGetAllCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetGetAllCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetIsEmptyCodec.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetIsEmptyCodec.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetIsEmptyCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x060D00\nconst REQUEST_MESSAGE_TYPE = 396544;\n// hex: 0x060D01\n// RESPONSE_MESSAGE_TYPE = 396545\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetIsEmptyCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetIsEmptyCodec = SetIsEmptyCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetIsEmptyCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetRemoveCodec.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetRemoveCodec.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetRemoveCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n// hex: 0x060500\nconst REQUEST_MESSAGE_TYPE = 394496;\n// hex: 0x060501\n// RESPONSE_MESSAGE_TYPE = 394497\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetRemoveCodec {\n    static encodeRequest(name, value) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        DataCodec_1.DataCodec.encode(clientMessage, value);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetRemoveCodec = SetRemoveCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetRemoveCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetRemoveListenerCodec.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetRemoveListenerCodec.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetRemoveListenerCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x060C00\nconst REQUEST_MESSAGE_TYPE = 396288;\n// hex: 0x060C01\n// RESPONSE_MESSAGE_TYPE = 396289\nconst REQUEST_REGISTRATION_ID_OFFSET = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst REQUEST_INITIAL_FRAME_SIZE = REQUEST_REGISTRATION_ID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetRemoveListenerCodec {\n    static encodeRequest(name, registrationId) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(true);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, REQUEST_REGISTRATION_ID_OFFSET, registrationId);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetRemoveListenerCodec = SetRemoveListenerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetRemoveListenerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/SetSizeCodec.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/SetSizeCodec.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetSizeCodec = void 0;\n/* eslint-disable max-len */\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst StringCodec_1 = __webpack_require__(/*! ./builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\n// hex: 0x060100\nconst REQUEST_MESSAGE_TYPE = 393472;\n// hex: 0x060101\n// RESPONSE_MESSAGE_TYPE = 393473\nconst REQUEST_INITIAL_FRAME_SIZE = ClientMessage_1.PARTITION_ID_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst RESPONSE_RESPONSE_OFFSET = ClientMessage_1.RESPONSE_BACKUP_ACKS_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass SetSizeCodec {\n    static encodeRequest(name) {\n        const clientMessage = ClientMessage_1.ClientMessage.createForEncode();\n        clientMessage.setRetryable(false);\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(REQUEST_INITIAL_FRAME_SIZE);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.setMessageType(REQUEST_MESSAGE_TYPE);\n        clientMessage.setPartitionId(-1);\n        StringCodec_1.StringCodec.encode(clientMessage, name);\n        return clientMessage;\n    }\n    static decodeResponse(clientMessage) {\n        const initialFrame = clientMessage.nextFrame();\n        const response = {};\n        response.response = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, RESPONSE_RESPONSE_OFFSET);\n        return response;\n    }\n}\nexports.SetSizeCodec = SetSizeCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/SetSizeCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/ByteArrayCodec.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/ByteArrayCodec.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ByteArrayCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\n/** @internal */\nclass ByteArrayCodec {\n    static encode(clientMessage, bytes) {\n        clientMessage.addFrame(new ClientMessage_1.Frame(bytes));\n    }\n    static decode(clientMessage) {\n        return clientMessage.nextFrame().content;\n    }\n}\nexports.ByteArrayCodec = ByteArrayCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/ByteArrayCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodecUtil = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\n/** @internal */\nclass CodecUtil {\n    static fastForwardToEndFrame(clientMessage) {\n        // We are starting from 1 because of the BEGIN_FRAME we read\n        // in the beginning of the decode method\n        let numberOfExpectedEndFrames = 1;\n        let frame;\n        while (numberOfExpectedEndFrames !== 0) {\n            frame = clientMessage.nextFrame();\n            if (frame.isEndFrame()) {\n                numberOfExpectedEndFrames--;\n            }\n            else if (frame.isBeginFrame()) {\n                numberOfExpectedEndFrames++;\n            }\n        }\n    }\n    static encodeNullable(clientMessage, value, encoder) {\n        if (value == null) {\n            clientMessage.addFrame(ClientMessage_1.NULL_FRAME.copy());\n        }\n        else {\n            encoder(clientMessage, value);\n        }\n    }\n    static decodeNullable(clientMessage, decoder) {\n        return CodecUtil.nextFrameIsNullFrame(clientMessage) ? null : decoder(clientMessage);\n    }\n    static nextFrameIsDataStructureEndFrame(clientMessage) {\n        return clientMessage.peekNextFrame().isEndFrame();\n    }\n    /**\n     * Returns whether the next frame is {@link NULL_FRAME} or not.\n     * If it is a {@link NULL_FRAME}, this method consumes the iterator\n     * by calling {@link ClientMessage.nextFrame} once to skip the {@link NULL_FRAME}.\n     */\n    static nextFrameIsNullFrame(clientMessage) {\n        const isNull = clientMessage.peekNextFrame().isNullFrame();\n        if (isNull) {\n            clientMessage.nextFrame();\n        }\n        return isNull;\n    }\n}\nexports.CodecUtil = CodecUtil;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst HeapData_1 = __webpack_require__(/*! ../../serialization/HeapData */ \"../shared/node_modules/hazelcast-client/lib/serialization/HeapData.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n/** @internal */\nclass DataCodec {\n    static encode(clientMessage, data) {\n        clientMessage.addFrame(new ClientMessage_1.Frame(data.toBuffer()));\n    }\n    static encodeNullable(clientMessage, data) {\n        if (data === null) {\n            clientMessage.addFrame(ClientMessage_1.NULL_FRAME.copy());\n        }\n        else {\n            clientMessage.addFrame(new ClientMessage_1.Frame(data.toBuffer()));\n        }\n    }\n    static decode(clientMessage) {\n        return new HeapData_1.HeapData(clientMessage.nextFrame().content);\n    }\n    static decodeNullable(clientMessage) {\n        return CodecUtil_1.CodecUtil.nextFrameIsNullFrame(clientMessage) ? null : this.decode(clientMessage);\n    }\n}\nexports.DataCodec = DataCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryListCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n/** @internal */\nclass EntryListCodec {\n    static encode(clientMessage, entries, keyEncoder, valueEncoder) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        for (let i = 0, n = entries.length; i < n; i++) {\n            keyEncoder(clientMessage, entries[i][0]);\n            valueEncoder(clientMessage, entries[i][1]);\n        }\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static encodeNullable(clientMessage, entries, keyEncoder, valueEncoder) {\n        if (entries === null) {\n            clientMessage.addFrame(ClientMessage_1.NULL_FRAME.copy());\n        }\n        else {\n            this.encode(clientMessage, entries, keyEncoder, valueEncoder);\n        }\n    }\n    static decode(clientMessage, keyDecoder, valueDecoder) {\n        const result = [];\n        // begin frame\n        clientMessage.nextFrame();\n        while (!CodecUtil_1.CodecUtil.nextFrameIsDataStructureEndFrame(clientMessage)) {\n            const key = keyDecoder(clientMessage);\n            const value = valueDecoder(clientMessage);\n            result.push([key, value]);\n        }\n        // end frame\n        clientMessage.nextFrame();\n        return result;\n    }\n    static decodeNullable(clientMessage, keyDecoder, valueDecoder) {\n        return CodecUtil_1.CodecUtil.nextFrameIsNullFrame(clientMessage) ? null : this.decode(clientMessage, keyDecoder, valueDecoder);\n    }\n}\nexports.EntryListCodec = EntryListCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListIntegerLongCodec.js":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListIntegerLongCodec.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryListIntegerLongCodec = void 0;\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ENTRY_SIZE_IN_BYTES = BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass EntryListIntegerLongCodec {\n    static encode(clientMessage, entries) {\n        const entryCount = entries.length;\n        const frame = new ClientMessage_1.Frame(Buffer.allocUnsafe(entryCount * ENTRY_SIZE_IN_BYTES));\n        for (let i = 0; i < entryCount; i++) {\n            FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(frame.content, i * ENTRY_SIZE_IN_BYTES, entries[i][0]);\n            FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(frame.content, i * ENTRY_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, entries[i][1]);\n        }\n        clientMessage.addFrame(frame);\n    }\n    static decode(clientMessage) {\n        const frame = clientMessage.nextFrame();\n        const entryCount = frame.content.length / ENTRY_SIZE_IN_BYTES;\n        const result = new Array(entryCount);\n        for (let i = 0; i < entryCount; i++) {\n            const key = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(frame.content, i * ENTRY_SIZE_IN_BYTES);\n            const value = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(frame.content, i * ENTRY_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n            result[i] = [key, value];\n        }\n        return result;\n    }\n}\nexports.EntryListIntegerLongCodec = EntryListIntegerLongCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListIntegerLongCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListIntegerUUIDCodec.js":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListIntegerUUIDCodec.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryListIntegerUUIDCodec = void 0;\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ENTRY_SIZE_IN_BYTES = BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n/** @internal */\nclass EntryListIntegerUUIDCodec {\n    static encode(clientMessage, entries) {\n        const entryCount = entries.length;\n        const frame = new ClientMessage_1.Frame(Buffer.allocUnsafe(entryCount * ENTRY_SIZE_IN_BYTES));\n        for (let i = 0; i < entryCount; i++) {\n            FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(frame.content, i * ENTRY_SIZE_IN_BYTES, entries[i][0]);\n            FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(frame.content, i * ENTRY_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, entries[i][1]);\n        }\n        clientMessage.addFrame(frame);\n    }\n    static decode(clientMessage) {\n        const frame = clientMessage.nextFrame();\n        const entryCount = frame.content.length / ENTRY_SIZE_IN_BYTES;\n        const result = new Array(entryCount);\n        for (let i = 0; i < entryCount; i++) {\n            const key = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(frame.content, i * ENTRY_SIZE_IN_BYTES);\n            const value = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(frame.content, i * ENTRY_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n            result[i] = [key, value];\n        }\n        return result;\n    }\n}\nexports.EntryListIntegerUUIDCodec = EntryListIntegerUUIDCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListIntegerUUIDCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListUUIDListIntegerCodec.js":
/*!**************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListUUIDListIntegerCodec.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryListUUIDListIntegerCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst ListIntegerCodec_1 = __webpack_require__(/*! ./ListIntegerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListIntegerCodec.js\");\nconst ListUUIDCodec_1 = __webpack_require__(/*! ./ListUUIDCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListUUIDCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\n/** @internal */\nclass EntryListUUIDListIntegerCodec {\n    static encode(clientMessage, entries) {\n        const entryCount = entries.length;\n        const keys = new Array(entryCount);\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        for (let i = 0; i < entryCount; i++) {\n            keys[i] = entries[i][0];\n            ListIntegerCodec_1.ListIntegerCodec.encode(clientMessage, entries[i][1]);\n        }\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n        ListUUIDCodec_1.ListUUIDCodec.encode(clientMessage, keys);\n    }\n    static decode(clientMessage) {\n        const values = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, ListIntegerCodec_1.ListIntegerCodec.decode);\n        const keys = ListUUIDCodec_1.ListUUIDCodec.decode(clientMessage);\n        const result = new Array(keys.length);\n        for (let i = 0; i < result.length; i++) {\n            result[i] = [keys[i], values[i]];\n        }\n        return result;\n    }\n}\nexports.EntryListUUIDListIntegerCodec = EntryListUUIDListIntegerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListUUIDListIntegerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListUUIDLongCodec.js":
/*!*******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListUUIDLongCodec.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryListUUIDLongCodec = void 0;\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst ENTRY_SIZE_IN_BYTES = BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass EntryListUUIDLongCodec {\n    static encode(clientMessage, entries) {\n        const entryCount = entries.length;\n        const frame = new ClientMessage_1.Frame(Buffer.allocUnsafe(entryCount * ENTRY_SIZE_IN_BYTES));\n        for (let i = 0; i < entryCount; i++) {\n            FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(frame.content, i * ENTRY_SIZE_IN_BYTES, entries[i][0]);\n            FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(frame.content, i * ENTRY_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES, entries[i][1]);\n        }\n        clientMessage.addFrame(frame);\n    }\n    static decode(clientMessage) {\n        const frame = clientMessage.nextFrame();\n        const entryCount = frame.content.length / ENTRY_SIZE_IN_BYTES;\n        const result = new Array(entryCount);\n        for (let i = 0; i < entryCount; i++) {\n            const key = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(frame.content, i * ENTRY_SIZE_IN_BYTES);\n            const value = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(frame.content, i * ENTRY_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES);\n            result[i] = [key, value];\n        }\n        return result;\n    }\n}\nexports.EntryListUUIDLongCodec = EntryListUUIDLongCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListUUIDLongCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/ErrorsCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/ErrorsCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ErrorsCodec = exports.EXCEPTION_MESSAGE_TYPE = void 0;\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst ErrorHolderCodec_1 = __webpack_require__(/*! ../custom/ErrorHolderCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/ErrorHolderCodec.js\");\nexports.EXCEPTION_MESSAGE_TYPE = 0;\n/** @internal */\nclass ErrorsCodec {\n    static decode(clientMessage) {\n        // initial frame\n        clientMessage.nextFrame();\n        return ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, ErrorHolderCodec_1.ErrorHolderCodec.decode);\n    }\n}\nexports.ErrorsCodec = ErrorsCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/ErrorsCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js":
/*!***************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FixSizedTypesCodec = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst UUID_1 = __webpack_require__(/*! ../../core/UUID */ \"../shared/node_modules/hazelcast-client/lib/core/UUID.js\");\n/** @internal */\nclass FixSizedTypesCodec {\n    static encodeInt(buffer, offset, value) {\n        buffer.writeInt32LE(value, offset);\n    }\n    static decodeInt(buffer, offset) {\n        return buffer.readInt32LE(offset);\n    }\n    static encodeLong(buffer, offset, value) {\n        if (!Long.isLong(value)) {\n            value = Long.fromValue(value);\n        }\n        buffer.writeInt32LE(value.low, offset);\n        buffer.writeInt32LE(value.high, offset + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n    }\n    static decodeLong(buffer, offset) {\n        const low = buffer.readInt32LE(offset);\n        const high = buffer.readInt32LE(offset + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n        return new Long(low, high);\n    }\n    static encodeBoolean(buffer, offset, value) {\n        buffer.writeUInt8(value ? 1 : 0, offset);\n    }\n    static decodeBoolean(buffer, offset) {\n        return buffer.readUInt8(offset) === 1;\n    }\n    static encodeByte(buffer, offset, value) {\n        buffer.writeUInt8(value, offset);\n    }\n    static decodeByte(buffer, offset) {\n        return buffer.readUInt8(offset);\n    }\n    static encodeUUID(buffer, offset, value) {\n        const isNull = value === null;\n        this.encodeBoolean(buffer, offset, isNull);\n        if (isNull) {\n            return;\n        }\n        const mostSignificantBits = value.mostSignificant;\n        const leastSignificantBits = value.leastSignificant;\n        this.encodeLong(buffer, offset + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES, mostSignificantBits);\n        this.encodeLong(buffer, offset + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES, leastSignificantBits);\n    }\n    static decodeUUID(buffer, offset) {\n        const isNull = this.decodeBoolean(buffer, offset);\n        if (isNull) {\n            return null;\n        }\n        const mostSignificantBits = this.decodeLong(buffer, offset + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES);\n        const leastSignificantBits = this.decodeLong(buffer, offset + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES);\n        return new UUID_1.UUID(mostSignificantBits, leastSignificantBits);\n    }\n}\nexports.FixSizedTypesCodec = FixSizedTypesCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/ListDataCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/ListDataCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListDataCodec = void 0;\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ./ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ./DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n/** @internal */\nclass ListDataCodec {\n    static encode(clientMessage, list) {\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, list, DataCodec_1.DataCodec.encode);\n    }\n    static decode(clientMessage) {\n        return ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, DataCodec_1.DataCodec.decode);\n    }\n}\nexports.ListDataCodec = ListDataCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/ListDataCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/ListIntegerCodec.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/ListIntegerCodec.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListIntegerCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\n/** @internal */\nclass ListIntegerCodec {\n    static encode(clientMessage, list) {\n        const itemCount = list.length;\n        const frame = new ClientMessage_1.Frame(Buffer.allocUnsafe(itemCount * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES));\n        for (let i = 0; i < itemCount; i++) {\n            FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(frame.content, i * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, list[i]);\n        }\n        clientMessage.addFrame(frame);\n    }\n    static decode(clientMessage) {\n        const frame = clientMessage.nextFrame();\n        const itemCount = frame.content.length / BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n        const result = new Array(itemCount);\n        for (let i = 0; i < itemCount; i++) {\n            result[i] = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(frame.content, i * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n        }\n        return result;\n    }\n}\nexports.ListIntegerCodec = ListIntegerCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/ListIntegerCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/ListLongCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/ListLongCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListLongCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\n/** @internal */\nclass ListLongCodec {\n    static encode(clientMessage, list) {\n        const itemCount = list.length;\n        const frame = new ClientMessage_1.Frame(Buffer.allocUnsafe(itemCount * BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES));\n        for (let i = 0; i < itemCount; i++) {\n            FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(frame.content, i * BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES, list[i]);\n        }\n        clientMessage.addFrame(frame);\n    }\n    static decode(clientMessage) {\n        const frame = clientMessage.nextFrame();\n        const itemCount = frame.content.length / BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n        const result = new Array(itemCount);\n        for (let i = 0; i < itemCount; i++) {\n            result[i] = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(frame.content, i * BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES);\n        }\n        return result;\n    }\n}\nexports.ListLongCodec = ListLongCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/ListLongCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListMultiFrameCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n/** @internal */\nclass ListMultiFrameCodec {\n    static encode(clientMessage, list, encoder) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        for (let i = 0, n = list.length; i < n; i++) {\n            encoder(clientMessage, list[i]);\n        }\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static encodeContainsNullable(clientMessage, list, encoder) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        for (let i = 0, n = list.length; i < n; i++) {\n            const item = list[i];\n            if (item === null) {\n                clientMessage.addFrame(ClientMessage_1.NULL_FRAME.copy());\n            }\n            else {\n                encoder(clientMessage, list[i]);\n            }\n        }\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static encodeNullable(clientMessage, list, encoder) {\n        if (list === null) {\n            clientMessage.addFrame(ClientMessage_1.NULL_FRAME.copy());\n        }\n        else {\n            this.encode(clientMessage, list, encoder);\n        }\n    }\n    static decode(clientMessage, decoder) {\n        const result = [];\n        // begin frame\n        clientMessage.nextFrame();\n        while (!CodecUtil_1.CodecUtil.nextFrameIsDataStructureEndFrame(clientMessage)) {\n            result.push(decoder(clientMessage));\n        }\n        // end frame\n        clientMessage.nextFrame();\n        return result;\n    }\n}\nexports.ListMultiFrameCodec = ListMultiFrameCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/ListUUIDCodec.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/ListUUIDCodec.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListUUIDCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ./FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\n/** @internal */\nclass ListUUIDCodec {\n    static encode(clientMessage, list) {\n        const itemCount = list.length;\n        const frame = new ClientMessage_1.Frame(Buffer.allocUnsafe(itemCount * BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES));\n        for (let i = 0; i < itemCount; i++) {\n            FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(frame.content, i * BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES, list[i]);\n        }\n        clientMessage.addFrame(frame);\n    }\n    static decode(clientMessage) {\n        const frame = clientMessage.nextFrame();\n        const itemCount = frame.content.length / BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\n        const result = new Array(itemCount);\n        for (let i = 0; i < itemCount; i++) {\n            result[i] = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(frame.content, i * BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES);\n        }\n        return result;\n    }\n}\nexports.ListUUIDCodec = ListUUIDCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/ListUUIDCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/LongArrayCodec.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/LongArrayCodec.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LongArrayCodec = void 0;\nconst ListLongCodec_1 = __webpack_require__(/*! ./ListLongCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListLongCodec.js\");\n/** @internal */\nclass LongArrayCodec {\n    static encode(clientMessage, array) {\n        ListLongCodec_1.ListLongCodec.encode(clientMessage, array);\n    }\n    static decode(clientMessage) {\n        return ListLongCodec_1.ListLongCodec.decode(clientMessage);\n    }\n}\nexports.LongArrayCodec = LongArrayCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/LongArrayCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/MapCodec.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/MapCodec.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ./CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\n/** @internal */\nclass MapCodec {\n    static encode(clientMessage, map, keyEncoder, valueEncoder) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        map.forEach((value, key) => {\n            keyEncoder(clientMessage, key);\n            valueEncoder(clientMessage, value);\n        });\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static encodeNullable(clientMessage, map, keyEncoder, valueEncoder) {\n        if (map === null) {\n            clientMessage.addFrame(ClientMessage_1.NULL_FRAME.copy());\n        }\n        else {\n            this.encode(clientMessage, map, keyEncoder, valueEncoder);\n        }\n    }\n    static decode(clientMessage, keyDecoder, valueDecoder) {\n        const result = new Map();\n        // begin frame\n        clientMessage.nextFrame();\n        while (!CodecUtil_1.CodecUtil.nextFrameIsDataStructureEndFrame(clientMessage)) {\n            const key = keyDecoder(clientMessage);\n            const value = valueDecoder(clientMessage);\n            result.set(key, value);\n        }\n        // end frame\n        clientMessage.nextFrame();\n        return result;\n    }\n    static decodeNullable(clientMessage, keyDecoder, valueDecoder) {\n        return CodecUtil_1.CodecUtil.nextFrameIsNullFrame(clientMessage) ? null : this.decode(clientMessage, keyDecoder, valueDecoder);\n    }\n}\nexports.MapCodec = MapCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/MapCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StringCodec = void 0;\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\n/** @internal */\nclass StringCodec {\n    static encode(clientMessage, value) {\n        clientMessage.addFrame(new ClientMessage_1.Frame(Buffer.from(value, 'utf8')));\n    }\n    static decode(clientMessage) {\n        const frame = clientMessage.nextFrame();\n        return frame.content.toString('utf8');\n    }\n}\nexports.StringCodec = StringCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/AddressCodec.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/AddressCodec.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AddressCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst Address_1 = __webpack_require__(/*! ../../core/Address */ \"../shared/node_modules/hazelcast-client/lib/core/Address.js\");\nconst StringCodec_1 = __webpack_require__(/*! ../builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst PORT_OFFSET = 0;\nconst INITIAL_FRAME_SIZE = PORT_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass AddressCodec {\n    static encode(clientMessage, address) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, PORT_OFFSET, address.port);\n        clientMessage.addFrame(initialFrame);\n        StringCodec_1.StringCodec.encode(clientMessage, address.host);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const port = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, PORT_OFFSET);\n        const host = StringCodec_1.StringCodec.decode(clientMessage);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new Address_1.AddressImpl(host, port);\n    }\n}\nexports.AddressCodec = AddressCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/AddressCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/AnchorDataListHolderCodec.js":
/*!*********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/AnchorDataListHolderCodec.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AnchorDataListHolderCodec = void 0;\n/* eslint-disable max-len */\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst ListIntegerCodec_1 = __webpack_require__(/*! ../builtin/ListIntegerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListIntegerCodec.js\");\nconst AnchorDataListHolder_1 = __webpack_require__(/*! ../../protocol/AnchorDataListHolder */ \"../shared/node_modules/hazelcast-client/lib/protocol/AnchorDataListHolder.js\");\nconst EntryListCodec_1 = __webpack_require__(/*! ../builtin/EntryListCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/EntryListCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ../builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\n/** @internal */\nclass AnchorDataListHolderCodec {\n    static encode(clientMessage, anchorDataListHolder) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        ListIntegerCodec_1.ListIntegerCodec.encode(clientMessage, anchorDataListHolder.anchorPageList);\n        EntryListCodec_1.EntryListCodec.encode(clientMessage, anchorDataListHolder.anchorDataList, DataCodec_1.DataCodec.encode, DataCodec_1.DataCodec.encode);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const anchorPageList = ListIntegerCodec_1.ListIntegerCodec.decode(clientMessage);\n        const anchorDataList = EntryListCodec_1.EntryListCodec.decode(clientMessage, DataCodec_1.DataCodec.decode, DataCodec_1.DataCodec.decode);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new AnchorDataListHolder_1.AnchorDataListHolder(anchorPageList, anchorDataList);\n    }\n}\nexports.AnchorDataListHolderCodec = AnchorDataListHolderCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/AnchorDataListHolderCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/BitmapIndexOptionsCodec.js":
/*!*******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/BitmapIndexOptionsCodec.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitmapIndexOptionsCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst BitmapIndexOptions_1 = __webpack_require__(/*! ../../config/BitmapIndexOptions */ \"../shared/node_modules/hazelcast-client/lib/config/BitmapIndexOptions.js\");\nconst StringCodec_1 = __webpack_require__(/*! ../builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst UNIQUE_KEY_TRANSFORMATION_OFFSET = 0;\nconst INITIAL_FRAME_SIZE = UNIQUE_KEY_TRANSFORMATION_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass BitmapIndexOptionsCodec {\n    static encode(clientMessage, bitmapIndexOptions) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, UNIQUE_KEY_TRANSFORMATION_OFFSET, bitmapIndexOptions.uniqueKeyTransformation);\n        clientMessage.addFrame(initialFrame);\n        StringCodec_1.StringCodec.encode(clientMessage, bitmapIndexOptions.uniqueKey);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const uniqueKeyTransformation = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, UNIQUE_KEY_TRANSFORMATION_OFFSET);\n        const uniqueKey = StringCodec_1.StringCodec.decode(clientMessage);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new BitmapIndexOptions_1.InternalBitmapIndexOptions(uniqueKey, uniqueKeyTransformation);\n    }\n}\nexports.BitmapIndexOptionsCodec = BitmapIndexOptionsCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/BitmapIndexOptionsCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/DistributedObjectInfoCodec.js":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/DistributedObjectInfoCodec.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DistributedObjectInfoCodec = void 0;\n/* eslint-disable max-len */\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst StringCodec_1 = __webpack_require__(/*! ../builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst DistributedObjectInfo_1 = __webpack_require__(/*! ../../core/DistributedObjectInfo */ \"../shared/node_modules/hazelcast-client/lib/core/DistributedObjectInfo.js\");\n/** @internal */\nclass DistributedObjectInfoCodec {\n    static encode(clientMessage, distributedObjectInfo) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        StringCodec_1.StringCodec.encode(clientMessage, distributedObjectInfo.serviceName);\n        StringCodec_1.StringCodec.encode(clientMessage, distributedObjectInfo.name);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const serviceName = StringCodec_1.StringCodec.decode(clientMessage);\n        const name = StringCodec_1.StringCodec.decode(clientMessage);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new DistributedObjectInfo_1.DistributedObjectInfo(serviceName, name);\n    }\n}\nexports.DistributedObjectInfoCodec = DistributedObjectInfoCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/DistributedObjectInfoCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/ErrorHolderCodec.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/ErrorHolderCodec.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ErrorHolderCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst ErrorHolder_1 = __webpack_require__(/*! ../../protocol/ErrorHolder */ \"../shared/node_modules/hazelcast-client/lib/protocol/ErrorHolder.js\");\nconst StringCodec_1 = __webpack_require__(/*! ../builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ../builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst StackTraceElementCodec_1 = __webpack_require__(/*! ./StackTraceElementCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/StackTraceElementCodec.js\");\nconst ERROR_CODE_OFFSET = 0;\nconst INITIAL_FRAME_SIZE = ERROR_CODE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass ErrorHolderCodec {\n    static encode(clientMessage, errorHolder) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, ERROR_CODE_OFFSET, errorHolder.errorCode);\n        clientMessage.addFrame(initialFrame);\n        StringCodec_1.StringCodec.encode(clientMessage, errorHolder.className);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, errorHolder.message, StringCodec_1.StringCodec.encode);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, errorHolder.stackTraceElements, StackTraceElementCodec_1.StackTraceElementCodec.encode);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const errorCode = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, ERROR_CODE_OFFSET);\n        const className = StringCodec_1.StringCodec.decode(clientMessage);\n        const message = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, StringCodec_1.StringCodec.decode);\n        const stackTraceElements = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, StackTraceElementCodec_1.StackTraceElementCodec.decode);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new ErrorHolder_1.ErrorHolder(errorCode, className, message, stackTraceElements);\n    }\n}\nexports.ErrorHolderCodec = ErrorHolderCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/ErrorHolderCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/IndexConfigCodec.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/IndexConfigCodec.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IndexConfigCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst IndexConfig_1 = __webpack_require__(/*! ../../config/IndexConfig */ \"../shared/node_modules/hazelcast-client/lib/config/IndexConfig.js\");\nconst StringCodec_1 = __webpack_require__(/*! ../builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst ListMultiFrameCodec_1 = __webpack_require__(/*! ../builtin/ListMultiFrameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ListMultiFrameCodec.js\");\nconst BitmapIndexOptionsCodec_1 = __webpack_require__(/*! ./BitmapIndexOptionsCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/BitmapIndexOptionsCodec.js\");\nconst TYPE_OFFSET = 0;\nconst INITIAL_FRAME_SIZE = TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass IndexConfigCodec {\n    static encode(clientMessage, indexConfig) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, TYPE_OFFSET, indexConfig.type);\n        clientMessage.addFrame(initialFrame);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, indexConfig.name, StringCodec_1.StringCodec.encode);\n        ListMultiFrameCodec_1.ListMultiFrameCodec.encode(clientMessage, indexConfig.attributes, StringCodec_1.StringCodec.encode);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, indexConfig.bitmapIndexOptions, BitmapIndexOptionsCodec_1.BitmapIndexOptionsCodec.encode);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const type = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, TYPE_OFFSET);\n        const name = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, StringCodec_1.StringCodec.decode);\n        const attributes = ListMultiFrameCodec_1.ListMultiFrameCodec.decode(clientMessage, StringCodec_1.StringCodec.decode);\n        const bitmapIndexOptions = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, BitmapIndexOptionsCodec_1.BitmapIndexOptionsCodec.decode);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new IndexConfig_1.InternalIndexConfig(name, type, attributes, bitmapIndexOptions);\n    }\n}\nexports.IndexConfigCodec = IndexConfigCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/IndexConfigCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/MemberInfoCodec.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/MemberInfoCodec.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemberInfoCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst MemberInfo_1 = __webpack_require__(/*! ../../core/MemberInfo */ \"../shared/node_modules/hazelcast-client/lib/core/MemberInfo.js\");\nconst AddressCodec_1 = __webpack_require__(/*! ./AddressCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/AddressCodec.js\");\nconst MapCodec_1 = __webpack_require__(/*! ../builtin/MapCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/MapCodec.js\");\nconst StringCodec_1 = __webpack_require__(/*! ../builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst MemberVersionCodec_1 = __webpack_require__(/*! ./MemberVersionCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/MemberVersionCodec.js\");\nconst UUID_OFFSET = 0;\nconst LITE_MEMBER_OFFSET = UUID_OFFSET + BitsUtil_1.BitsUtil.UUID_SIZE_IN_BYTES;\nconst INITIAL_FRAME_SIZE = LITE_MEMBER_OFFSET + BitsUtil_1.BitsUtil.BOOLEAN_SIZE_IN_BYTES;\n/** @internal */\nclass MemberInfoCodec {\n    static encode(clientMessage, memberInfo) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeUUID(initialFrame.content, UUID_OFFSET, memberInfo.uuid);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeBoolean(initialFrame.content, LITE_MEMBER_OFFSET, memberInfo.liteMember);\n        clientMessage.addFrame(initialFrame);\n        AddressCodec_1.AddressCodec.encode(clientMessage, memberInfo.address);\n        MapCodec_1.MapCodec.encode(clientMessage, memberInfo.attributes, StringCodec_1.StringCodec.encode, StringCodec_1.StringCodec.encode);\n        MemberVersionCodec_1.MemberVersionCodec.encode(clientMessage, memberInfo.version);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const uuid = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeUUID(initialFrame.content, UUID_OFFSET);\n        const liteMember = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeBoolean(initialFrame.content, LITE_MEMBER_OFFSET);\n        const address = AddressCodec_1.AddressCodec.decode(clientMessage);\n        const attributes = MapCodec_1.MapCodec.decode(clientMessage, StringCodec_1.StringCodec.decode, StringCodec_1.StringCodec.decode);\n        const version = MemberVersionCodec_1.MemberVersionCodec.decode(clientMessage);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new MemberInfo_1.MemberInfo(address, uuid, attributes, liteMember, version);\n    }\n}\nexports.MemberInfoCodec = MemberInfoCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/MemberInfoCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/MemberVersionCodec.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/MemberVersionCodec.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemberVersionCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst MemberVersion_1 = __webpack_require__(/*! ../../core/MemberVersion */ \"../shared/node_modules/hazelcast-client/lib/core/MemberVersion.js\");\nconst MAJOR_OFFSET = 0;\nconst MINOR_OFFSET = MAJOR_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst PATCH_OFFSET = MINOR_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\nconst INITIAL_FRAME_SIZE = PATCH_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass MemberVersionCodec {\n    static encode(clientMessage, memberVersion) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeByte(initialFrame.content, MAJOR_OFFSET, memberVersion.major);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeByte(initialFrame.content, MINOR_OFFSET, memberVersion.minor);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeByte(initialFrame.content, PATCH_OFFSET, memberVersion.patch);\n        clientMessage.addFrame(initialFrame);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const major = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeByte(initialFrame.content, MAJOR_OFFSET);\n        const minor = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeByte(initialFrame.content, MINOR_OFFSET);\n        const patch = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeByte(initialFrame.content, PATCH_OFFSET);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new MemberVersion_1.MemberVersion(major, minor, patch);\n    }\n}\nexports.MemberVersionCodec = MemberVersionCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/MemberVersionCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/PagingPredicateHolderCodec.js":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/PagingPredicateHolderCodec.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PagingPredicateHolderCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst PagingPredicateHolder_1 = __webpack_require__(/*! ../../protocol/PagingPredicateHolder */ \"../shared/node_modules/hazelcast-client/lib/protocol/PagingPredicateHolder.js\");\nconst AnchorDataListHolderCodec_1 = __webpack_require__(/*! ./AnchorDataListHolderCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/custom/AnchorDataListHolderCodec.js\");\nconst DataCodec_1 = __webpack_require__(/*! ../builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst PAGE_SIZE_OFFSET = 0;\nconst PAGE_OFFSET = PAGE_SIZE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst ITERATION_TYPE_ID_OFFSET = PAGE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\nconst INITIAL_FRAME_SIZE = ITERATION_TYPE_ID_OFFSET + BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n/** @internal */\nclass PagingPredicateHolderCodec {\n    static encode(clientMessage, pagingPredicateHolder) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, PAGE_SIZE_OFFSET, pagingPredicateHolder.pageSize);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, PAGE_OFFSET, pagingPredicateHolder.page);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeByte(initialFrame.content, ITERATION_TYPE_ID_OFFSET, pagingPredicateHolder.iterationTypeId);\n        clientMessage.addFrame(initialFrame);\n        AnchorDataListHolderCodec_1.AnchorDataListHolderCodec.encode(clientMessage, pagingPredicateHolder.anchorDataListHolder);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, pagingPredicateHolder.predicateData, DataCodec_1.DataCodec.encode);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, pagingPredicateHolder.comparatorData, DataCodec_1.DataCodec.encode);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, pagingPredicateHolder.partitionKeyData, DataCodec_1.DataCodec.encode);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const pageSize = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, PAGE_SIZE_OFFSET);\n        const page = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, PAGE_OFFSET);\n        const iterationTypeId = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeByte(initialFrame.content, ITERATION_TYPE_ID_OFFSET);\n        const anchorDataListHolder = AnchorDataListHolderCodec_1.AnchorDataListHolderCodec.decode(clientMessage);\n        const predicateData = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        const comparatorData = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        const partitionKeyData = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, DataCodec_1.DataCodec.decode);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new PagingPredicateHolder_1.PagingPredicateHolder(anchorDataListHolder, predicateData, comparatorData, pageSize, page, iterationTypeId, partitionKeyData);\n    }\n}\nexports.PagingPredicateHolderCodec = PagingPredicateHolderCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/PagingPredicateHolderCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RaftGroupIdCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst RaftGroupId_1 = __webpack_require__(/*! ../../proxy/cpsubsystem/RaftGroupId */ \"../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/RaftGroupId.js\");\nconst StringCodec_1 = __webpack_require__(/*! ../builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst SEED_OFFSET = 0;\nconst ID_OFFSET = SEED_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst INITIAL_FRAME_SIZE = ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass RaftGroupIdCodec {\n    static encode(clientMessage, raftGroupId) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, SEED_OFFSET, raftGroupId.seed);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, ID_OFFSET, raftGroupId.id);\n        clientMessage.addFrame(initialFrame);\n        StringCodec_1.StringCodec.encode(clientMessage, raftGroupId.name);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const seed = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, SEED_OFFSET);\n        const id = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, ID_OFFSET);\n        const name = StringCodec_1.StringCodec.decode(clientMessage);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new RaftGroupId_1.RaftGroupId(name, seed, id);\n    }\n}\nexports.RaftGroupIdCodec = RaftGroupIdCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/RaftGroupIdCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/SimpleEntryViewCodec.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/SimpleEntryViewCodec.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleEntryViewCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst SimpleEntryView_1 = __webpack_require__(/*! ../../core/SimpleEntryView */ \"../shared/node_modules/hazelcast-client/lib/core/SimpleEntryView.js\");\nconst DataCodec_1 = __webpack_require__(/*! ../builtin/DataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/DataCodec.js\");\nconst COST_OFFSET = 0;\nconst CREATION_TIME_OFFSET = COST_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst EXPIRATION_TIME_OFFSET = CREATION_TIME_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst HITS_OFFSET = EXPIRATION_TIME_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst LAST_ACCESS_TIME_OFFSET = HITS_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst LAST_STORED_TIME_OFFSET = LAST_ACCESS_TIME_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst LAST_UPDATE_TIME_OFFSET = LAST_STORED_TIME_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst VERSION_OFFSET = LAST_UPDATE_TIME_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst TTL_OFFSET = VERSION_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst MAX_IDLE_OFFSET = TTL_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst INITIAL_FRAME_SIZE = MAX_IDLE_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nclass SimpleEntryViewCodec {\n    static encode(clientMessage, simpleEntryView) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, COST_OFFSET, simpleEntryView.cost);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, CREATION_TIME_OFFSET, simpleEntryView.creationTime);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, EXPIRATION_TIME_OFFSET, simpleEntryView.expirationTime);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, HITS_OFFSET, simpleEntryView.hits);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, LAST_ACCESS_TIME_OFFSET, simpleEntryView.lastAccessTime);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, LAST_STORED_TIME_OFFSET, simpleEntryView.lastStoredTime);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, LAST_UPDATE_TIME_OFFSET, simpleEntryView.lastUpdateTime);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, VERSION_OFFSET, simpleEntryView.version);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, TTL_OFFSET, simpleEntryView.ttl);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(initialFrame.content, MAX_IDLE_OFFSET, simpleEntryView.maxIdle);\n        clientMessage.addFrame(initialFrame);\n        DataCodec_1.DataCodec.encode(clientMessage, simpleEntryView.key);\n        DataCodec_1.DataCodec.encode(clientMessage, simpleEntryView.value);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const cost = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, COST_OFFSET);\n        const creationTime = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, CREATION_TIME_OFFSET);\n        const expirationTime = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, EXPIRATION_TIME_OFFSET);\n        const hits = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, HITS_OFFSET);\n        const lastAccessTime = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, LAST_ACCESS_TIME_OFFSET);\n        const lastStoredTime = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, LAST_STORED_TIME_OFFSET);\n        const lastUpdateTime = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, LAST_UPDATE_TIME_OFFSET);\n        const version = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, VERSION_OFFSET);\n        const ttl = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, TTL_OFFSET);\n        const maxIdle = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(initialFrame.content, MAX_IDLE_OFFSET);\n        const key = DataCodec_1.DataCodec.decode(clientMessage);\n        const value = DataCodec_1.DataCodec.decode(clientMessage);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new SimpleEntryView_1.SimpleEntryView(key, value, cost, creationTime, expirationTime, hits, lastAccessTime, lastStoredTime, lastUpdateTime, version, ttl, maxIdle);\n    }\n}\nexports.SimpleEntryViewCodec = SimpleEntryViewCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/SimpleEntryViewCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/codec/custom/StackTraceElementCodec.js":
/*!******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/codec/custom/StackTraceElementCodec.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StackTraceElementCodec = void 0;\n/* eslint-disable max-len */\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst CodecUtil_1 = __webpack_require__(/*! ../builtin/CodecUtil */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/CodecUtil.js\");\nconst StackTraceElement_1 = __webpack_require__(/*! ../../protocol/StackTraceElement */ \"../shared/node_modules/hazelcast-client/lib/protocol/StackTraceElement.js\");\nconst StringCodec_1 = __webpack_require__(/*! ../builtin/StringCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/StringCodec.js\");\nconst LINE_NUMBER_OFFSET = 0;\nconst INITIAL_FRAME_SIZE = LINE_NUMBER_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nclass StackTraceElementCodec {\n    static encode(clientMessage, stackTraceElement) {\n        clientMessage.addFrame(ClientMessage_1.BEGIN_FRAME.copy());\n        const initialFrame = ClientMessage_1.Frame.createInitialFrame(INITIAL_FRAME_SIZE, ClientMessage_1.DEFAULT_FLAGS);\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeInt(initialFrame.content, LINE_NUMBER_OFFSET, stackTraceElement.lineNumber);\n        clientMessage.addFrame(initialFrame);\n        StringCodec_1.StringCodec.encode(clientMessage, stackTraceElement.className);\n        StringCodec_1.StringCodec.encode(clientMessage, stackTraceElement.methodName);\n        CodecUtil_1.CodecUtil.encodeNullable(clientMessage, stackTraceElement.fileName, StringCodec_1.StringCodec.encode);\n        clientMessage.addFrame(ClientMessage_1.END_FRAME.copy());\n    }\n    static decode(clientMessage) {\n        // begin frame\n        clientMessage.nextFrame();\n        const initialFrame = clientMessage.nextFrame();\n        const lineNumber = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(initialFrame.content, LINE_NUMBER_OFFSET);\n        const className = StringCodec_1.StringCodec.decode(clientMessage);\n        const methodName = StringCodec_1.StringCodec.decode(clientMessage);\n        const fileName = CodecUtil_1.CodecUtil.decodeNullable(clientMessage, StringCodec_1.StringCodec.decode);\n        CodecUtil_1.CodecUtil.fastForwardToEndFrame(clientMessage);\n        return new StackTraceElement_1.StackTraceElement(className, methodName, fileName, lineNumber);\n    }\n}\nexports.StackTraceElementCodec = StackTraceElementCodec;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/codec/custom/StackTraceElementCodec.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/BitmapIndexOptions.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/BitmapIndexOptions.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InternalBitmapIndexOptions = exports.UniqueKeyTransformation = void 0;\nconst Predicate_1 = __webpack_require__(/*! ../core/Predicate */ \"../shared/node_modules/hazelcast-client/lib/core/Predicate.js\");\n/**\n * Defines an assortment of transformations which can be applied to\n * {@link BitmapIndexOptions.uniqueKey unique key} values.\n */\nvar UniqueKeyTransformation;\n(function (UniqueKeyTransformation) {\n    /**\n     * Extracted unique key value is interpreted as an object value.\n     * Non-negative unique ID is assigned to every distinct object value.\n     */\n    UniqueKeyTransformation[UniqueKeyTransformation[\"OBJECT\"] = 0] = \"OBJECT\";\n    /**\n     * Extracted unique key value is interpreted as a whole integer value of\n     * byte, short, int or long type. The extracted value is upcasted to\n     * long (if necessary) and unique non-negative ID is assigned to every\n     * distinct value.\n     */\n    UniqueKeyTransformation[UniqueKeyTransformation[\"LONG\"] = 1] = \"LONG\";\n    /**\n     * Extracted unique key value is interpreted as a whole integer value of\n     * byte, short, int or long type. The extracted value is upcasted to\n     * long (if necessary) and the resulting value is used directly as an ID.\n     */\n    UniqueKeyTransformation[UniqueKeyTransformation[\"RAW\"] = 2] = \"RAW\";\n})(UniqueKeyTransformation = exports.UniqueKeyTransformation || (exports.UniqueKeyTransformation = {}));\nconst DEFAULT_UNIQUE_KEY = Predicate_1.QueryConstants.KEY_ATTRIBUTE_NAME;\nconst DEFAULT_UNIQUE_KEY_TRANSFORMATION = UniqueKeyTransformation.OBJECT;\n/**\n * Follows the shape of {@link BitmapIndexOptions}, but doesn't implement it due\n * to the `uniqueKeyTransformation` enum field.\n * @internal\n */\nclass InternalBitmapIndexOptions {\n    constructor(uniqueKey = DEFAULT_UNIQUE_KEY, uniqueKeyTransformation = DEFAULT_UNIQUE_KEY_TRANSFORMATION) {\n        this.uniqueKey = uniqueKey;\n        this.uniqueKeyTransformation = uniqueKeyTransformation;\n    }\n    toString() {\n        return 'BitmapIndexOptions[' +\n            'uniqueKey: ' + this.uniqueKey +\n            ', uniqueKeyTransformation: ' + this.uniqueKeyTransformation +\n            ']';\n    }\n}\nexports.InternalBitmapIndexOptions = InternalBitmapIndexOptions;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/BitmapIndexOptions.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/ClientCloudConfig.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/ClientCloudConfig.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientCloudConfigImpl = void 0;\n/** @internal */\nclass ClientCloudConfigImpl {\n    constructor() {\n        this.discoveryToken = null;\n    }\n}\nexports.ClientCloudConfigImpl = ClientCloudConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/ClientCloudConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/ClientNetworkConfig.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/ClientNetworkConfig.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientNetworkConfigImpl = void 0;\nconst ClientCloudConfig_1 = __webpack_require__(/*! ./ClientCloudConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ClientCloudConfig.js\");\nconst SSLConfig_1 = __webpack_require__(/*! ./SSLConfig */ \"../shared/node_modules/hazelcast-client/lib/config/SSLConfig.js\");\n/** @internal */\nclass ClientNetworkConfigImpl {\n    constructor() {\n        this.clusterMembers = [];\n        this.hazelcastCloud = new ClientCloudConfig_1.ClientCloudConfigImpl();\n        this.connectionTimeout = 5000;\n        this.redoOperation = false;\n        this.smartRouting = true;\n        this.ssl = new SSLConfig_1.SSLConfigImpl();\n    }\n}\nexports.ClientNetworkConfigImpl = ClientNetworkConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/ClientNetworkConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/Config.js":
/*!********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/Config.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientConfigImpl = void 0;\nconst ClientNetworkConfig_1 = __webpack_require__(/*! ./ClientNetworkConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ClientNetworkConfig.js\");\nconst ConfigPatternMatcher_1 = __webpack_require__(/*! ./ConfigPatternMatcher */ \"../shared/node_modules/hazelcast-client/lib/config/ConfigPatternMatcher.js\");\nconst FlakeIdGeneratorConfig_1 = __webpack_require__(/*! ./FlakeIdGeneratorConfig */ \"../shared/node_modules/hazelcast-client/lib/config/FlakeIdGeneratorConfig.js\");\nconst ReliableTopicConfig_1 = __webpack_require__(/*! ./ReliableTopicConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ReliableTopicConfig.js\");\nconst SerializationConfig_1 = __webpack_require__(/*! ./SerializationConfig */ \"../shared/node_modules/hazelcast-client/lib/config/SerializationConfig.js\");\nconst Statistics_1 = __webpack_require__(/*! ../statistics/Statistics */ \"../shared/node_modules/hazelcast-client/lib/statistics/Statistics.js\");\nconst ConnectionStrategyConfig_1 = __webpack_require__(/*! ./ConnectionStrategyConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ConnectionStrategyConfig.js\");\nconst LoadBalancerConfig_1 = __webpack_require__(/*! ./LoadBalancerConfig */ \"../shared/node_modules/hazelcast-client/lib/config/LoadBalancerConfig.js\");\n/** @internal */\nclass ClientConfigImpl {\n    constructor() {\n        this.properties = {\n            'hazelcast.client.heartbeat.interval': 5000,\n            'hazelcast.client.heartbeat.timeout': 60000,\n            'hazelcast.client.invocation.retry.pause.millis': 1000,\n            'hazelcast.client.invocation.timeout.millis': 120000,\n            'hazelcast.client.internal.clean.resources.millis': 100,\n            'hazelcast.client.cloud.url': 'https://coordinator.hazelcast.cloud',\n            'hazelcast.client.statistics.enabled': false,\n            'hazelcast.client.statistics.period.seconds': Statistics_1.Statistics.PERIOD_SECONDS_DEFAULT_VALUE,\n            'hazelcast.invalidation.reconciliation.interval.seconds': 60,\n            'hazelcast.invalidation.max.tolerated.miss.count': 10,\n            'hazelcast.invalidation.min.reconciliation.interval.seconds': 30,\n            'hazelcast.logging.level': 'INFO',\n            'hazelcast.client.autopipelining.enabled': true,\n            'hazelcast.client.autopipelining.threshold.bytes': 8192,\n            'hazelcast.client.socket.no.delay': true,\n            'hazelcast.client.shuffle.member.list': true,\n            'hazelcast.client.operation.backup.timeout.millis': 5000,\n            'hazelcast.client.operation.fail.on.indeterminate.state': false,\n        };\n        this.network = new ClientNetworkConfig_1.ClientNetworkConfigImpl();\n        this.customLogger = null;\n        this.customCredentials = null;\n        this.lifecycleListeners = [];\n        this.membershipListeners = [];\n        this.serialization = new SerializationConfig_1.SerializationConfigImpl();\n        this.reliableTopics = {};\n        this.nearCaches = {};\n        this.flakeIdGenerators = {};\n        this.connectionStrategy = new ConnectionStrategyConfig_1.ConnectionStrategyConfigImpl();\n        this.clusterName = 'dev';\n        this.clientLabels = [];\n        this.loadBalancer = new LoadBalancerConfig_1.LoadBalancerConfigImpl();\n        this.backupAckToClientEnabled = true;\n        this.configPatternMatcher = new ConfigPatternMatcher_1.ConfigPatternMatcher();\n    }\n    getInstanceName() {\n        return this.instanceName;\n    }\n    getReliableTopicConfig(name) {\n        const matching = this.lookupByPattern(this.reliableTopics, name);\n        let config;\n        if (matching != null) {\n            config = matching.clone();\n        }\n        else {\n            config = new ReliableTopicConfig_1.ReliableTopicConfigImpl();\n        }\n        config.name = name;\n        return config;\n    }\n    getNearCacheConfig(name) {\n        const matching = this.lookupByPattern(this.nearCaches, name);\n        if (matching == null) {\n            return null;\n        }\n        const config = matching.clone();\n        config.name = name;\n        return config;\n    }\n    getFlakeIdGeneratorConfig(name) {\n        const matching = this.lookupByPattern(this.flakeIdGenerators, name);\n        let config;\n        if (matching != null) {\n            config = matching.clone();\n        }\n        else {\n            config = new FlakeIdGeneratorConfig_1.FlakeIdGeneratorConfigImpl();\n        }\n        config.name = name;\n        return config;\n    }\n    lookupByPattern(config, name) {\n        if (config[name] != null) {\n            return config[name];\n        }\n        const matchingPattern = this.configPatternMatcher.matches(Object.keys(config), name);\n        if (matchingPattern != null) {\n            return config[matchingPattern];\n        }\n        if (config.default != null) {\n            return config.default;\n        }\n        return null;\n    }\n}\nexports.ClientConfigImpl = ClientConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/Config.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/ConfigBuilder.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/ConfigBuilder.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigBuilder = void 0;\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst proxy_1 = __webpack_require__(/*! ../proxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/index.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst Config_1 = __webpack_require__(/*! ./Config */ \"../shared/node_modules/hazelcast-client/lib/config/Config.js\");\nconst EvictionPolicy_1 = __webpack_require__(/*! ./EvictionPolicy */ \"../shared/node_modules/hazelcast-client/lib/config/EvictionPolicy.js\");\nconst FlakeIdGeneratorConfig_1 = __webpack_require__(/*! ./FlakeIdGeneratorConfig */ \"../shared/node_modules/hazelcast-client/lib/config/FlakeIdGeneratorConfig.js\");\nconst InMemoryFormat_1 = __webpack_require__(/*! ./InMemoryFormat */ \"../shared/node_modules/hazelcast-client/lib/config/InMemoryFormat.js\");\nconst NearCacheConfig_1 = __webpack_require__(/*! ./NearCacheConfig */ \"../shared/node_modules/hazelcast-client/lib/config/NearCacheConfig.js\");\nconst ReliableTopicConfig_1 = __webpack_require__(/*! ./ReliableTopicConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ReliableTopicConfig.js\");\nconst JsonStringDeserializationPolicy_1 = __webpack_require__(/*! ./JsonStringDeserializationPolicy */ \"../shared/node_modules/hazelcast-client/lib/config/JsonStringDeserializationPolicy.js\");\nconst ConnectionStrategyConfig_1 = __webpack_require__(/*! ./ConnectionStrategyConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ConnectionStrategyConfig.js\");\nconst LoadBalancerConfig_1 = __webpack_require__(/*! ./LoadBalancerConfig */ \"../shared/node_modules/hazelcast-client/lib/config/LoadBalancerConfig.js\");\n/**\n * Responsible for user-defined config validation. Builds the effective config with necessary defaults.\n * @internal\n */\nclass ConfigBuilder {\n    constructor(config) {\n        this.effectiveConfig = new Config_1.ClientConfigImpl();\n        this.originalConfig = config || {};\n    }\n    build() {\n        try {\n            this.handleConfig(this.originalConfig);\n            return this.effectiveConfig;\n        }\n        catch (e) {\n            throw new core_1.HazelcastError('Config validation error: ' + e.message, e);\n        }\n    }\n    handleConfig(jsonObject) {\n        for (const key in jsonObject) {\n            const value = jsonObject[key];\n            if (key === 'clusterName') {\n                this.effectiveConfig.clusterName = Util_1.tryGetString(value);\n            }\n            else if (key === 'instanceName') {\n                this.effectiveConfig.instanceName = Util_1.tryGetString(value);\n            }\n            else if (key === 'properties') {\n                this.handleProperties(value);\n            }\n            else if (key === 'clientLabels') {\n                this.handleClientLabels(value);\n            }\n            else if (key === 'network') {\n                this.handleNetwork(value);\n            }\n            else if (key === 'connectionStrategy') {\n                this.handleConnectionStrategy(value);\n            }\n            else if (key === 'lifecycleListeners') {\n                this.handleLifecycleListeners(value);\n            }\n            else if (key === 'membershipListeners') {\n                this.handleMembershipListeners(value);\n            }\n            else if (key === 'serialization') {\n                this.handleSerialization(value);\n            }\n            else if (key === 'nearCaches') {\n                this.handleNearCaches(value);\n            }\n            else if (key === 'reliableTopics') {\n                this.handleReliableTopics(value);\n            }\n            else if (key === 'flakeIdGenerators') {\n                this.handleFlakeIdGenerators(value);\n            }\n            else if (key === 'loadBalancer') {\n                this.handleLoadBalancer(value);\n            }\n            else if (key === 'customLogger') {\n                this.handleLogger(value);\n            }\n            else if (key === 'customCredentials') {\n                this.handleCredentials(value);\n            }\n            else if (key === 'backupAckToClientEnabled') {\n                this.effectiveConfig.backupAckToClientEnabled = Util_1.tryGetBoolean(value);\n            }\n        }\n    }\n    handleConnectionStrategy(jsonObject) {\n        for (const key in jsonObject) {\n            const value = jsonObject[key];\n            if (key === 'asyncStart') {\n                this.effectiveConfig.connectionStrategy.asyncStart = Util_1.tryGetBoolean(value);\n            }\n            else if (key === 'reconnectMode') {\n                this.effectiveConfig.connectionStrategy.reconnectMode = Util_1.tryGetEnum(ConnectionStrategyConfig_1.ReconnectMode, value);\n            }\n            else if (key === 'connectionRetry') {\n                this.handleConnectionRetry(value);\n            }\n        }\n    }\n    handleConnectionRetry(jsonObject) {\n        for (const key in jsonObject) {\n            const value = jsonObject[key];\n            if (key === 'initialBackoffMillis') {\n                this.effectiveConfig.connectionStrategy.connectionRetry.initialBackoffMillis = Util_1.tryGetNumber(value);\n            }\n            else if (key === 'maxBackoffMillis') {\n                this.effectiveConfig.connectionStrategy.connectionRetry.maxBackoffMillis = Util_1.tryGetNumber(value);\n            }\n            else if (key === 'multiplier') {\n                this.effectiveConfig.connectionStrategy.connectionRetry.multiplier = Util_1.tryGetNumber(value);\n            }\n            else if (key === 'clusterConnectTimeoutMillis') {\n                this.effectiveConfig.connectionStrategy.connectionRetry\n                    .clusterConnectTimeoutMillis = Util_1.tryGetNumber(value);\n            }\n            else if (key === 'jitter') {\n                this.effectiveConfig.connectionStrategy.connectionRetry.jitter = Util_1.tryGetNumber(value);\n            }\n        }\n    }\n    handleClientLabels(jsonObject) {\n        const labelsArray = Util_1.tryGetArray(jsonObject);\n        for (const index in labelsArray) {\n            const label = labelsArray[index];\n            this.effectiveConfig.clientLabels.push(label);\n        }\n    }\n    handleNetwork(jsonObject) {\n        for (const key in jsonObject) {\n            if (key === 'clusterMembers') {\n                this.handleClusterMembers(jsonObject[key]);\n            }\n            else if (key === 'smartRouting') {\n                this.effectiveConfig.network.smartRouting = Util_1.tryGetBoolean(jsonObject[key]);\n            }\n            else if (key === 'connectionTimeout') {\n                this.effectiveConfig.network.connectionTimeout = Util_1.tryGetNumber(jsonObject[key]);\n            }\n            else if (key === 'ssl') {\n                this.handleSSL(jsonObject[key]);\n            }\n            else if (key === 'hazelcastCloud') {\n                this.handleHazelcastCloud(jsonObject[key]);\n            }\n        }\n    }\n    handleHazelcastCloud(jsonObject) {\n        for (const key in jsonObject) {\n            if (key === 'discoveryToken') {\n                this.effectiveConfig.network.hazelcastCloud.discoveryToken = Util_1.tryGetString(jsonObject[key]);\n            }\n        }\n    }\n    parseProperties(jsonObject) {\n        const props = {};\n        for (const key in jsonObject) {\n            props[key] = jsonObject[key];\n        }\n        return props;\n    }\n    handleSSL(jsonObject) {\n        const sslEnabled = Util_1.tryGetBoolean(jsonObject.enabled);\n        this.effectiveConfig.network.ssl.enabled = sslEnabled;\n        if (jsonObject.sslOptions) {\n            if (jsonObject.sslOptionsFactory || jsonObject.sslOptionsFactoryProperties) {\n                throw new RangeError('Invalid configuration. Either SSL options should be set manually or SSL factory'\n                    + ' should be used.');\n            }\n            this.effectiveConfig.network.ssl.sslOptions = jsonObject.sslOptions;\n        }\n        else if (jsonObject.sslOptionsFactory || jsonObject.sslOptionsFactoryProperties) {\n            this.effectiveConfig.network.ssl.sslOptionsFactory = jsonObject.sslOptionsFactory;\n            this.effectiveConfig.network.ssl.sslOptionsFactoryProperties = jsonObject.sslOptionsFactoryProperties\n                ? this.parseProperties(jsonObject.sslOptionsFactoryProperties) : null;\n        }\n    }\n    handleClusterMembers(jsonObject) {\n        const addressArray = Util_1.tryGetArray(jsonObject);\n        for (const index in addressArray) {\n            const address = addressArray[index];\n            this.effectiveConfig.network.clusterMembers.push(Util_1.tryGetString(address));\n        }\n    }\n    handleProperties(jsonObject) {\n        for (const key in jsonObject) {\n            this.effectiveConfig.properties[key] = jsonObject[key];\n        }\n    }\n    handleLifecycleListeners(jsonObject) {\n        const listenersArray = Util_1.tryGetArray(jsonObject);\n        for (const index in listenersArray) {\n            const listener = listenersArray[index];\n            this.effectiveConfig.lifecycleListeners.push(listener);\n        }\n    }\n    handleMembershipListeners(jsonObject) {\n        const listenersArray = Util_1.tryGetArray(jsonObject);\n        for (const index in listenersArray) {\n            const listener = listenersArray[index];\n            this.effectiveConfig.membershipListeners.push(listener);\n        }\n    }\n    handleSerialization(jsonObject) {\n        for (const key in jsonObject) {\n            if (key === 'defaultNumberType') {\n                this.effectiveConfig.serialization.defaultNumberType = Util_1.tryGetString(jsonObject[key]);\n            }\n            else if (key === 'isBigEndian') {\n                this.effectiveConfig.serialization.isBigEndian = Util_1.tryGetBoolean(jsonObject[key]);\n            }\n            else if (key === 'portableVersion') {\n                this.effectiveConfig.serialization.portableVersion = Util_1.tryGetNumber(jsonObject[key]);\n            }\n            else if (key === 'dataSerializableFactories') {\n                for (const index in jsonObject[key]) {\n                    const idx = Number.parseInt(index);\n                    this.effectiveConfig.serialization\n                        .dataSerializableFactories[idx] = jsonObject[key][index];\n                }\n            }\n            else if (key === 'portableFactories') {\n                for (const index in jsonObject[key]) {\n                    const idx = Number.parseInt(index);\n                    this.effectiveConfig.serialization\n                        .portableFactories[idx] = jsonObject[key][index];\n                }\n            }\n            else if (key === 'globalSerializer') {\n                const globalSerializer = jsonObject[key];\n                this.effectiveConfig.serialization.globalSerializer = globalSerializer;\n            }\n            else if (key === 'customSerializers') {\n                this.handleCustomSerializers(jsonObject[key]);\n            }\n            else if (key === 'jsonStringDeserializationPolicy') {\n                this.effectiveConfig.serialization\n                    .jsonStringDeserializationPolicy = Util_1.tryGetEnum(JsonStringDeserializationPolicy_1.JsonStringDeserializationPolicy, jsonObject[key]);\n            }\n        }\n    }\n    handleCustomSerializers(jsonObject) {\n        const serializersArray = Util_1.tryGetArray(jsonObject);\n        for (const index in serializersArray) {\n            const serializer = serializersArray[index];\n            this.effectiveConfig.serialization.customSerializers.push(serializer);\n        }\n    }\n    handleNearCaches(jsonObject) {\n        for (const key in jsonObject) {\n            const ncConfig = jsonObject[key];\n            const nearCacheConfig = new NearCacheConfig_1.NearCacheConfigImpl();\n            nearCacheConfig.name = key;\n            for (const name in ncConfig) {\n                if (name === 'invalidateOnChange') {\n                    nearCacheConfig.invalidateOnChange = Util_1.tryGetBoolean(ncConfig[name]);\n                }\n                else if (name === 'maxIdleSeconds') {\n                    nearCacheConfig.maxIdleSeconds = Util_1.tryGetNumber(ncConfig[name]);\n                }\n                else if (name === 'inMemoryFormat') {\n                    nearCacheConfig.inMemoryFormat = Util_1.tryGetEnum(InMemoryFormat_1.InMemoryFormat, ncConfig[name]);\n                }\n                else if (name === 'timeToLiveSeconds') {\n                    nearCacheConfig.timeToLiveSeconds = Util_1.tryGetNumber(ncConfig[name]);\n                }\n                else if (name === 'evictionPolicy') {\n                    nearCacheConfig.evictionPolicy = Util_1.tryGetEnum(EvictionPolicy_1.EvictionPolicy, ncConfig[name]);\n                }\n                else if (name === 'evictionMaxSize') {\n                    nearCacheConfig.evictionMaxSize = Util_1.tryGetNumber(ncConfig[name]);\n                }\n                else if (name === 'evictionSamplingCount') {\n                    nearCacheConfig.evictionSamplingCount = Util_1.tryGetNumber(ncConfig[name]);\n                }\n                else if (name === 'evictionSamplingPoolSize') {\n                    nearCacheConfig.evictionSamplingPoolSize = Util_1.tryGetNumber(ncConfig[name]);\n                }\n            }\n            this.effectiveConfig.nearCaches[nearCacheConfig.name] = nearCacheConfig;\n        }\n    }\n    handleReliableTopics(jsonObject) {\n        for (const key in jsonObject) {\n            const jsonRtCfg = jsonObject[key];\n            const reliableTopicConfig = new ReliableTopicConfig_1.ReliableTopicConfigImpl();\n            reliableTopicConfig.name = key;\n            for (const name in jsonRtCfg) {\n                if (name === 'readBatchSize') {\n                    reliableTopicConfig.readBatchSize = jsonRtCfg[name];\n                }\n                else if (name === 'overloadPolicy') {\n                    reliableTopicConfig.overloadPolicy = Util_1.tryGetEnum(proxy_1.TopicOverloadPolicy, jsonRtCfg[name]);\n                }\n            }\n            this.effectiveConfig.reliableTopics[reliableTopicConfig.name] = reliableTopicConfig;\n        }\n    }\n    handleFlakeIdGenerators(jsonObject) {\n        for (const key in jsonObject) {\n            const fidConfig = jsonObject[key];\n            const flakeIdConfig = new FlakeIdGeneratorConfig_1.FlakeIdGeneratorConfigImpl();\n            flakeIdConfig.name = key;\n            for (const name in fidConfig) {\n                if (name === 'prefetchCount') {\n                    flakeIdConfig.prefetchCount = Util_1.tryGetNumber(fidConfig[name]);\n                }\n                else if (name === 'prefetchValidityMillis') {\n                    flakeIdConfig.prefetchValidityMillis = Util_1.tryGetNumber(fidConfig[name]);\n                }\n            }\n            this.effectiveConfig.flakeIdGenerators[flakeIdConfig.name] = flakeIdConfig;\n        }\n    }\n    handleLoadBalancer(jsonObject) {\n        for (const key in jsonObject) {\n            if (key === 'type') {\n                this.effectiveConfig.loadBalancer.type = Util_1.tryGetEnum(LoadBalancerConfig_1.LoadBalancerType, jsonObject[key]);\n            }\n            else if (key === 'customLoadBalancer') {\n                this.effectiveConfig.loadBalancer.customLoadBalancer = jsonObject[key];\n            }\n        }\n    }\n    handleLogger(jsonObject) {\n        this.effectiveConfig.customLogger = jsonObject;\n    }\n    handleCredentials(jsonObject) {\n        this.effectiveConfig.customCredentials = jsonObject;\n    }\n}\nexports.ConfigBuilder = ConfigBuilder;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/ConfigBuilder.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/ConfigPatternMatcher.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/ConfigPatternMatcher.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigPatternMatcher = void 0;\n/** @internal */\nclass ConfigPatternMatcher {\n    /**\n     *\n     * @param configPatterns\n     * @param itemName\n     * @throws\n     * @returns `null` if there is no matching pattern;\n     *          the best matching pattern otherwise\n     */\n    matches(configPatterns, itemName) {\n        let bestMatchingPoint = -1;\n        let matchingPattern = null;\n        let duplicatePattern = null;\n        configPatterns.forEach((pattern) => {\n            const currentPoint = this.getMatchingPoint(pattern, itemName);\n            if (currentPoint > bestMatchingPoint) {\n                bestMatchingPoint = currentPoint;\n                matchingPattern = pattern;\n                duplicatePattern = null;\n            }\n            else if (currentPoint === bestMatchingPoint && matchingPattern != null) {\n                duplicatePattern = matchingPattern;\n                matchingPattern = pattern;\n            }\n        });\n        if (duplicatePattern != null) {\n            throw new TypeError('Found ambiguous configurations for item ' + itemName + ': \"' + matchingPattern +\n                '\" vs \"' + duplicatePattern + '\". Please specify your configuration.');\n        }\n        return matchingPattern;\n    }\n    getMatchingPoint(pattern, itemName) {\n        const index = pattern.indexOf('*');\n        if (index === -1) {\n            return -1;\n        }\n        const firstPart = pattern.substring(0, index);\n        if (!itemName.startsWith(firstPart)) {\n            return -1;\n        }\n        const secondPart = pattern.substring(index + 1);\n        if (!itemName.endsWith(secondPart)) {\n            return -1;\n        }\n        return firstPart.length + secondPart.length;\n    }\n}\nexports.ConfigPatternMatcher = ConfigPatternMatcher;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/ConfigPatternMatcher.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/ConnectionRetryConfig.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/ConnectionRetryConfig.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectionRetryConfigImpl = void 0;\n/**\n * Connection Retry Config is controls the period among the retries and when should a client gave up\n * retrying. Exponential behaviour can be chosen or jitter can be added to wait periods.\n * @internal\n */\nclass ConnectionRetryConfigImpl {\n    constructor() {\n        this.initialBackoffMillis = 1000;\n        this.maxBackoffMillis = 30000;\n        this.clusterConnectTimeoutMillis = 20000;\n        this.multiplier = 1;\n        this.jitter = 0;\n    }\n}\nexports.ConnectionRetryConfigImpl = ConnectionRetryConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/ConnectionRetryConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/ConnectionStrategyConfig.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/ConnectionStrategyConfig.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectionStrategyConfigImpl = exports.ReconnectMode = void 0;\nconst ConnectionRetryConfig_1 = __webpack_require__(/*! ./ConnectionRetryConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ConnectionRetryConfig.js\");\n/**\n * Reconnect mode.\n */\nvar ReconnectMode;\n(function (ReconnectMode) {\n    /**\n     * Prevent reconnect to cluster after a disconnect\n     */\n    ReconnectMode[\"OFF\"] = \"OFF\";\n    /**\n     * Reconnect to cluster by blocking invocations\n     */\n    ReconnectMode[\"ON\"] = \"ON\";\n    /**\n     * Reconnect to cluster without blocking invocations. Invocations will receive\n     * {@link ClientOfflineError}\n     */\n    ReconnectMode[\"ASYNC\"] = \"ASYNC\";\n})(ReconnectMode = exports.ReconnectMode || (exports.ReconnectMode = {}));\n/** @internal */\nclass ConnectionStrategyConfigImpl {\n    constructor() {\n        this.asyncStart = false;\n        this.reconnectMode = ReconnectMode.ON;\n        this.connectionRetry = new ConnectionRetryConfig_1.ConnectionRetryConfigImpl();\n    }\n}\nexports.ConnectionStrategyConfigImpl = ConnectionStrategyConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/ConnectionStrategyConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/EvictionPolicy.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/EvictionPolicy.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EvictionPolicy = void 0;\n/**\n * Represents the format that objects are kept in this client's memory.\n */\nvar EvictionPolicy;\n(function (EvictionPolicy) {\n    /**\n     * No items are evicted.\n     */\n    EvictionPolicy[\"NONE\"] = \"NONE\";\n    /**\n     * Least Recently Used.\n     */\n    EvictionPolicy[\"LRU\"] = \"LRU\";\n    /**\n     * Least Frequently Used.\n     */\n    EvictionPolicy[\"LFU\"] = \"LFU\";\n    /**\n     * A random item is evicted each time.\n     */\n    EvictionPolicy[\"RANDOM\"] = \"RANDOM\";\n})(EvictionPolicy = exports.EvictionPolicy || (exports.EvictionPolicy = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/EvictionPolicy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/FlakeIdGeneratorConfig.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/FlakeIdGeneratorConfig.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlakeIdGeneratorConfigImpl = void 0;\n/** @internal */\nclass FlakeIdGeneratorConfigImpl {\n    constructor() {\n        this.prefetchCount = 100;\n        this.prefetchValidityMillis = 600000;\n    }\n    toString() {\n        return 'FlakeIdGeneratorConfig[' +\n            'name: ' + this.name + ', ' +\n            'prefetchCount: ' + this.prefetchCount + ', ' +\n            'prefetchValidityMillis: ' + this.prefetchValidityMillis + ']';\n    }\n    clone() {\n        const other = new FlakeIdGeneratorConfigImpl();\n        Object.assign(other, this);\n        return other;\n    }\n}\nexports.FlakeIdGeneratorConfigImpl = FlakeIdGeneratorConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/FlakeIdGeneratorConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/InMemoryFormat.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/InMemoryFormat.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InMemoryFormat = void 0;\n/**\n * In-memory format for Near Cache.\n */\nvar InMemoryFormat;\n(function (InMemoryFormat) {\n    /**\n     * Objects are in native JS objects.\n     */\n    InMemoryFormat[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Objects are in serialized form.\n     */\n    InMemoryFormat[\"BINARY\"] = \"BINARY\";\n})(InMemoryFormat = exports.InMemoryFormat || (exports.InMemoryFormat = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/InMemoryFormat.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/IndexConfig.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/IndexConfig.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InternalIndexConfig = void 0;\nconst IndexType_1 = __webpack_require__(/*! ./IndexType */ \"../shared/node_modules/hazelcast-client/lib/config/IndexType.js\");\n/**\n * Follows the shape of {@link IndexConfig}, but doesn't implement it due\n * to the `type` enum field.\n * @internal\n */\nclass InternalIndexConfig {\n    constructor(name, type, attributes, bitmapIndexOptions) {\n        this.type = InternalIndexConfig.DEFAULT_TYPE;\n        this.attributes = [];\n        if (name) {\n            this.name = name;\n        }\n        if (type) {\n            this.type = type;\n        }\n        if (attributes) {\n            this.attributes = attributes;\n        }\n        if (bitmapIndexOptions) {\n            this.bitmapIndexOptions = bitmapIndexOptions;\n        }\n    }\n    toString() {\n        let bitmapIndexOptions;\n        if (this.bitmapIndexOptions == null) {\n            bitmapIndexOptions = undefined;\n        }\n        else {\n            bitmapIndexOptions = this.bitmapIndexOptions.toString();\n        }\n        return 'IndexConfig[' +\n            'name: ' + this.name +\n            ', type: ' + this.type +\n            ', attributes: ' + this.attributes +\n            ', bitmapIndexOptions: ' + bitmapIndexOptions +\n            ']';\n    }\n}\nexports.InternalIndexConfig = InternalIndexConfig;\n/**\n * Default index type.\n */\nInternalIndexConfig.DEFAULT_TYPE = IndexType_1.IndexType.SORTED;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/IndexConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/IndexType.js":
/*!***********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/IndexType.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IndexType = void 0;\n/**\n * Type of the index.\n */\nvar IndexType;\n(function (IndexType) {\n    /**\n     * Sorted index. Can be used with equality and range predicates.\n     */\n    IndexType[IndexType[\"SORTED\"] = 0] = \"SORTED\";\n    /**\n     * Hash index. Can be used with equality predicates.\n     */\n    IndexType[IndexType[\"HASH\"] = 1] = \"HASH\";\n    /**\n     * Bitmap index. Can be used with equality predicates.\n     */\n    IndexType[IndexType[\"BITMAP\"] = 2] = \"BITMAP\";\n})(IndexType = exports.IndexType || (exports.IndexType = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/IndexType.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/JsonStringDeserializationPolicy.js":
/*!*********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/JsonStringDeserializationPolicy.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonStringDeserializationPolicy = void 0;\n/**\n * Using this policy, one can control the\n * deserialization type of the JSON strings.\n */\nvar JsonStringDeserializationPolicy;\n(function (JsonStringDeserializationPolicy) {\n    /**\n     * JSON strings are parsed and returned\n     * as JavaScript objects.\n     */\n    JsonStringDeserializationPolicy[\"EAGER\"] = \"EAGER\";\n    /**\n     * Raw JSON strings are returned around a\n     * lightweight {@link HazelcastJsonValue}\n     * wrapper.\n     */\n    JsonStringDeserializationPolicy[\"NO_DESERIALIZATION\"] = \"NO_DESERIALIZATION\";\n})(JsonStringDeserializationPolicy = exports.JsonStringDeserializationPolicy || (exports.JsonStringDeserializationPolicy = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/JsonStringDeserializationPolicy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/LoadBalancerConfig.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/LoadBalancerConfig.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoadBalancerConfigImpl = exports.LoadBalancerType = void 0;\n/**\n * Defines {@link LoadBalancer} type used by the client.\n */\nvar LoadBalancerType;\n(function (LoadBalancerType) {\n    /**\n     * This type of load balancer picks the next member randomly.\n     */\n    LoadBalancerType[\"RANDOM\"] = \"RANDOM\";\n    /**\n     * This type of load balancer picks each cluster member in turn.\n     */\n    LoadBalancerType[\"ROUND_ROBIN\"] = \"ROUND_ROBIN\";\n})(LoadBalancerType = exports.LoadBalancerType || (exports.LoadBalancerType = {}));\n/** @internal */\nclass LoadBalancerConfigImpl {\n    constructor() {\n        this.type = LoadBalancerType.ROUND_ROBIN;\n        this.customLoadBalancer = null;\n    }\n}\nexports.LoadBalancerConfigImpl = LoadBalancerConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/LoadBalancerConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/NearCacheConfig.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/NearCacheConfig.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NearCacheConfigImpl = void 0;\nconst EvictionPolicy_1 = __webpack_require__(/*! ./EvictionPolicy */ \"../shared/node_modules/hazelcast-client/lib/config/EvictionPolicy.js\");\nconst InMemoryFormat_1 = __webpack_require__(/*! ./InMemoryFormat */ \"../shared/node_modules/hazelcast-client/lib/config/InMemoryFormat.js\");\n/** @internal */\nclass NearCacheConfigImpl {\n    constructor() {\n        this.invalidateOnChange = true;\n        this.maxIdleSeconds = 0;\n        this.inMemoryFormat = InMemoryFormat_1.InMemoryFormat.BINARY;\n        this.timeToLiveSeconds = 0;\n        this.evictionPolicy = EvictionPolicy_1.EvictionPolicy.LRU;\n        this.evictionMaxSize = Number.MAX_SAFE_INTEGER;\n        this.evictionSamplingCount = 8;\n        this.evictionSamplingPoolSize = 16;\n    }\n    toString() {\n        return 'NearCacheConfig[' +\n            'name: ' + this.name + ', ' +\n            'invalidateOnChange:' + this.invalidateOnChange + ', ' +\n            'inMemoryFormat: ' + this.inMemoryFormat + ', ' +\n            'ttl(sec): ' + this.timeToLiveSeconds + ', ' +\n            'evictionPolicy: ' + this.evictionPolicy + ', ' +\n            'evictionMaxSize: ' + this.evictionMaxSize + ', ' +\n            'maxIdleSeconds: ' + this.maxIdleSeconds + ']';\n    }\n    clone() {\n        const other = new NearCacheConfigImpl();\n        Object.assign(other, this);\n        return other;\n    }\n}\nexports.NearCacheConfigImpl = NearCacheConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/NearCacheConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/Properties.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/Properties.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/Properties.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/ReliableTopicConfig.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/ReliableTopicConfig.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReliableTopicConfigImpl = void 0;\nconst proxy_1 = __webpack_require__(/*! ../proxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/index.js\");\n/** @internal */\nclass ReliableTopicConfigImpl {\n    constructor() {\n        this.readBatchSize = 10;\n        this.overloadPolicy = proxy_1.TopicOverloadPolicy.BLOCK;\n    }\n    toString() {\n        return 'ReliableTopicConfig[' +\n            'name: ' + this.name + ', ' +\n            'readBatchSize: ' + this.readBatchSize + ', ' +\n            'overloadPolicy: ' + this.overloadPolicy + ']';\n    }\n    clone() {\n        const other = new ReliableTopicConfigImpl();\n        Object.assign(other, this);\n        return other;\n    }\n}\nexports.ReliableTopicConfigImpl = ReliableTopicConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/ReliableTopicConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/SSLConfig.js":
/*!***********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/SSLConfig.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SSLConfigImpl = void 0;\n/** @internal */\nclass SSLConfigImpl {\n    constructor() {\n        this.enabled = false;\n        this.sslOptions = null;\n        this.sslOptionsFactory = null;\n        this.sslOptionsFactoryProperties = null;\n    }\n}\nexports.SSLConfigImpl = SSLConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/SSLConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/SerializationConfig.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/SerializationConfig.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SerializationConfigImpl = void 0;\nconst JsonStringDeserializationPolicy_1 = __webpack_require__(/*! ./JsonStringDeserializationPolicy */ \"../shared/node_modules/hazelcast-client/lib/config/JsonStringDeserializationPolicy.js\");\n/** @internal */\nclass SerializationConfigImpl {\n    constructor() {\n        this.defaultNumberType = 'double';\n        this.isBigEndian = true;\n        this.dataSerializableFactories = {};\n        this.portableFactories = {};\n        this.portableVersion = 0;\n        this.customSerializers = [];\n        this.globalSerializer = null;\n        this.jsonStringDeserializationPolicy = JsonStringDeserializationPolicy_1.JsonStringDeserializationPolicy.EAGER;\n    }\n}\nexports.SerializationConfigImpl = SerializationConfigImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/SerializationConfig.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/config/index.js":
/*!*******************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/config/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Public API re-exports.\n */\n__exportStar(__webpack_require__(/*! ./BitmapIndexOptions */ \"../shared/node_modules/hazelcast-client/lib/config/BitmapIndexOptions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ClientCloudConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ClientCloudConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ClientNetworkConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ClientNetworkConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Config */ \"../shared/node_modules/hazelcast-client/lib/config/Config.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ConnectionRetryConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ConnectionRetryConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ConnectionStrategyConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ConnectionStrategyConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EvictionPolicy */ \"../shared/node_modules/hazelcast-client/lib/config/EvictionPolicy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./FlakeIdGeneratorConfig */ \"../shared/node_modules/hazelcast-client/lib/config/FlakeIdGeneratorConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IndexConfig */ \"../shared/node_modules/hazelcast-client/lib/config/IndexConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IndexType */ \"../shared/node_modules/hazelcast-client/lib/config/IndexType.js\"), exports);\n__exportStar(__webpack_require__(/*! ./InMemoryFormat */ \"../shared/node_modules/hazelcast-client/lib/config/InMemoryFormat.js\"), exports);\n__exportStar(__webpack_require__(/*! ./JsonStringDeserializationPolicy */ \"../shared/node_modules/hazelcast-client/lib/config/JsonStringDeserializationPolicy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./LoadBalancerConfig */ \"../shared/node_modules/hazelcast-client/lib/config/LoadBalancerConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./NearCacheConfig */ \"../shared/node_modules/hazelcast-client/lib/config/NearCacheConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Properties */ \"../shared/node_modules/hazelcast-client/lib/config/Properties.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ReliableTopicConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ReliableTopicConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SerializationConfig */ \"../shared/node_modules/hazelcast-client/lib/config/SerializationConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SSLConfig */ \"../shared/node_modules/hazelcast-client/lib/config/SSLConfig.js\"), exports);\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/config/index.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/connection/BasicSSLOptionsFactory.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/connection/BasicSSLOptionsFactory.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BasicSSLOptionsFactory = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\n/**\n * Default implementation of {@link SSLOptionsFactory}.\n */\nclass BasicSSLOptionsFactory {\n    init(properties) {\n        if (typeof properties !== 'object') {\n            throw new core_1.HazelcastError('properties is not an object');\n        }\n        const promises = [];\n        const readFile = Promise.promisify(fs.readFile);\n        const caPath = Util_1.getStringOrUndefined(properties.caPath);\n        const keyPath = Util_1.getStringOrUndefined(properties.keyPath);\n        const certPath = Util_1.getStringOrUndefined(properties.certPath);\n        if (caPath !== undefined) {\n            promises.push(readFile(Util_1.resolvePath(caPath)).then((data) => {\n                this.ca = data;\n            }));\n        }\n        if (keyPath !== undefined) {\n            promises.push(readFile(Util_1.resolvePath(keyPath)).then((data) => {\n                this.key = data;\n            }));\n        }\n        if (certPath !== undefined) {\n            promises.push(readFile(Util_1.resolvePath(certPath)).then((data) => {\n                this.cert = data;\n            }));\n        }\n        this.servername = Util_1.getStringOrUndefined(properties.servername);\n        this.rejectUnauthorized = Util_1.getBooleanOrUndefined(properties.rejectUnauthorized);\n        this.ciphers = Util_1.getStringOrUndefined(properties.ciphers);\n        return Promise.all(promises)\n            .then(() => undefined);\n    }\n    getSSLOptions() {\n        return {\n            servername: this.servername,\n            rejectUnauthorized: this.rejectUnauthorized,\n            ca: this.ca,\n            key: this.key,\n            cert: this.cert,\n            ciphers: this.ciphers,\n        };\n    }\n}\nexports.BasicSSLOptionsFactory = BasicSSLOptionsFactory;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/connection/BasicSSLOptionsFactory.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/connection/DefaultAddressProvider.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/connection/DefaultAddressProvider.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultAddressProvider = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\n/**\n * Default address provider of Hazelcast.\n * Loads addresses from the Hazelcast configuration.\n * @internal\n */\nclass DefaultAddressProvider {\n    constructor(networkConfig) {\n        this.networkConfig = networkConfig;\n    }\n    loadAddresses() {\n        const addresses = this.networkConfig.clusterMembers;\n        if (addresses.length === 0) {\n            addresses.push('localhost');\n        }\n        return Promise.resolve(addresses);\n    }\n    translate(address) {\n        return Promise.resolve(address);\n    }\n}\nexports.DefaultAddressProvider = DefaultAddressProvider;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/connection/DefaultAddressProvider.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/connection/SSLOptionsFactory.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/connection/SSLOptionsFactory.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/connection/SSLOptionsFactory.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/connection/index.js":
/*!***********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/connection/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Public API re-exports.\n */\n__exportStar(__webpack_require__(/*! ./BasicSSLOptionsFactory */ \"../shared/node_modules/hazelcast-client/lib/connection/BasicSSLOptionsFactory.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SSLOptionsFactory */ \"../shared/node_modules/hazelcast-client/lib/connection/SSLOptionsFactory.js\"), exports);\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/connection/index.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/Address.js":
/*!*******************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/Address.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AddressImpl = void 0;\nconst net = __webpack_require__(/*! net */ \"net\");\nconst ClusterDataFactory_1 = __webpack_require__(/*! ../serialization/ClusterDataFactory */ \"../shared/node_modules/hazelcast-client/lib/serialization/ClusterDataFactory.js\");\n/** @internal */\nclass AddressImpl {\n    constructor(host, port) {\n        this.factoryId = ClusterDataFactory_1.CLUSTER_DATA_FACTORY_ID;\n        this.classId = ClusterDataFactory_1.CLUSTER_DATA_ADDRESS_CLASS_ID;\n        this.host = host;\n        this.port = port;\n        this.type = net.isIP(host);\n        this.addrStr = this.toStringInternal();\n    }\n    readData(input) {\n        this.port = input.readInt();\n        this.type = input.readByte();\n        this.host = input.readUTF();\n        this.addrStr = this.toStringInternal();\n    }\n    writeData(output) {\n        output.writeInt(this.port);\n        output.writeByte(this.type);\n        output.writeUTF(this.host);\n    }\n    equals(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (other.host === this.host &&\n            other.port === this.port &&\n            other.type === this.type) {\n            return true;\n        }\n        return false;\n    }\n    toString() {\n        return this.addrStr;\n    }\n    toStringInternal() {\n        return this.host + ':' + this.port;\n    }\n}\nexports.AddressImpl = AddressImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/Address.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/ClientInfo.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/ClientInfo.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientInfo = void 0;\n/**\n * Local information of the client.\n */\nclass ClientInfo {\n    constructor() {\n        /**\n         * Type of this client. It is always NodeJS.\n         */\n        this.type = 'NodeJS';\n    }\n}\nexports.ClientInfo = ClientInfo;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/ClientInfo.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/Cluster.js":
/*!*******************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/Cluster.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/Cluster.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/Comparator.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/Comparator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/Comparator.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/DistributedObject.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/DistributedObject.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/DistributedObject.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/DistributedObjectInfo.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/DistributedObjectInfo.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DistributedObjectInfo = void 0;\n/** @internal */\nclass DistributedObjectInfo {\n    constructor(serviceName, name) {\n        this.serviceName = serviceName;\n        this.name = name;\n    }\n}\nexports.DistributedObjectInfo = DistributedObjectInfo;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/DistributedObjectInfo.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/DistributedObjectListener.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/DistributedObjectListener.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DistributedObjectEvent = void 0;\n/**\n * DistributedObjectEvent is fired when a DistributedObject\n * is created or destroyed cluster-wide.\n */\nclass DistributedObjectEvent {\n    constructor(eventType, serviceName, objectName) {\n        this.eventType = eventType;\n        this.serviceName = serviceName;\n        this.objectName = objectName;\n    }\n}\nexports.DistributedObjectEvent = DistributedObjectEvent;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/DistributedObjectListener.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/HazelcastError.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/HazelcastError.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UndefinedErrorCodeError = exports.NullPointerError = exports.NoSuchElementError = exports.NegativeArraySizeError = exports.InvalidAddressError = exports.InterruptedError = exports.IndexOutOfBoundsError = exports.IllegalArgumentError = exports.ArrayStoreError = exports.ArrayIndexOutOfBoundsError = exports.IndeterminateOperationStateError = exports.ReachedMaxSizeError = exports.NodeIdOutOfRangeError = exports.StaleTaskIdError = exports.NoDataMemberInClusterError = exports.ConsistencyLostError = exports.UnsupportedOperationError = exports.TargetDisconnectedError = exports.RetryableIOError = exports.SplitBrainProtectionError = exports.TransactionTimedOutError = exports.TransactionNotActiveError = exports.TransactionError = exports.QueryError = exports.PartitionMigratingError = exports.MemberLeftError = exports.HazelcastInstanceNotActiveError = exports.DistributedObjectDestroyedError = exports.ConfigMismatchError = exports.ConcurrentModificationError = exports.ClassNotFoundError = exports.ClassCastError = exports.CancellationError = exports.CallerNotMemberError = exports.TargetNotMemberError = exports.RetryableHazelcastError = exports.InvocationTimeoutError = exports.IOError = exports.TopicOverloadError = exports.StaleSequenceError = exports.IllegalStateError = exports.InvalidConfigurationError = exports.ClientOfflineError = exports.ClientNotAllowedInClusterError = exports.ClientNotActiveError = exports.AuthenticationError = exports.HazelcastSerializationError = exports.HazelcastError = void 0;\n/**\n * Base class for all specific exceptions thrown by Hazelcast client.\n */\nclass HazelcastError extends Error {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg);\n        this.cause = cause;\n        this.serverStackTrace = serverStackTrace;\n        Error.captureStackTrace(this, HazelcastError);\n        Object.setPrototypeOf(this, HazelcastError.prototype);\n    }\n}\nexports.HazelcastError = HazelcastError;\nclass HazelcastSerializationError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, HazelcastSerializationError.prototype);\n    }\n}\nexports.HazelcastSerializationError = HazelcastSerializationError;\nclass AuthenticationError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, AuthenticationError.prototype);\n    }\n}\nexports.AuthenticationError = AuthenticationError;\nclass ClientNotActiveError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ClientNotActiveError.prototype);\n    }\n}\nexports.ClientNotActiveError = ClientNotActiveError;\nclass ClientNotAllowedInClusterError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ClientNotAllowedInClusterError.prototype);\n    }\n}\nexports.ClientNotAllowedInClusterError = ClientNotAllowedInClusterError;\nclass ClientOfflineError extends HazelcastError {\n    constructor(cause) {\n        super('No connection found to cluster', cause);\n        Object.setPrototypeOf(this, ClientOfflineError.prototype);\n    }\n}\nexports.ClientOfflineError = ClientOfflineError;\nclass InvalidConfigurationError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, InvalidConfigurationError.prototype);\n    }\n}\nexports.InvalidConfigurationError = InvalidConfigurationError;\nclass IllegalStateError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, IllegalStateError.prototype);\n    }\n}\nexports.IllegalStateError = IllegalStateError;\nclass StaleSequenceError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, StaleSequenceError.prototype);\n    }\n}\nexports.StaleSequenceError = StaleSequenceError;\nclass TopicOverloadError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, TopicOverloadError.prototype);\n    }\n}\nexports.TopicOverloadError = TopicOverloadError;\nclass IOError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, IOError.prototype);\n    }\n}\nexports.IOError = IOError;\nclass InvocationTimeoutError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, InvocationTimeoutError.prototype);\n    }\n}\nexports.InvocationTimeoutError = InvocationTimeoutError;\nclass RetryableHazelcastError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, RetryableHazelcastError.prototype);\n    }\n}\nexports.RetryableHazelcastError = RetryableHazelcastError;\nclass TargetNotMemberError extends RetryableHazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, TargetNotMemberError.prototype);\n    }\n}\nexports.TargetNotMemberError = TargetNotMemberError;\nclass CallerNotMemberError extends RetryableHazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, CallerNotMemberError.prototype);\n    }\n}\nexports.CallerNotMemberError = CallerNotMemberError;\nclass CancellationError extends IllegalStateError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, CancellationError.prototype);\n    }\n}\nexports.CancellationError = CancellationError;\nclass ClassCastError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ClassCastError.prototype);\n    }\n}\nexports.ClassCastError = ClassCastError;\nclass ClassNotFoundError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ClassNotFoundError.prototype);\n    }\n}\nexports.ClassNotFoundError = ClassNotFoundError;\nclass ConcurrentModificationError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ConcurrentModificationError.prototype);\n    }\n}\nexports.ConcurrentModificationError = ConcurrentModificationError;\nclass ConfigMismatchError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ConfigMismatchError.prototype);\n    }\n}\nexports.ConfigMismatchError = ConfigMismatchError;\nclass DistributedObjectDestroyedError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, DistributedObjectDestroyedError.prototype);\n    }\n}\nexports.DistributedObjectDestroyedError = DistributedObjectDestroyedError;\nclass HazelcastInstanceNotActiveError extends IllegalStateError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, HazelcastInstanceNotActiveError.prototype);\n    }\n}\nexports.HazelcastInstanceNotActiveError = HazelcastInstanceNotActiveError;\nclass MemberLeftError extends RetryableHazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, MemberLeftError.prototype);\n    }\n}\nexports.MemberLeftError = MemberLeftError;\nclass PartitionMigratingError extends RetryableHazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, PartitionMigratingError.prototype);\n    }\n}\nexports.PartitionMigratingError = PartitionMigratingError;\nclass QueryError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, QueryError.prototype);\n    }\n}\nexports.QueryError = QueryError;\nclass TransactionError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, TransactionError.prototype);\n    }\n}\nexports.TransactionError = TransactionError;\nclass TransactionNotActiveError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, TransactionNotActiveError.prototype);\n    }\n}\nexports.TransactionNotActiveError = TransactionNotActiveError;\nclass TransactionTimedOutError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, TransactionTimedOutError.prototype);\n    }\n}\nexports.TransactionTimedOutError = TransactionTimedOutError;\nclass SplitBrainProtectionError extends TransactionError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, SplitBrainProtectionError.prototype);\n    }\n}\nexports.SplitBrainProtectionError = SplitBrainProtectionError;\nclass RetryableIOError extends RetryableHazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, RetryableIOError.prototype);\n    }\n}\nexports.RetryableIOError = RetryableIOError;\nclass TargetDisconnectedError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, TargetDisconnectedError.prototype);\n    }\n}\nexports.TargetDisconnectedError = TargetDisconnectedError;\nclass UnsupportedOperationError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, UnsupportedOperationError.prototype);\n    }\n}\nexports.UnsupportedOperationError = UnsupportedOperationError;\nclass ConsistencyLostError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ConsistencyLostError.prototype);\n    }\n}\nexports.ConsistencyLostError = ConsistencyLostError;\nclass NoDataMemberInClusterError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, NoDataMemberInClusterError.prototype);\n    }\n}\nexports.NoDataMemberInClusterError = NoDataMemberInClusterError;\nclass StaleTaskIdError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, StaleTaskIdError.prototype);\n    }\n}\nexports.StaleTaskIdError = StaleTaskIdError;\nclass NodeIdOutOfRangeError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, NodeIdOutOfRangeError.prototype);\n    }\n}\nexports.NodeIdOutOfRangeError = NodeIdOutOfRangeError;\nclass ReachedMaxSizeError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ReachedMaxSizeError.prototype);\n    }\n}\nexports.ReachedMaxSizeError = ReachedMaxSizeError;\nclass IndeterminateOperationStateError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, IndeterminateOperationStateError.prototype);\n    }\n}\nexports.IndeterminateOperationStateError = IndeterminateOperationStateError;\nclass ArrayIndexOutOfBoundsError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ArrayIndexOutOfBoundsError.prototype);\n    }\n}\nexports.ArrayIndexOutOfBoundsError = ArrayIndexOutOfBoundsError;\nclass ArrayStoreError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, ArrayStoreError.prototype);\n    }\n}\nexports.ArrayStoreError = ArrayStoreError;\nclass IllegalArgumentError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, IllegalArgumentError.prototype);\n    }\n}\nexports.IllegalArgumentError = IllegalArgumentError;\nclass IndexOutOfBoundsError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, IndexOutOfBoundsError.prototype);\n    }\n}\nexports.IndexOutOfBoundsError = IndexOutOfBoundsError;\nclass InterruptedError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, InterruptedError.prototype);\n    }\n}\nexports.InterruptedError = InterruptedError;\nclass InvalidAddressError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, InvalidAddressError.prototype);\n    }\n}\nexports.InvalidAddressError = InvalidAddressError;\nclass NegativeArraySizeError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, NegativeArraySizeError.prototype);\n    }\n}\nexports.NegativeArraySizeError = NegativeArraySizeError;\nclass NoSuchElementError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, NoSuchElementError.prototype);\n    }\n}\nexports.NoSuchElementError = NoSuchElementError;\nclass NullPointerError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, NullPointerError.prototype);\n    }\n}\nexports.NullPointerError = NullPointerError;\nclass UndefinedErrorCodeError extends HazelcastError {\n    constructor(msg, cause, serverStackTrace) {\n        super(msg, cause, serverStackTrace);\n        Object.setPrototypeOf(this, UndefinedErrorCodeError.prototype);\n    }\n}\nexports.UndefinedErrorCodeError = UndefinedErrorCodeError;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/HazelcastError.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/HazelcastJsonValue.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/HazelcastJsonValue.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HazelcastJsonValue = void 0;\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\n/**\n * HazelcastJsonValue is a wrapper for JSON formatted strings. It is preferred\n * to store HazelcastJsonValue instead of Strings for JSON formatted strings.\n * Users can run predicates and use indexes on the attributes of the underlying\n * JSON strings.\n *\n * HazelcastJsonValue is queried using Hazelcast's querying language.\n *\n * In terms of querying, numbers in JSON strings are treated as either\n * Long or Double in the Java side. Strings, booleans and null\n * are treated as their Java counterparts.\n *\n * HazelcastJsonValue keeps given string as it is. Strings are not\n * checked for being valid. Ill-formatted json strings may cause false\n * positive or false negative results in queries.\n *\n * Important note: `null` values are not allowed.\n */\nclass HazelcastJsonValue {\n    /**\n     * Creates a HazelcastJsonValue from given string.\n     * @param jsonString a non null Json string\n     */\n    constructor(jsonString) {\n        Util_1.assertString(jsonString);\n        this.jsonString = jsonString;\n    }\n    /**\n     * Returns unaltered string that was used to create this object.\n     * @return original string\n     */\n    toString() {\n        return this.jsonString;\n    }\n}\nexports.HazelcastJsonValue = HazelcastJsonValue;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/HazelcastJsonValue.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/LoadBalancer.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/LoadBalancer.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractLoadBalancer = void 0;\n/**\n * Abstract Load Balancer to be used in built-in and user-provided\n * {@link LoadBalancer} implementations.\n */\nclass AbstractLoadBalancer {\n    initLoadBalancer(cluster, config) {\n        this.cluster = cluster;\n        cluster.addMembershipListener(this);\n    }\n    init(event) {\n        this.setMembers();\n    }\n    memberAdded(membership) {\n        this.setMembers();\n    }\n    memberRemoved(membership) {\n        this.setMembers();\n    }\n    getMembers() {\n        return this.members;\n    }\n    setMembers() {\n        this.members = this.cluster.getMembers();\n    }\n}\nexports.AbstractLoadBalancer = AbstractLoadBalancer;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/LoadBalancer.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/Member.js":
/*!******************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/Member.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemberImpl = void 0;\n/** @internal */\nclass MemberImpl {\n    constructor(address, uuid, attributes, liteMember, version) {\n        this.address = address;\n        this.uuid = uuid;\n        this.attributes = attributes;\n        this.liteMember = liteMember;\n        this.version = version;\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        if (!this.address.equals(other.address)) {\n            return false;\n        }\n        return this.uuid != null ? this.uuid.equals(other.uuid) : other.uuid === null;\n    }\n    toString() {\n        let memberStr = 'Member ['\n            + this.address.host\n            + ']:'\n            + this.address.port\n            + ' - '\n            + this.uuid.toString();\n        if (this.liteMember) {\n            memberStr += ' lite';\n        }\n        return memberStr;\n    }\n    id() {\n        let hashCode = this.address.toString();\n        if (this.uuid) {\n            hashCode += this.uuid.toString();\n        }\n        return hashCode;\n    }\n}\nexports.MemberImpl = MemberImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/Member.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/MemberInfo.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/MemberInfo.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemberInfo = void 0;\n/** @internal */\nclass MemberInfo {\n    constructor(address, uuid, attributes, liteMember, version) {\n        this.address = address;\n        this.uuid = uuid;\n        this.attributes = attributes;\n        this.liteMember = liteMember;\n        this.version = version;\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        if (!this.address.equals(other.address)) {\n            return false;\n        }\n        return this.uuid != null ? this.uuid.equals(other.uuid) : other.uuid === null;\n    }\n    toString() {\n        return 'Member[uuid: ' + this.uuid.toString()\n            + ', address: ' + this.address.toString()\n            + ', liteMember: ' + this.liteMember\n            + ', memberListJoinVersion' + this.version + ']';\n    }\n}\nexports.MemberInfo = MemberInfo;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/MemberInfo.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/MemberSelector.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/MemberSelector.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dataMemberSelector = void 0;\n/** @internal */\nexports.dataMemberSelector = (member) => !member.liteMember;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/MemberSelector.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/MemberVersion.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/MemberVersion.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemberVersion = void 0;\n/** @internal */\nclass MemberVersion {\n    constructor(major, minor, patch) {\n        this.major = major;\n        this.minor = minor;\n        this.patch = patch;\n    }\n}\nexports.MemberVersion = MemberVersion;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/MemberVersion.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/MembershipListener.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/MembershipListener.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InitialMembershipEvent = exports.MemberEvent = exports.MembershipEvent = void 0;\n/**\n * Membership event fired when a new member is added to the cluster and/or\n * when a member leaves the cluster or when there is a member attribute change.\n */\nclass MembershipEvent {\n    /** @internal */\n    constructor(member, eventType, members) {\n        this.member = member;\n        this.eventType = eventType;\n        this.members = members;\n    }\n}\nexports.MembershipEvent = MembershipEvent;\n/** @internal */\nvar MemberEvent;\n(function (MemberEvent) {\n    MemberEvent[MemberEvent[\"ADDED\"] = 1] = \"ADDED\";\n    MemberEvent[MemberEvent[\"REMOVED\"] = 2] = \"REMOVED\";\n})(MemberEvent = exports.MemberEvent || (exports.MemberEvent = {}));\n/**\n * An event that is sent when a {@link InitialMembershipListener} registers itself on a cluster.\n *\n * @see MembershipListener\n * @see MembershipEvent\n */\nclass InitialMembershipEvent {\n    /** @internal */\n    constructor(members) {\n        this.members = members;\n    }\n}\nexports.InitialMembershipEvent = InitialMembershipEvent;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/MembershipListener.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/PartitionAware.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/PartitionAware.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/PartitionAware.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/Predicate.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/Predicate.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryConstants = exports.iterationTypeToId = exports.IterationType = exports.paging = exports.alwaysFalse = exports.alwaysTrue = exports.regex = exports.or = exports.not = exports.notEqual = exports.instanceOf = exports.inPredicate = exports.ilike = exports.like = exports.lessEqual = exports.lessThan = exports.greaterEqual = exports.greaterThan = exports.equal = exports.between = exports.and = exports.sql = void 0;\nconst DefaultPredicates_1 = __webpack_require__(/*! ../serialization/DefaultPredicates */ \"../shared/node_modules/hazelcast-client/lib/serialization/DefaultPredicates.js\");\nfunction sql(str) {\n    return new DefaultPredicates_1.SqlPredicate(str);\n}\nexports.sql = sql;\nfunction and(...predicates) {\n    return new DefaultPredicates_1.AndPredicate(...predicates);\n}\nexports.and = and;\nfunction between(field, from, to) {\n    return new DefaultPredicates_1.BetweenPredicate(field, from, to);\n}\nexports.between = between;\nfunction equal(field, value) {\n    return new DefaultPredicates_1.EqualPredicate(field, value);\n}\nexports.equal = equal;\nfunction greaterThan(field, value) {\n    return new DefaultPredicates_1.GreaterLessPredicate(field, value, false, false);\n}\nexports.greaterThan = greaterThan;\nfunction greaterEqual(field, value) {\n    return new DefaultPredicates_1.GreaterLessPredicate(field, value, true, false);\n}\nexports.greaterEqual = greaterEqual;\nfunction lessThan(field, value) {\n    return new DefaultPredicates_1.GreaterLessPredicate(field, value, false, true);\n}\nexports.lessThan = lessThan;\nfunction lessEqual(field, value) {\n    return new DefaultPredicates_1.GreaterLessPredicate(field, value, true, true);\n}\nexports.lessEqual = lessEqual;\nfunction like(field, expr) {\n    return new DefaultPredicates_1.LikePredicate(field, expr);\n}\nexports.like = like;\nfunction ilike(field, expr) {\n    return new DefaultPredicates_1.ILikePredicate(field, expr);\n}\nexports.ilike = ilike;\nfunction inPredicate(field, ...values) {\n    return new DefaultPredicates_1.InPredicate(field, ...values);\n}\nexports.inPredicate = inPredicate;\nfunction instanceOf(className) {\n    return new DefaultPredicates_1.InstanceOfPredicate(className);\n}\nexports.instanceOf = instanceOf;\nfunction notEqual(field, value) {\n    return new DefaultPredicates_1.NotEqualPredicate(field, value);\n}\nexports.notEqual = notEqual;\nfunction not(predicate) {\n    return new DefaultPredicates_1.NotPredicate(predicate);\n}\nexports.not = not;\nfunction or(...predicates) {\n    return new DefaultPredicates_1.OrPredicate(...predicates);\n}\nexports.or = or;\nfunction regex(field, reg) {\n    return new DefaultPredicates_1.RegexPredicate(field, reg);\n}\nexports.regex = regex;\nfunction alwaysTrue() {\n    return DefaultPredicates_1.TruePredicate.INSTANCE;\n}\nexports.alwaysTrue = alwaysTrue;\nfunction alwaysFalse() {\n    return DefaultPredicates_1.FalsePredicate.INSTANCE;\n}\nexports.alwaysFalse = alwaysFalse;\nfunction paging(predicate, pageSize, comparator = null) {\n    return new DefaultPredicates_1.PagingPredicateImpl(predicate, pageSize, comparator);\n}\nexports.paging = paging;\n/**\n * Iteration type.\n * @internal\n */\nvar IterationType;\n(function (IterationType) {\n    /**\n     * Iterate over keys.\n     */\n    IterationType[\"KEY\"] = \"KEY\";\n    /**\n     * Iterate over values.\n     */\n    IterationType[\"VALUE\"] = \"VALUE\";\n    /**\n     * Iterate over whole entry (so key and value).\n     */\n    IterationType[\"ENTRY\"] = \"ENTRY\";\n})(IterationType = exports.IterationType || (exports.IterationType = {}));\n/** @internal */\nexports.iterationTypeToId = (type) => {\n    switch (type) {\n        case IterationType.KEY:\n            return 0;\n        case IterationType.VALUE:\n            return 1;\n        case IterationType.ENTRY:\n            return 2;\n        default:\n            throw new TypeError('Unexpected type value: ' + type);\n    }\n};\n/** @internal */\nvar QueryConstants;\n(function (QueryConstants) {\n    /**\n     * Attribute name of the key.\n     */\n    QueryConstants[\"KEY_ATTRIBUTE_NAME\"] = \"__key\";\n    /**\n     * Attribute name of the \"this\".\n     */\n    QueryConstants[\"THIS_ATTRIBUTE_NAME\"] = \"this\";\n})(QueryConstants = exports.QueryConstants || (exports.QueryConstants = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/Predicate.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/ReadOnlyLazyList.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/ReadOnlyLazyList.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadOnlyLazyList = void 0;\nclass ReadOnlyLazyListIterator {\n    constructor(list) {\n        this.index = 0;\n        this.list = list;\n    }\n    next() {\n        if (this.index < this.list.size()) {\n            return { done: false, value: this.list.get(this.index++) };\n        }\n        else {\n            return { done: true, value: undefined };\n        }\n    }\n}\n/**\n * Represents a list of values with lazy deserialization.\n */\nclass ReadOnlyLazyList {\n    /** @internal */\n    constructor(array, serializationService) {\n        this.internalArray = array;\n        this.serializationService = serializationService;\n    }\n    /**\n     * Returns list's element at the specified index.\n     *\n     * @param index element's index\n     * @returns element\n     */\n    get(index) {\n        const dataOrObject = this.internalArray[index];\n        if (dataOrObject == null) {\n            return undefined;\n        }\n        if (this.serializationService.isData(dataOrObject)) {\n            const obj = this.serializationService.toObject(dataOrObject);\n            this.internalArray[index] = obj;\n            return obj;\n        }\n        else {\n            return dataOrObject;\n        }\n    }\n    /**\n     * Returns the size of the list.\n     */\n    size() {\n        return this.internalArray.length;\n    }\n    /**\n     * Returns an iterator for elements in the list.\n     */\n    values() {\n        return new ReadOnlyLazyListIterator(this);\n    }\n    /**\n     * Returns a slice of the list.\n     *\n     * @param start The beginning of the specified portion of the list (inclusive).\n     * @param end The end of the specified portion of the list (exclusive).\n     */\n    slice(start, end) {\n        return new ReadOnlyLazyList(this.internalArray.slice(start, end), this.serializationService);\n    }\n    /**\n     * Returns an array that contains all elements of this list in proper sequence.\n     */\n    toArray() {\n        const arr = [];\n        const iterator = this.values();\n        for (let item = iterator.next(); !item.done; item = iterator.next()) {\n            arr.push(item.value);\n        }\n        return arr;\n    }\n    [Symbol.iterator]() {\n        return this.values();\n    }\n}\nexports.ReadOnlyLazyList = ReadOnlyLazyList;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/ReadOnlyLazyList.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/ReadResultSet.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/ReadResultSet.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SEQUENCE_UNAVAILABLE = void 0;\nexports.SEQUENCE_UNAVAILABLE = -1;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/ReadResultSet.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/RestValue.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/RestValue.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.restValueFactory = exports.RestValue = exports.REST_VALUE_CLASS_ID = exports.REST_VALUE_FACTORY_ID = void 0;\n/** @internal */\nexports.REST_VALUE_FACTORY_ID = -25;\n/** @internal */\nexports.REST_VALUE_CLASS_ID = 1;\n/**\n * Wrapper for values stored via IMDG REST API.\n */\nclass RestValue {\n    constructor() {\n        /** @ignore */\n        this.factoryId = exports.REST_VALUE_FACTORY_ID;\n        /** @ignore */\n        this.classId = exports.REST_VALUE_CLASS_ID;\n    }\n    /** @ignore */\n    readData(input) {\n        this.value = input.readUTF();\n        this.contentType = input.readUTF();\n    }\n    /** @ignore */\n    writeData(output) {\n        output.writeUTF(this.value);\n        output.writeUTF(this.contentType);\n    }\n}\nexports.RestValue = RestValue;\n/** @internal */\nfunction restValueFactory(classId) {\n    if (classId === exports.REST_VALUE_CLASS_ID) {\n        return new RestValue();\n    }\n    return null;\n}\nexports.restValueFactory = restValueFactory;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/RestValue.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/SimpleEntryView.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/SimpleEntryView.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleEntryView = void 0;\n/**\n * Represents a view of a map entry.\n */\nclass SimpleEntryView {\n    /** @internal */\n    constructor(key, value, cost, creationTime, expirationTime, hits, lastAccessTime, lastStoredTime, lastUpdateTime, version, ttl, maxIdle) {\n        this.key = key;\n        this.value = value;\n        this.cost = cost;\n        this.creationTime = creationTime;\n        this.expirationTime = expirationTime;\n        this.hits = hits;\n        this.lastAccessTime = lastAccessTime;\n        this.lastStoredTime = lastStoredTime;\n        this.lastUpdateTime = lastUpdateTime;\n        this.version = version;\n        this.ttl = ttl;\n        this.maxIdle = maxIdle;\n    }\n}\nexports.SimpleEntryView = SimpleEntryView;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/SimpleEntryView.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/UUID.js":
/*!****************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/UUID.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UUID = void 0;\n/**\n * Represents UUIDs used by Hazelcast client. A UUID represents a 128-bit value.\n */\nclass UUID {\n    constructor(mostSig, leastSig) {\n        this.mostSignificant = mostSig;\n        this.leastSignificant = leastSig;\n    }\n    /** @internal */\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        return other.mostSignificant.equals(this.mostSignificant) && other.leastSignificant.equals(this.leastSignificant);\n    }\n    toString() {\n        if (this.cachedString) {\n            return this.cachedString;\n        }\n        const mostHigh = this.mostSignificant.getHighBitsUnsigned(); // (32) 32 32 32\n        const mostLow = this.mostSignificant.getLowBitsUnsigned(); // 32 (32) 32 32\n        const leastHigh = this.leastSignificant.getHighBitsUnsigned(); // 32 32 (32) 32\n        const leastLow = this.leastSignificant.getLowBitsUnsigned(); // 32 32 32 (32)\n        const div1 = mostHigh.toString(16);\n        const div2 = (mostLow >>> 16).toString(16);\n        const div3 = (mostLow & ((1 << 16) - 1)).toString(16);\n        const div4 = (leastHigh >>> 16).toString(16);\n        const div5 = (leastHigh & ((1 << 16) - 1)).toString(16) + leastLow.toString(16).padStart(8, '0');\n        this.cachedString = div1.padStart(8, '0') + '-'\n            + div2.padStart(4, '0') + '-'\n            + div3.padStart(4, '0') + '-'\n            + div4.padStart(4, '0') + '-'\n            + div5.padStart(12, '0');\n        return this.cachedString;\n    }\n}\nexports.UUID = UUID;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/UUID.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/core/index.js":
/*!*****************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/core/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Public API re-exports.\n */\n__exportStar(__webpack_require__(/*! ./Address */ \"../shared/node_modules/hazelcast-client/lib/core/Address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ClientInfo */ \"../shared/node_modules/hazelcast-client/lib/core/ClientInfo.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Cluster */ \"../shared/node_modules/hazelcast-client/lib/core/Cluster.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Comparator */ \"../shared/node_modules/hazelcast-client/lib/core/Comparator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./DistributedObject */ \"../shared/node_modules/hazelcast-client/lib/core/DistributedObject.js\"), exports);\n__exportStar(__webpack_require__(/*! ./DistributedObjectListener */ \"../shared/node_modules/hazelcast-client/lib/core/DistributedObjectListener.js\"), exports);\n__exportStar(__webpack_require__(/*! ./HazelcastError */ \"../shared/node_modules/hazelcast-client/lib/core/HazelcastError.js\"), exports);\n__exportStar(__webpack_require__(/*! ./HazelcastJsonValue */ \"../shared/node_modules/hazelcast-client/lib/core/HazelcastJsonValue.js\"), exports);\n__exportStar(__webpack_require__(/*! ./LoadBalancer */ \"../shared/node_modules/hazelcast-client/lib/core/LoadBalancer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Member */ \"../shared/node_modules/hazelcast-client/lib/core/Member.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MemberSelector */ \"../shared/node_modules/hazelcast-client/lib/core/MemberSelector.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MembershipListener */ \"../shared/node_modules/hazelcast-client/lib/core/MembershipListener.js\"), exports);\n__exportStar(__webpack_require__(/*! ./PartitionAware */ \"../shared/node_modules/hazelcast-client/lib/core/PartitionAware.js\"), exports);\nexports.Predicates = __webpack_require__(/*! ./Predicate */ \"../shared/node_modules/hazelcast-client/lib/core/Predicate.js\");\n__exportStar(__webpack_require__(/*! ./ReadOnlyLazyList */ \"../shared/node_modules/hazelcast-client/lib/core/ReadOnlyLazyList.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ReadResultSet */ \"../shared/node_modules/hazelcast-client/lib/core/ReadResultSet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./RestValue */ \"../shared/node_modules/hazelcast-client/lib/core/RestValue.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SimpleEntryView */ \"../shared/node_modules/hazelcast-client/lib/core/SimpleEntryView.js\"), exports);\n__exportStar(__webpack_require__(/*! ./UUID */ \"../shared/node_modules/hazelcast-client/lib/core/UUID.js\"), exports);\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/core/index.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/discovery/HazelcastCloudAddressProvider.js":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/discovery/HazelcastCloudAddressProvider.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HazelcastCloudAddressProvider = void 0;\nconst HazelcastCloudDiscovery_1 = __webpack_require__(/*! ./HazelcastCloudDiscovery */ \"../shared/node_modules/hazelcast-client/lib/discovery/HazelcastCloudDiscovery.js\");\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\n/** @internal */\nclass HazelcastCloudAddressProvider {\n    constructor(endpointUrl, connectionTimeoutMillis, logger) {\n        this.privateToPublic = new Map();\n        this.cloudDiscovery = new HazelcastCloudDiscovery_1.HazelcastCloudDiscovery(endpointUrl, connectionTimeoutMillis);\n        this.logger = logger;\n    }\n    loadAddresses() {\n        return this.cloudDiscovery.discoverNodes().then((res) => {\n            return Array.from(res.keys());\n        }).catch((e) => {\n            this.logger.warn('HazelcastCloudAddressProvider', 'Failed to load addresses from hazelcast.cloud : ' + e.message);\n            return [];\n        });\n    }\n    translate(address) {\n        if (address == null) {\n            return Promise.resolve(null);\n        }\n        let publicAddress = this.privateToPublic.get(address.toString());\n        if (publicAddress != null) {\n            return Promise.resolve(publicAddress);\n        }\n        return this.refresh().then(() => {\n            publicAddress = this.privateToPublic.get(address.toString());\n            if (publicAddress != null) {\n                return publicAddress;\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    refresh() {\n        return this.cloudDiscovery.discoverNodes().then((res) => {\n            this.privateToPublic = res;\n        }).catch((e) => {\n            this.logger.warn('HazelcastCloudAddressTranslator', 'Failed to load addresses from hazelcast.cloud : ' + e.message);\n        });\n    }\n}\nexports.HazelcastCloudAddressProvider = HazelcastCloudAddressProvider;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/discovery/HazelcastCloudAddressProvider.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/discovery/HazelcastCloudDiscovery.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/discovery/HazelcastCloudDiscovery.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HazelcastCloudDiscovery = void 0;\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst https_1 = __webpack_require__(/*! https */ \"https\");\nconst URL = __webpack_require__(/*! url */ \"url\");\n/**\n * Discovery service that discover nodes via hazelcast.cloud\n * https://coordinator.hazelcast.cloud/cluster/discovery?token=<TOKEN>\n * @internal\n */\nclass HazelcastCloudDiscovery {\n    constructor(endpointUrl, connectionTimeoutInMillis) {\n        this.endpointUrl = endpointUrl;\n        this.connectionTimeoutMillis = connectionTimeoutInMillis;\n    }\n    static createUrlEndpoint(properties, cloudToken) {\n        const cloudBaseUrl = properties[HazelcastCloudDiscovery.CLOUD_URL_BASE_PROPERTY];\n        return cloudBaseUrl + this.CLOUD_URL_PATH + cloudToken;\n    }\n    discoverNodes() {\n        return this.callService().catch((e) => {\n            throw e;\n        });\n    }\n    callService() {\n        const deferred = Util_1.DeferredPromise();\n        const url = URL.parse(this.endpointUrl);\n        const endpointUrlOptions = {\n            host: url.host,\n            path: url.path,\n            timeout: this.connectionTimeoutMillis,\n        };\n        let dataAsAString = '';\n        https_1.get(endpointUrlOptions, (res) => {\n            res.setEncoding('utf8');\n            res.on('data', (chunk) => {\n                dataAsAString += chunk;\n            });\n            res.on('end', () => {\n                deferred.resolve(this.parseResponse(dataAsAString));\n            });\n        }).on('error', (e) => {\n            deferred.reject(e);\n        });\n        return deferred.promise;\n    }\n    parseResponse(data) {\n        const jsonValue = JSON.parse(data);\n        const privateToPublicAddresses = new Map();\n        for (const value of jsonValue) {\n            const privateAddress = value[HazelcastCloudDiscovery.PRIVATE_ADDRESS_PROPERTY];\n            const publicAddress = value[HazelcastCloudDiscovery.PUBLIC_ADDRESS_PROPERTY];\n            const publicAddr = Util_1.AddressHelper.createAddressFromString(publicAddress.toString(), -1);\n            // If not explicitly given, create the private address with the public addresses port\n            const privateAddr = Util_1.AddressHelper.createAddressFromString(privateAddress.toString(), publicAddr.port);\n            privateToPublicAddresses.set(privateAddr.toString(), publicAddr);\n        }\n        return privateToPublicAddresses;\n    }\n}\nexports.HazelcastCloudDiscovery = HazelcastCloudDiscovery;\n/**\n * Internal client property to change base url of cloud discovery endpoint.\n * Used for testing cloud discovery.\n */\nHazelcastCloudDiscovery.CLOUD_URL_BASE_PROPERTY = 'hazelcast.client.cloud.url';\nHazelcastCloudDiscovery.CLOUD_URL_PATH = '/cluster/discovery?token=';\nHazelcastCloudDiscovery.PRIVATE_ADDRESS_PROPERTY = 'private-address';\nHazelcastCloudDiscovery.PUBLIC_ADDRESS_PROPERTY = 'public-address';\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/discovery/HazelcastCloudDiscovery.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/index.js":
/*!************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Public API re-exports.\n */\n__exportStar(__webpack_require__(/*! ./aggregation */ \"../shared/node_modules/hazelcast-client/lib/aggregation/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./config */ \"../shared/node_modules/hazelcast-client/lib/config/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./connection */ \"../shared/node_modules/hazelcast-client/lib/connection/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./logging */ \"../shared/node_modules/hazelcast-client/lib/logging/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./proxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./serialization */ \"../shared/node_modules/hazelcast-client/lib/serialization/index.js\"), exports);\nvar HazelcastClient_1 = __webpack_require__(/*! ./HazelcastClient */ \"../shared/node_modules/hazelcast-client/lib/HazelcastClient.js\");\nObject.defineProperty(exports, \"Client\", { enumerable: true, get: function () { return HazelcastClient_1.HazelcastClient; } });\n__exportStar(__webpack_require__(/*! ./LifecycleService */ \"../shared/node_modules/hazelcast-client/lib/LifecycleService.js\"), exports);\n__exportStar(__webpack_require__(/*! ./PartitionService */ \"../shared/node_modules/hazelcast-client/lib/PartitionService.js\"), exports);\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/index.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/invocation/ClientEventRegistration.js":
/*!*****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/invocation/ClientEventRegistration.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientEventRegistration = void 0;\n/** @internal */\nclass ClientEventRegistration {\n    constructor(serverRegistrationId, correlationId, subscriber, codec) {\n        this.serverRegistrationId = serverRegistrationId;\n        this.correlationId = correlationId;\n        this.subscriber = subscriber;\n        this.codec = codec;\n    }\n    toString() {\n        return this.serverRegistrationId.toString();\n    }\n}\nexports.ClientEventRegistration = ClientEventRegistration;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/invocation/ClientEventRegistration.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/invocation/ClusterService.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/invocation/ClusterService.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClusterService = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst UuidUtil_1 = __webpack_require__(/*! ../util/UuidUtil */ \"../shared/node_modules/hazelcast-client/lib/util/UuidUtil.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nclass MemberListSnapshot {\n    constructor(version, members, memberList) {\n        this.version = version;\n        this.members = members;\n        this.memberList = memberList;\n    }\n}\nconst EMPTY_SNAPSHOT = new MemberListSnapshot(-1, new Map(), []);\nconst INITIAL_MEMBERS_TIMEOUT_IN_MILLIS = 120 * 1000; // 120 seconds\n/**\n * Manages the relationship of this client with the cluster.\n * @internal\n */\nclass ClusterService {\n    constructor(client) {\n        this.memberListSnapshot = EMPTY_SNAPSHOT;\n        this.listeners = new Map();\n        this.initialListFetched = Util_1.DeferredPromise();\n        this.client = client;\n        this.labels = new Set(client.getConfig().clientLabels);\n        this.logger = client.getLoggingService().getLogger();\n        this.connectionManager = client.getConnectionManager();\n    }\n    /**\n     * Gets the member with the given UUID.\n     *\n     * @param uuid The UUID of the member.\n     * @return The member that was found, or undefined if not found.\n     */\n    getMember(uuid) {\n        Util_1.assertNotNull(uuid);\n        return this.memberListSnapshot.members.get(uuid.toString());\n    }\n    getMembers(selector) {\n        const members = this.getMemberList();\n        if (selector == null) {\n            return members;\n        }\n        const selectedMembers = [];\n        members.forEach((member) => {\n            if (selector(member)) {\n                selectedMembers.push(member);\n            }\n        });\n        return selectedMembers;\n    }\n    /**\n     * Gets the current number of members.\n     *\n     * @return The current number of members.\n     */\n    getSize() {\n        return this.memberListSnapshot.members.size;\n    }\n    /**\n     * @return The {@link ClientInfo} instance representing the local client.\n     */\n    getLocalClient() {\n        const connectionManager = this.client.getConnectionManager();\n        const connection = connectionManager.getRandomConnection();\n        const localAddress = connection != null ? connection.getLocalAddress() : null;\n        const info = new core_1.ClientInfo();\n        info.uuid = connectionManager.getClientUuid();\n        info.localAddress = localAddress;\n        info.labels = this.labels;\n        info.name = this.client.getName();\n        return info;\n    }\n    addMembershipListener(listener) {\n        Util_1.assertNotNull(listener);\n        const registrationId = UuidUtil_1.UuidUtil.generate().toString();\n        this.listeners.set(registrationId, listener);\n        if (this.isInitialMembershipListener(listener)) {\n            const members = this.getMemberList();\n            // if members are empty,it means initial event did not arrive yet\n            // it will be redirected to listeners when it arrives see #handleInitialMembershipEvent\n            if (members.length !== 0) {\n                const event = new core_1.InitialMembershipEvent(members);\n                listener.init(event);\n            }\n        }\n        return registrationId;\n    }\n    removeMembershipListener(listenerId) {\n        Util_1.assertNotNull(listenerId);\n        return this.listeners.delete(listenerId);\n    }\n    start(configuredListeners) {\n        for (const listener of configuredListeners) {\n            this.addMembershipListener(listener);\n        }\n    }\n    waitInitialMemberListFetched() {\n        return this.initialListFetched.promise\n            .timeout(INITIAL_MEMBERS_TIMEOUT_IN_MILLIS)\n            .catch((error) => {\n            return Promise.reject(new core_1.IllegalStateError('Could not get initial member list from the cluster!', error));\n        });\n    }\n    clearMemberListVersion() {\n        this.logger.trace('ClusterService', 'Resetting the member list version');\n        if (this.memberListSnapshot !== EMPTY_SNAPSHOT) {\n            this.memberListSnapshot.version = 0;\n        }\n    }\n    reset() {\n        this.logger.trace('ClusterService', 'Resetting the cluster snapshot');\n        this.initialListFetched = Util_1.DeferredPromise();\n        this.memberListSnapshot = EMPTY_SNAPSHOT;\n    }\n    handleMembersViewEvent(memberListVersion, memberInfos) {\n        if (this.memberListSnapshot === EMPTY_SNAPSHOT) {\n            this.applyInitialState(memberListVersion, memberInfos);\n            this.initialListFetched.resolve();\n            return;\n        }\n        if (memberListVersion >= this.memberListSnapshot.version) {\n            const prevMembers = this.memberListSnapshot.memberList;\n            const snapshot = this.createSnapshot(memberListVersion, memberInfos);\n            this.memberListSnapshot = snapshot;\n            const currentMembers = snapshot.memberList;\n            const events = this.detectMembershipEvents(prevMembers, currentMembers);\n            this.fireEvents(events);\n        }\n    }\n    fireEvents(events) {\n        for (const event of events) {\n            this.listeners.forEach((listener) => {\n                if (event.eventType === core_1.MemberEvent.ADDED && listener.memberAdded) {\n                    listener.memberAdded(event);\n                }\n                else if (event.eventType === core_1.MemberEvent.REMOVED && listener.memberRemoved) {\n                    listener.memberRemoved(event);\n                }\n            });\n        }\n    }\n    isInitialMembershipListener(listener) {\n        return listener.init !== undefined;\n    }\n    applyInitialState(memberListVersion, memberInfos) {\n        const snapshot = this.createSnapshot(memberListVersion, memberInfos);\n        this.memberListSnapshot = snapshot;\n        this.logger.info('ClusterService', this.membersString(snapshot));\n        const members = snapshot.memberList;\n        const event = new core_1.InitialMembershipEvent(members);\n        this.listeners.forEach((listener) => {\n            if (this.isInitialMembershipListener(listener)) {\n                listener.init(event);\n            }\n        });\n    }\n    detectMembershipEvents(prevMembers, currentMembers) {\n        const newMembers = new Array();\n        const deadMembers = new Map();\n        for (const member of prevMembers) {\n            deadMembers.set(member.id(), member);\n        }\n        for (const member of currentMembers) {\n            if (!deadMembers.delete(member.id())) {\n                newMembers.push(member);\n            }\n        }\n        const events = new Array(deadMembers.size + newMembers.length);\n        let index = 0;\n        // removal events should be added before added events\n        deadMembers.forEach((member) => {\n            events[index++] = new core_1.MembershipEvent(member, core_1.MemberEvent.REMOVED, currentMembers);\n            const connection = this.connectionManager.getConnection(member.uuid);\n            if (connection != null) {\n                connection.close(null, new core_1.TargetDisconnectedError('The client has closed the connection to this ' +\n                    'member, after receiving a member left event from the cluster ' + connection));\n            }\n        });\n        for (const member of newMembers) {\n            events[index++] = new core_1.MembershipEvent(member, core_1.MemberEvent.ADDED, currentMembers);\n        }\n        if (events.length !== 0) {\n            if (this.memberListSnapshot.members.size !== 0) {\n                this.logger.info('ClusterService', this.membersString(this.memberListSnapshot));\n            }\n        }\n        return events;\n    }\n    createSnapshot(memberListVersion, memberInfos) {\n        const newMembers = new Map();\n        const newMemberList = new Array(memberInfos.length);\n        let index = 0;\n        for (const memberInfo of memberInfos) {\n            const member = new core_1.MemberImpl(memberInfo.address, memberInfo.uuid, memberInfo.attributes, memberInfo.liteMember, memberInfo.version);\n            newMembers.set(memberInfo.uuid.toString(), member);\n            newMemberList[index++] = member;\n        }\n        return new MemberListSnapshot(memberListVersion, newMembers, newMemberList);\n    }\n    membersString(snapshot) {\n        const members = snapshot.memberList;\n        let logString = '\\n\\nMembers [' + members.length + '] {';\n        for (const member of members) {\n            logString += '\\n\\t' + member.toString();\n        }\n        logString += '\\n}\\n';\n        return logString;\n    }\n    getMemberList() {\n        return this.memberListSnapshot.memberList;\n    }\n}\nexports.ClusterService = ClusterService;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/invocation/ClusterService.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InvocationService = exports.Invocation = void 0;\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst ClientLocalBackupListenerCodec_1 = __webpack_require__(/*! ../codec/ClientLocalBackupListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientLocalBackupListenerCodec.js\");\nconst ErrorsCodec_1 = __webpack_require__(/*! ../codec/builtin/ErrorsCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ErrorsCodec.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst MAX_FAST_INVOCATION_COUNT = 5;\nconst PROPERTY_INVOCATION_RETRY_PAUSE_MILLIS = 'hazelcast.client.invocation.retry.pause.millis';\nconst PROPERTY_INVOCATION_TIMEOUT_MILLIS = 'hazelcast.client.invocation.timeout.millis';\nconst PROPERTY_CLEAN_RESOURCES_MILLIS = 'hazelcast.client.internal.clean.resources.millis';\nconst PROPERTY_BACKUP_TIMEOUT_MILLIS = 'hazelcast.client.operation.backup.timeout.millis';\nconst PROPERTY_FAIL_ON_INDETERMINATE_STATE = 'hazelcast.client.operation.fail.on.indeterminate.state';\n/**\n * A request to be sent to a hazelcast node.\n * @internal\n */\nclass Invocation {\n    constructor(client, request) {\n        /**\n         * Number of backups acks received.\n         */\n        this.backupsAcksReceived = 0;\n        /**\n         * Number of expected backups. It is set correctly as soon as the pending response is set.\n         */\n        this.backupsAcksExpected = -1;\n        /**\n         * The time in millis when the response of the primary has been received.\n         */\n        this.pendingResponseReceivedMillis = -1;\n        this.invokeCount = 0;\n        /**\n         * True if this invocation is urgent (can be invoked even in the client is in the disconnected state), false otherwise.\n         */\n        this.urgent = false;\n        this.client = client;\n        this.invocationService = client.getInvocationService();\n        this.deadline = Date.now() + this.invocationService.invocationTimeoutMillis;\n        this.request = request;\n    }\n    /**\n     * @returns {boolean}\n     */\n    hasPartitionId() {\n        return this.hasOwnProperty('partitionId') && this.partitionId >= 0;\n    }\n    shouldRetry(err) {\n        if (this.connection != null\n            && (err instanceof core_1.IOError || err instanceof core_1.TargetDisconnectedError)) {\n            return false;\n        }\n        if (this.uuid != null && err instanceof core_1.TargetNotMemberError) {\n            // when invocation is sent to a specific member\n            // and target is no longer a member, we should not retry\n            // note that this exception could come from the server\n            return false;\n        }\n        if (err instanceof core_1.IOError\n            || err instanceof core_1.HazelcastInstanceNotActiveError\n            || err instanceof core_1.RetryableHazelcastError) {\n            return true;\n        }\n        if (err instanceof core_1.TargetDisconnectedError) {\n            return this.request.isRetryable();\n        }\n        return false;\n    }\n    notify(clientMessage) {\n        assert(clientMessage != null, 'Response can not be null');\n        const expectedBackups = clientMessage.getNumberOfBackupAcks();\n        if (expectedBackups > this.backupsAcksReceived) {\n            this.pendingResponseReceivedMillis = Date.now();\n            this.backupsAcksExpected = expectedBackups;\n            this.pendingResponseMessage = clientMessage;\n            return;\n        }\n        this.complete(clientMessage);\n    }\n    notifyBackupComplete() {\n        this.backupsAcksReceived++;\n        if (this.pendingResponseMessage == null) {\n            return;\n        }\n        if (this.backupsAcksExpected !== this.backupsAcksReceived) {\n            return;\n        }\n        this.complete(this.pendingResponseMessage);\n    }\n    detectAndHandleBackupTimeout(timeoutMillis) {\n        if (this.pendingResponseMessage == null) {\n            return;\n        }\n        if (this.backupsAcksExpected === this.backupsAcksReceived) {\n            return;\n        }\n        const expirationTime = this.pendingResponseReceivedMillis + timeoutMillis;\n        const timeoutReached = expirationTime > 0 && expirationTime < Date.now();\n        if (!timeoutReached) {\n            return;\n        }\n        if (this.invocationService.shouldFailOnIndeterminateState) {\n            this.completeWithError(new core_1.IndeterminateOperationStateError('Invocation '\n                + this.request.getCorrelationId() + ' failed because of missed backup acks'));\n            return;\n        }\n        this.complete(this.pendingResponseMessage);\n    }\n    complete(clientMessage) {\n        this.deferred.resolve(clientMessage);\n        this.invocationService.deregisterInvocation(this.request.getCorrelationId());\n    }\n    completeWithError(err) {\n        this.deferred.reject(err);\n        this.invocationService.deregisterInvocation(this.request.getCorrelationId());\n    }\n}\nexports.Invocation = Invocation;\nconst backupListenerCodec = {\n    encodeAddRequest(localOnly) {\n        return ClientLocalBackupListenerCodec_1.ClientLocalBackupListenerCodec.encodeRequest();\n    },\n    decodeAddResponse(msg) {\n        return ClientLocalBackupListenerCodec_1.ClientLocalBackupListenerCodec.decodeResponse(msg).response;\n    },\n    encodeRemoveRequest(listenerId) {\n        return null;\n    }\n};\n/**\n * Sends requests to appropriate nodes. Resolves waiting promises with responses.\n * @internal\n */\nclass InvocationService {\n    constructor(client) {\n        this.eventHandlers = new Map();\n        this.pending = new Map();\n        this.correlationCounter = 1;\n        this.client = client;\n        this.connectionManager = client.getConnectionManager();\n        this.partitionService = client.getPartitionService();\n        this.logger = this.client.getLoggingService().getLogger();\n        const config = client.getConfig();\n        if (config.network.smartRouting) {\n            this.doInvoke = this.invokeSmart;\n        }\n        else {\n            this.doInvoke = this.invokeNonSmart;\n        }\n        this.invocationRetryPauseMillis =\n            config.properties[PROPERTY_INVOCATION_RETRY_PAUSE_MILLIS];\n        this.invocationTimeoutMillis =\n            config.properties[PROPERTY_INVOCATION_TIMEOUT_MILLIS];\n        this.operationBackupTimeoutMillis =\n            config.properties[PROPERTY_BACKUP_TIMEOUT_MILLIS];\n        this.shouldFailOnIndeterminateState =\n            config.properties[PROPERTY_FAIL_ON_INDETERMINATE_STATE];\n        this.cleanResourcesMillis =\n            config.properties[PROPERTY_CLEAN_RESOURCES_MILLIS];\n        this.backupAckToClientEnabled = config.network.smartRouting && config.backupAckToClientEnabled;\n        this.isShutdown = false;\n    }\n    start() {\n        if (this.backupAckToClientEnabled) {\n            const listenerService = this.client.getListenerService();\n            listenerService.registerListener(backupListenerCodec, this.backupEventHandler.bind(this));\n            this.cleanResourcesTask = this.scheduleCleanResourcesTask(this.cleanResourcesMillis);\n        }\n    }\n    scheduleCleanResourcesTask(periodMillis) {\n        return Util_1.scheduleWithRepetition(() => {\n            for (const pendingInvocation of this.pending.values()) {\n                pendingInvocation.detectAndHandleBackupTimeout(this.operationBackupTimeoutMillis);\n            }\n        }, periodMillis, periodMillis);\n    }\n    shutdown() {\n        if (this.isShutdown) {\n            return;\n        }\n        this.isShutdown = true;\n        if (this.cleanResourcesTask != null) {\n            Util_1.cancelRepetitionTask(this.cleanResourcesTask);\n        }\n    }\n    invoke(invocation) {\n        invocation.deferred = Util_1.DeferredPromise();\n        const newCorrelationId = this.correlationCounter++;\n        invocation.request.setCorrelationId(newCorrelationId);\n        this.doInvoke(invocation);\n        return invocation.deferred.promise;\n    }\n    invokeUrgent(invocation) {\n        invocation.urgent = true;\n        return this.invoke(invocation);\n    }\n    /**\n     * Invokes given invocation on specified connection.\n     * @param connection\n     * @param request\n     * @param handler called with values returned from server for this invocation.\n     * @returns\n     */\n    invokeOnConnection(connection, request, handler) {\n        const invocation = new Invocation(this.client, request);\n        invocation.connection = connection;\n        if (handler) {\n            invocation.handler = handler;\n        }\n        return this.invoke(invocation);\n    }\n    /**\n     * Invokes given invocation on the node that owns given partition.\n     * @param request\n     * @param partitionId\n     * @returns\n     */\n    invokeOnPartition(request, partitionId) {\n        const invocation = new Invocation(this.client, request);\n        invocation.partitionId = partitionId;\n        return this.invoke(invocation);\n    }\n    /**\n     * Invokes given invocation on the host with given UUID.\n     * @param request\n     * @param target\n     * @returns\n     */\n    invokeOnTarget(request, target) {\n        const invocation = new Invocation(this.client, request);\n        invocation.uuid = target;\n        return this.invoke(invocation);\n    }\n    /**\n     * Invokes given invocation on any host.\n     * Useful when an operation is not bound to any host but a generic operation.\n     * @param request\n     * @returns\n     */\n    invokeOnRandomTarget(request) {\n        return this.invoke(new Invocation(this.client, request));\n    }\n    /**\n     * Removes the handler for all event handlers with a specific correlation id.\n     */\n    removeEventHandler(correlationId) {\n        this.eventHandlers.delete(correlationId);\n    }\n    backupEventHandler(clientMessage) {\n        ClientLocalBackupListenerCodec_1.ClientLocalBackupListenerCodec.handle(clientMessage, (correlationId) => {\n            const invocation = this.pending.get(correlationId.toNumber());\n            if (invocation === undefined) {\n                this.logger.trace('InvocationService', 'Invocation not found for backup event, '\n                    + 'invocation id ' + correlationId);\n                return;\n            }\n            invocation.notifyBackupComplete();\n        });\n    }\n    /**\n     * Extracts codec specific properties in a protocol message and resolves waiting promise.\n     */\n    processResponse(clientMessage) {\n        const correlationId = clientMessage.getCorrelationId();\n        if (clientMessage.startFrame.hasEventFlag() || clientMessage.startFrame.hasBackupEventFlag()) {\n            process.nextTick(() => {\n                const eventHandler = this.eventHandlers.get(correlationId);\n                if (eventHandler !== undefined) {\n                    eventHandler.handler(clientMessage);\n                }\n            });\n            return;\n        }\n        const pendingInvocation = this.pending.get(correlationId);\n        const messageType = clientMessage.getMessageType();\n        if (messageType === ErrorsCodec_1.EXCEPTION_MESSAGE_TYPE) {\n            const remoteError = this.client.getErrorFactory().createErrorFromClientMessage(clientMessage);\n            this.notifyError(pendingInvocation, remoteError);\n        }\n        else {\n            pendingInvocation.notify(clientMessage);\n        }\n    }\n    invokeSmart(invocation) {\n        invocation.invokeCount++;\n        if (!invocation.urgent) {\n            const error = this.connectionManager.checkIfInvocationAllowed();\n            if (error != null) {\n                this.notifyError(invocation, error);\n                return;\n            }\n        }\n        let invocationPromise;\n        if (invocation.hasOwnProperty('connection')) {\n            invocationPromise = this.send(invocation, invocation.connection);\n            invocationPromise.catch((err) => {\n                this.notifyError(invocation, err);\n            });\n            return;\n        }\n        if (invocation.hasPartitionId()) {\n            invocationPromise = this.invokeOnPartitionOwner(invocation, invocation.partitionId);\n        }\n        else if (invocation.hasOwnProperty('uuid')) {\n            invocationPromise = this.invokeOnUuid(invocation, invocation.uuid);\n        }\n        else {\n            invocationPromise = this.invokeOnRandomConnection(invocation);\n        }\n        invocationPromise.catch(() => {\n            return this.invokeOnRandomConnection(invocation);\n        }).catch((err) => {\n            this.notifyError(invocation, err);\n        });\n    }\n    invokeNonSmart(invocation) {\n        invocation.invokeCount++;\n        if (!invocation.urgent) {\n            const error = this.connectionManager.checkIfInvocationAllowed();\n            if (error != null) {\n                this.notifyError(invocation, error);\n                return;\n            }\n        }\n        let invocationPromise;\n        if (invocation.hasOwnProperty('connection')) {\n            invocationPromise = this.send(invocation, invocation.connection);\n        }\n        else {\n            invocationPromise = this.invokeOnRandomConnection(invocation);\n        }\n        invocationPromise.catch((err) => {\n            this.notifyError(invocation, err);\n        });\n    }\n    invokeOnRandomConnection(invocation) {\n        const connection = this.connectionManager.getRandomConnection();\n        if (connection == null) {\n            return Promise.reject(new core_1.IOError('No connection found to invoke'));\n        }\n        return this.send(invocation, connection);\n    }\n    invokeOnUuid(invocation, target) {\n        const connection = this.connectionManager.getConnection(target);\n        if (connection == null) {\n            this.logger.trace('InvocationService', `Client is not connected to target: ${target}`);\n            return Promise.reject(new core_1.IOError('No connection found to invoke'));\n        }\n        return this.send(invocation, connection);\n    }\n    invokeOnPartitionOwner(invocation, partitionId) {\n        const partitionOwner = this.partitionService.getPartitionOwner(partitionId);\n        if (partitionOwner == null) {\n            this.logger.trace('InvocationService', 'Partition owner is not assigned yet');\n            return Promise.reject(new core_1.IOError('No connection found to invoke'));\n        }\n        return this.invokeOnUuid(invocation, partitionOwner);\n    }\n    send(invocation, connection) {\n        assert(connection != null);\n        if (this.isShutdown) {\n            return Promise.reject(new core_1.ClientNotActiveError('Client is shutdown.'));\n        }\n        if (this.backupAckToClientEnabled) {\n            invocation.request.getStartFrame().addFlag(ClientMessage_1.IS_BACKUP_AWARE_FLAG);\n        }\n        this.registerInvocation(invocation);\n        return this.write(invocation, connection);\n    }\n    write(invocation, connection) {\n        return connection.write(invocation.request.toBuffer());\n    }\n    notifyError(invocation, error) {\n        const correlationId = invocation.request.getCorrelationId();\n        if (this.rejectIfNotRetryable(invocation, error)) {\n            this.pending.delete(correlationId);\n            return;\n        }\n        this.logger.debug('InvocationService', 'Retrying(' + invocation.invokeCount + ') on correlation-id=' + correlationId, error);\n        if (invocation.invokeCount < MAX_FAST_INVOCATION_COUNT) {\n            this.doInvoke(invocation);\n        }\n        else {\n            setTimeout(this.doInvoke.bind(this, invocation), this.invocationRetryPauseMillis);\n        }\n    }\n    /**\n     * Determines if an error is retryable. The given invocation is rejected with\n     * appropriate error if the error is not retryable.\n     *\n     * @param invocation\n     * @param error\n     * @returns `true` if invocation is rejected, `false` otherwise\n     */\n    rejectIfNotRetryable(invocation, error) {\n        if (!this.client.getLifecycleService().isRunning()) {\n            invocation.deferred.reject(new core_1.ClientNotActiveError('Client is shutting down.', error));\n            return true;\n        }\n        if (!invocation.shouldRetry(error)) {\n            invocation.deferred.reject(error);\n            return true;\n        }\n        if (invocation.deadline < Date.now()) {\n            this.logger.trace('InvocationService', 'Error will not be retried because invocation timed out');\n            invocation.deferred.reject(new core_1.InvocationTimeoutError('Invocation '\n                + invocation.request.getCorrelationId() + ') reached its deadline.', error));\n            return true;\n        }\n    }\n    registerInvocation(invocation) {\n        const message = invocation.request;\n        const correlationId = message.getCorrelationId();\n        if (invocation.hasPartitionId()) {\n            message.setPartitionId(invocation.partitionId);\n        }\n        else {\n            message.setPartitionId(-1);\n        }\n        if (invocation.hasOwnProperty('handler')) {\n            this.eventHandlers.set(correlationId, invocation);\n        }\n        this.pending.set(correlationId, invocation);\n    }\n    deregisterInvocation(correlationId) {\n        this.pending.delete(correlationId);\n    }\n}\nexports.InvocationService = InvocationService;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/invocation/Murmur.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/invocation/Murmur.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.murmur = void 0;\nconst seed = 0x01000193;\n/** @internal */\nfunction murmur(key) {\n    let h1, h1b, k1, i;\n    const remainder = key.length & 3; // key.length % 4\n    const bytes = key.length - remainder;\n    h1 = seed;\n    const c1 = 0xcc9e2d51;\n    const c2 = 0x1b873593;\n    i = 0;\n    while (i < bytes) {\n        k1 =\n            ((key.readUInt8(i) & 0xff)) |\n                ((key.readUInt8(++i) & 0xff) << 8) |\n                ((key.readUInt8(++i) & 0xff) << 16) |\n                ((key.readUInt8(++i) & 0xff) << 24);\n        ++i;\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n    k1 = 0;\n    switch (remainder) {\n        case 3:\n            k1 ^= (key.readUInt8(i + 2) & 0xff) << 16;\n        case 2: // eslint-disable-line no-fallthrough\n            k1 ^= (key.readUInt8(i + 1) & 0xff) << 8;\n        case 1: // eslint-disable-line no-fallthrough\n            k1 ^= (key.readUInt8(i) & 0xff);\n            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n            h1 ^= k1;\n    }\n    h1 ^= key.length;\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n    const result = h1 >>> 0;\n    // This simulates the 32 bit integer overflow to match Java implementation\n    return result | 0;\n}\nexports.murmur = murmur;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/invocation/Murmur.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/invocation/RegistrationKey.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/invocation/RegistrationKey.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RegistrationKey = void 0;\n/** @internal */\nclass RegistrationKey {\n    constructor(regId, codec, registerRequest, registerHandlerFn) {\n        this.userRegistrationId = regId;\n        this.registerHandlerFn = registerHandlerFn;\n        this.registerRequest = registerRequest;\n        this.codec = codec;\n    }\n    getRegisterRequest() {\n        return this.registerRequest;\n    }\n    setRegisterRequest(registerRequest) {\n        this.registerRequest = registerRequest;\n    }\n    getCodec() {\n        return this.codec;\n    }\n    setCodec(value) {\n        this.codec = value;\n    }\n    getHandler() {\n        return this.registerHandlerFn;\n    }\n    setHandler(handler) {\n        this.registerHandlerFn = handler;\n    }\n    getUserRegistrationKey() {\n        return this.userRegistrationId;\n    }\n}\nexports.RegistrationKey = RegistrationKey;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/invocation/RegistrationKey.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/listener/ClusterViewListenerService.js":
/*!******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/listener/ClusterViewListenerService.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClusterViewListenerService = void 0;\nconst ClientAddClusterViewListenerCodec_1 = __webpack_require__(/*! ../codec/ClientAddClusterViewListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientAddClusterViewListenerCodec.js\");\nconst InvocationService_1 = __webpack_require__(/*! ../invocation/InvocationService */ \"../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js\");\n/**\n * Adds cluster listener to one of the connections. If that connection is removed,\n * it registers connection to any other connection.\n * @internal\n */\nclass ClusterViewListenerService {\n    constructor(client) {\n        this.client = client;\n        this.logger = client.getLoggingService().getLogger();\n        this.connectionManager = client.getConnectionManager();\n        this.partitionService = client.getPartitionService();\n        this.clusterService = client.getClusterService();\n    }\n    start() {\n        this.connectionManager.on('connectionAdded', this.connectionAdded.bind(this));\n        this.connectionManager.on('connectionRemoved', this.connectionRemoved.bind(this));\n    }\n    connectionAdded(connection) {\n        this.tryRegister(connection);\n    }\n    connectionRemoved(connection) {\n        this.tryRegisterToRandomConnection(connection);\n    }\n    tryRegister(connection) {\n        if (this.listenerAddedConnection != null) {\n            // already registering/registered to another connection\n            return;\n        }\n        this.listenerAddedConnection = connection;\n        const request = ClientAddClusterViewListenerCodec_1.ClientAddClusterViewListenerCodec.encodeRequest();\n        const handler = this.createClusterViewEventHandler(connection);\n        const invocation = new InvocationService_1.Invocation(this.client, request);\n        invocation.connection = connection;\n        invocation.handler = handler;\n        this.logger.trace('ClusterViewListenerService', `Register attempt of cluster view handler to ${connection}`);\n        this.client.getInvocationService().invokeUrgent(invocation)\n            .then(() => {\n            this.logger.trace('ClusterViewListenerService', `Registered cluster view handler to ${connection}`);\n        })\n            .catch(() => {\n            // listener needs to be re-registered\n            this.tryRegisterToRandomConnection(connection);\n        });\n    }\n    tryRegisterToRandomConnection(oldConnection) {\n        if (this.listenerAddedConnection !== oldConnection) {\n            // somebody else already trying to re-register\n            return;\n        }\n        this.listenerAddedConnection = null;\n        const newConnection = this.connectionManager.getRandomConnection();\n        if (newConnection != null) {\n            this.tryRegister(newConnection);\n        }\n    }\n    createClusterViewEventHandler(connection) {\n        return (clientMessage) => {\n            ClientAddClusterViewListenerCodec_1.ClientAddClusterViewListenerCodec.handle(clientMessage, this.clusterService.handleMembersViewEvent.bind(this.clusterService), (version, partitions) => {\n                this.partitionService.handlePartitionViewEvent(connection, partitions, version);\n            });\n        };\n    }\n}\nexports.ClusterViewListenerService = ClusterViewListenerService;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/listener/ClusterViewListenerService.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/listener/ListenerService.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/listener/ListenerService.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListenerService = void 0;\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst ClientEventRegistration_1 = __webpack_require__(/*! ../invocation/ClientEventRegistration */ \"../shared/node_modules/hazelcast-client/lib/invocation/ClientEventRegistration.js\");\nconst InvocationService_1 = __webpack_require__(/*! ../invocation/InvocationService */ \"../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js\");\nconst RegistrationKey_1 = __webpack_require__(/*! ../invocation/RegistrationKey */ \"../shared/node_modules/hazelcast-client/lib/invocation/RegistrationKey.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst UuidUtil_1 = __webpack_require__(/*! ../util/UuidUtil */ \"../shared/node_modules/hazelcast-client/lib/util/UuidUtil.js\");\n/** @internal */\nclass ListenerService {\n    constructor(client) {\n        this.client = client;\n        this.logger = this.client.getLoggingService().getLogger();\n        this.isSmartService = this.client.getConfig().network.smartRouting;\n        this.activeRegistrations = new Map();\n        this.userRegistrationKeyInformation = new Map();\n    }\n    start() {\n        this.client.getConnectionManager().on('connectionAdded', this.onConnectionAdded.bind(this));\n        this.client.getConnectionManager().on('connectionRemoved', this.onConnectionRemoved.bind(this));\n    }\n    onConnectionAdded(connection) {\n        this.reregisterListenersOnConnection(connection);\n    }\n    onConnectionRemoved(connection) {\n        this.removeRegistrationsOnConnection(connection);\n    }\n    reregisterListeners() {\n        const connections = this.client.getConnectionManager().getActiveConnections();\n        for (const connAddress in connections) {\n            this.reregisterListenersOnConnection(connections[connAddress]);\n        }\n    }\n    reregisterListenersOnConnection(connection) {\n        this.activeRegistrations.forEach((registrationMap, userKey) => {\n            if (registrationMap.has(connection)) {\n                return;\n            }\n            this.invokeRegistrationFromRecord(userKey, connection).then((eventRegistration) => {\n                registrationMap.set(connection, eventRegistration);\n            }).catch((e) => {\n                this.logger.warn('ListenerService', e);\n            });\n        }, this);\n    }\n    removeRegistrationsOnConnection(connection) {\n        this.activeRegistrations.forEach((registrationsOnUserKey) => {\n            const eventRegistration = registrationsOnUserKey.get(connection);\n            if (eventRegistration !== undefined) {\n                this.client.getInvocationService().removeEventHandler(eventRegistration.correlationId);\n            }\n        });\n    }\n    invokeRegistrationFromRecord(userRegistrationKey, connection) {\n        const deferred = Util_1.DeferredPromise();\n        const activeRegsOnUserKey = this.activeRegistrations.get(userRegistrationKey);\n        if (activeRegsOnUserKey !== undefined && activeRegsOnUserKey.has(connection)) {\n            deferred.resolve(activeRegsOnUserKey.get(connection));\n            return deferred.promise;\n        }\n        const registrationKey = this.userRegistrationKeyInformation.get(userRegistrationKey);\n        // New correlation id will be set on the invoke call\n        const registerRequest = registrationKey.getRegisterRequest().copyWithNewCorrelationId();\n        const codec = registrationKey.getCodec();\n        const invocation = new InvocationService_1.Invocation(this.client, registerRequest);\n        invocation.handler = registrationKey.getHandler();\n        invocation.connection = connection;\n        this.client.getInvocationService().invokeUrgent(invocation).then((responseMessage) => {\n            const correlationId = responseMessage.getCorrelationId();\n            const response = codec.decodeAddResponse(responseMessage);\n            const eventRegistration = new ClientEventRegistration_1.ClientEventRegistration(response, correlationId, invocation.connection, codec);\n            this.logger.debug('ListenerService', 'Listener ' + userRegistrationKey + ' re-registered on ' + connection.toString());\n            deferred.resolve(eventRegistration);\n        }).catch(((e) => {\n            deferred.reject(new core_1.HazelcastError('Could not add listener[' + userRegistrationKey +\n                '] to connection[' + connection.toString() + ']', e));\n        }));\n        return deferred.promise;\n    }\n    registerListener(codec, listenerHandlerFn) {\n        const activeConnections = this.client.getConnectionManager().getActiveConnections();\n        const userRegistrationKey = UuidUtil_1.UuidUtil.generate().toString();\n        let connectionsOnUserKey;\n        const deferred = Util_1.DeferredPromise();\n        const registerRequest = codec.encodeAddRequest(this.isSmart());\n        connectionsOnUserKey = this.activeRegistrations.get(userRegistrationKey);\n        if (connectionsOnUserKey === undefined) {\n            connectionsOnUserKey = new Map();\n            this.activeRegistrations.set(userRegistrationKey, connectionsOnUserKey);\n            this.userRegistrationKeyInformation.set(userRegistrationKey, new RegistrationKey_1.RegistrationKey(userRegistrationKey, codec, registerRequest, listenerHandlerFn));\n        }\n        for (const connection of activeConnections) {\n            if (connectionsOnUserKey.has(connection)) {\n                continue;\n            }\n            // new correlation id will be set on the invoke call\n            const requestCopy = registerRequest.copyWithNewCorrelationId();\n            const invocation = new InvocationService_1.Invocation(this.client, requestCopy);\n            invocation.handler = listenerHandlerFn;\n            invocation.connection = connection;\n            this.client.getInvocationService().invokeUrgent(invocation).then((responseMessage) => {\n                const correlationId = responseMessage.getCorrelationId();\n                const response = codec.decodeAddResponse(responseMessage);\n                const clientEventRegistration = new ClientEventRegistration_1.ClientEventRegistration(response, correlationId, invocation.connection, codec);\n                this.logger.debug('ListenerService', 'Listener ' + userRegistrationKey + ' registered on ' + invocation.connection.toString());\n                connectionsOnUserKey.set(connection, clientEventRegistration);\n            }).then(() => {\n                deferred.resolve(userRegistrationKey);\n            }).catch((e) => {\n                if (invocation.connection.isAlive()) {\n                    this.deregisterListener(userRegistrationKey);\n                    deferred.reject(new core_1.HazelcastError('Listener cannot be added!', e));\n                }\n            });\n        }\n        return deferred.promise;\n    }\n    deregisterListener(userRegistrationKey) {\n        const deferred = Util_1.DeferredPromise();\n        const registrationsOnUserKey = this.activeRegistrations.get(userRegistrationKey);\n        if (registrationsOnUserKey === undefined) {\n            deferred.resolve(false);\n            return deferred.promise;\n        }\n        registrationsOnUserKey.forEach((eventRegistration, connection) => {\n            const clientMessage = eventRegistration.codec.encodeRemoveRequest(eventRegistration.serverRegistrationId);\n            const invocation = new InvocationService_1.Invocation(this.client, clientMessage);\n            invocation.connection = eventRegistration.subscriber;\n            this.client.getInvocationService().invoke(invocation).then((responseMessage) => {\n                registrationsOnUserKey.delete(connection);\n                this.client.getInvocationService().removeEventHandler(eventRegistration.correlationId);\n                this.logger.debug('ListenerService', 'Listener ' + userRegistrationKey + ' unregistered from ' + invocation.connection.toString());\n                this.activeRegistrations.delete(userRegistrationKey);\n                this.userRegistrationKeyInformation.delete(userRegistrationKey);\n                deferred.resolve(true);\n            });\n        });\n        return deferred.promise;\n    }\n    isSmart() {\n        return this.isSmartService;\n    }\n}\nexports.ListenerService = ListenerService;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/listener/ListenerService.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/logging/DefaultLogger.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/logging/DefaultLogger.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultLogger = void 0;\nconst ILogger_1 = __webpack_require__(/*! ./ILogger */ \"../shared/node_modules/hazelcast-client/lib/logging/ILogger.js\");\n/** @internal */\nclass DefaultLogger {\n    constructor(level) {\n        this.level = level;\n    }\n    log(level, objectName, message, furtherInfo) {\n        if (level <= this.level) {\n            console.log('[DefaultLogger] %s at %s: %s', ILogger_1.LogLevel[level], objectName, message);\n            if (furtherInfo != null) {\n                console.log(furtherInfo);\n            }\n        }\n    }\n    error(objectName, message, furtherInfo) {\n        this.log(ILogger_1.LogLevel.ERROR, objectName, message, furtherInfo);\n    }\n    warn(objectName, message, furtherInfo) {\n        this.log(ILogger_1.LogLevel.WARN, objectName, message, furtherInfo);\n    }\n    info(objectName, message, furtherInfo) {\n        this.log(ILogger_1.LogLevel.INFO, objectName, message, furtherInfo);\n    }\n    debug(objectName, message, furtherInfo) {\n        this.log(ILogger_1.LogLevel.DEBUG, objectName, message, furtherInfo);\n    }\n    trace(objectName, message, furtherInfo) {\n        this.log(ILogger_1.LogLevel.TRACE, objectName, message, furtherInfo);\n    }\n}\nexports.DefaultLogger = DefaultLogger;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/logging/DefaultLogger.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/logging/ILogger.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/logging/ILogger.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LogLevel = void 0;\n/**\n * Log level for built-in or custom logger.\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"OFF\"] = -1] = \"OFF\";\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n    LogLevel[LogLevel[\"TRACE\"] = 4] = \"TRACE\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/logging/ILogger.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/logging/LoggingService.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/logging/LoggingService.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoggingService = void 0;\nconst DefaultLogger_1 = __webpack_require__(/*! ./DefaultLogger */ \"../shared/node_modules/hazelcast-client/lib/logging/DefaultLogger.js\");\nconst ILogger_1 = __webpack_require__(/*! ./ILogger */ \"../shared/node_modules/hazelcast-client/lib/logging/ILogger.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\n/** @internal */\nclass LoggingService {\n    constructor(customLogger, level) {\n        if (customLogger == null) {\n            const logLevel = Util_1.enumFromString(ILogger_1.LogLevel, level);\n            this.logger = new DefaultLogger_1.DefaultLogger(logLevel);\n        }\n        else if (this.isLogger(customLogger)) {\n            this.logger = customLogger;\n        }\n        else {\n            throw new RangeError('Logger should implement ILogger functions!');\n        }\n    }\n    isLogger(loggingProperty) {\n        loggingProperty = loggingProperty;\n        return loggingProperty.log !== undefined && loggingProperty.error !== undefined\n            && loggingProperty.warn !== undefined && loggingProperty.info !== undefined\n            && loggingProperty.debug !== undefined && loggingProperty.trace !== undefined;\n    }\n    getLogger() {\n        return this.logger;\n    }\n}\nexports.LoggingService = LoggingService;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/logging/LoggingService.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/logging/index.js":
/*!********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/logging/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Public API re-exports.\n */\n__exportStar(__webpack_require__(/*! ./ILogger */ \"../shared/node_modules/hazelcast-client/lib/logging/ILogger.js\"), exports);\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/logging/index.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/nearcache/DataRecord.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/nearcache/DataRecord.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataRecord = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\n/** @internal */\nclass DataRecord {\n    constructor(key, value, creationTime, ttl) {\n        this.key = key;\n        this.value = value;\n        this.ttl = ttl;\n        if (creationTime) {\n            this.creationTime = creationTime;\n        }\n        else {\n            this.creationTime = Date.now();\n        }\n        if (ttl) {\n            this.expirationTime = this.creationTime + ttl * 1000;\n        }\n        else {\n            this.expirationTime = undefined;\n        }\n        this.lastAccessTime = this.creationTime;\n        this.accessHit = 0;\n        this.invalidationSequence = Long.fromNumber(0);\n        this.uuid = null;\n        this.status = DataRecord.READ_PERMITTED;\n    }\n    static lruComp(x, y) {\n        return x.lastAccessTime - y.lastAccessTime;\n    }\n    static lfuComp(x, y) {\n        return x.accessHit - y.accessHit;\n    }\n    static randomComp(x, y) {\n        return Math.random() - 0.5;\n    }\n    isExpired(maxIdleSeconds) {\n        const now = Date.now();\n        if ((this.expirationTime > 0 && this.expirationTime < now) ||\n            (maxIdleSeconds > 0 && this.lastAccessTime + maxIdleSeconds * 1000 < now)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    setAccessTime() {\n        this.lastAccessTime = Date.now();\n    }\n    hitRecord() {\n        this.accessHit++;\n    }\n    getInvalidationSequence() {\n        return this.invalidationSequence;\n    }\n    setInvalidationSequence(sequence) {\n        this.invalidationSequence = sequence;\n    }\n    hasSameUuid(uuid) {\n        return uuid != null && this.uuid != null && this.uuid.equals(uuid);\n    }\n    setUuid(uuid) {\n        this.uuid = uuid;\n    }\n    casStatus(expected, update) {\n        if (expected.equals(this.status)) {\n            this.status = update;\n            return true;\n        }\n        return false;\n    }\n    getStatus() {\n        return this.status;\n    }\n    setCreationTime(creationTime) {\n        if (creationTime) {\n            this.creationTime = creationTime;\n        }\n        else {\n            this.creationTime = Date.now();\n        }\n        if (this.ttl) {\n            this.expirationTime = this.creationTime + this.ttl * 1000;\n        }\n        else {\n            this.expirationTime = undefined;\n        }\n    }\n}\nexports.DataRecord = DataRecord;\nDataRecord.NOT_RESERVED = Long.NEG_ONE;\nDataRecord.RESERVED = Long.fromNumber(-2);\nDataRecord.READ_PERMITTED = Long.fromNumber(-3);\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/nearcache/DataRecord.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/nearcache/DataStoreHashMap.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/nearcache/DataStoreHashMap.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataKeyedHashMap = void 0;\n/** @internal */\nclass DataKeyedHashMap {\n    constructor() {\n        this.internalStore = new Map();\n        this.size = 0;\n    }\n    clear() {\n        this.size = 0;\n        this.internalStore = new Map();\n    }\n    delete(key) {\n        const existingIndex = this.findIndexInBucket(key);\n        if (existingIndex === -1) {\n            return false;\n        }\n        else {\n            this.getOrCreateBucket(key.hashCode()).splice(existingIndex, 1);\n            this.size--;\n            return true;\n        }\n    }\n    has(key) {\n        return this.findIndexInBucket(key) !== -1;\n    }\n    get(key) {\n        const keyHash = key.hashCode();\n        const existingIndex = this.findIndexInBucket(key);\n        if (existingIndex !== -1) {\n            return this.getOrCreateBucket(keyHash)[existingIndex].value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set(key, value) {\n        const keyHash = key.hashCode();\n        const existingIndex = this.findIndexInBucket(key);\n        if (existingIndex !== -1) {\n            this.getOrCreateBucket(keyHash)[existingIndex].value = value;\n        }\n        else {\n            this.getOrCreateBucket(keyHash).push({ key, value });\n            this.size++;\n        }\n        return this;\n    }\n    values() {\n        const snapshot = [];\n        this.internalStore.forEach((bucket) => {\n            snapshot.push(...(bucket.map((item) => item.value)));\n        });\n        return snapshot;\n    }\n    entries() {\n        const snapshot = [];\n        this.internalStore.forEach((bucket) => {\n            snapshot.push(...(bucket.map((item) => {\n                return [item.key, item.value];\n            })));\n        });\n        return snapshot;\n    }\n    /**\n     *\n     * @param key\n     * @returns index of the key if it exists, -1 if either bucket or item does not exist\n     */\n    findIndexInBucket(key) {\n        const keyHash = key.hashCode();\n        const bucket = this.internalStore.get(keyHash);\n        if (bucket === undefined) {\n            return -1;\n        }\n        else {\n            return bucket.findIndex((item) => {\n                return item.key.equals(key);\n            });\n        }\n    }\n    getOrCreateBucket(key) {\n        let bucket;\n        bucket = this.internalStore.get(key);\n        if (bucket === undefined) {\n            bucket = [];\n            this.internalStore.set(key, bucket);\n        }\n        return bucket;\n    }\n}\nexports.DataKeyedHashMap = DataKeyedHashMap;\nclass InternalRecord {\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/nearcache/DataStoreHashMap.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/nearcache/MetadataContainer.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/nearcache/MetadataContainer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MetadataContainer = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\n/** @internal */\nclass MetadataContainer {\n    constructor() {\n        this.sequence = Long.fromNumber(0);\n        this.staleSequence = Long.fromNumber(0);\n        this.missedSequenceCount = Long.fromNumber(0);\n    }\n    reset() {\n        this.sequence = Long.fromNumber(0);\n        this.staleSequence = Long.fromNumber(0);\n        this.missedSequenceCount = Long.fromNumber(0);\n    }\n    setSequence(sequence) {\n        this.sequence = sequence;\n    }\n    getSequence() {\n        return this.sequence;\n    }\n    setStaleSequence(staleSequence) {\n        this.staleSequence = staleSequence;\n    }\n    getStaleSequence() {\n        return this.staleSequence;\n    }\n    increaseMissedSequenceCount(missed) {\n        this.missedSequenceCount = this.missedSequenceCount.add(missed);\n    }\n    getMissedSequenceCount() {\n        return this.missedSequenceCount;\n    }\n    setUuid(uuid) {\n        this.uuid = uuid;\n    }\n    getUuid() {\n        return this.uuid;\n    }\n}\nexports.MetadataContainer = MetadataContainer;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/nearcache/MetadataContainer.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/nearcache/MetadataFetcher.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/nearcache/MetadataFetcher.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MetadataFetcher = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst MapFetchNearCacheInvalidationMetadataCodec_1 = __webpack_require__(/*! ../codec/MapFetchNearCacheInvalidationMetadataCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapFetchNearCacheInvalidationMetadataCodec.js\");\nconst MemberSelector_1 = __webpack_require__(/*! ../core/MemberSelector */ \"../shared/node_modules/hazelcast-client/lib/core/MemberSelector.js\");\nconst InvocationService_1 = __webpack_require__(/*! ../invocation/InvocationService */ \"../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js\");\n/** @internal */\nclass MetadataFetcher {\n    constructor(client) {\n        this.logger = client.getLoggingService().getLogger();\n        this.client = client;\n    }\n    initHandler(handler) {\n        const scanPromises = this.scanMembers([handler.getName()]);\n        return Promise.all(scanPromises).then((responses) => {\n            responses.forEach((response) => {\n                const metadata = MapFetchNearCacheInvalidationMetadataCodec_1.MapFetchNearCacheInvalidationMetadataCodec.decodeResponse(response);\n                handler.initUuid(metadata.partitionUuidList);\n                handler.initSequence(metadata.namePartitionSequenceList[0]);\n            });\n        });\n    }\n    fetchMetadata(handlers) {\n        const objectNames = this.getObjectNames(handlers);\n        const promises = this.scanMembers(objectNames);\n        return Promise.each(promises, (clientMessage) => {\n            this.processResponse(clientMessage, handlers);\n        }).then(() => undefined);\n    }\n    processResponse(responseMessage, handlers) {\n        const metadata = MapFetchNearCacheInvalidationMetadataCodec_1.MapFetchNearCacheInvalidationMetadataCodec.decodeResponse(responseMessage);\n        handlers.forEach((handler) => {\n            try {\n                this.repairUuids(handler, metadata.partitionUuidList);\n                this.repairSequences(handler, metadata.namePartitionSequenceList);\n            }\n            catch (e) {\n                this.logger.warn('MetadataFetcher', 'Can not get invalidation metadata ' + e.message);\n            }\n        });\n    }\n    repairUuids(handler, partitionIdUuidList) {\n        partitionIdUuidList.forEach((entry) => {\n            handler.checkOrRepairUuid(entry[0], entry[1]);\n        });\n    }\n    repairSequences(handler, partitionIdSequenceList) {\n        partitionIdSequenceList.forEach((partitionIdSeq) => {\n            const pairs = partitionIdSeq[1];\n            pairs.forEach((pair) => {\n                handler.checkOrRepairSequence(pair[0], pair[1], true);\n            });\n        });\n    }\n    scanMembers(objectNames) {\n        const members = this.client.getClusterService().getMembers(MemberSelector_1.dataMemberSelector);\n        const promises = [];\n        members.forEach((member) => {\n            const request = MapFetchNearCacheInvalidationMetadataCodec_1.MapFetchNearCacheInvalidationMetadataCodec.encodeRequest(objectNames, member.uuid);\n            const promise = this.client.getInvocationService().invoke(new InvocationService_1.Invocation(this.client, request));\n            promises.push(promise);\n        });\n        return promises;\n    }\n    getObjectNames(handlers) {\n        const names = [];\n        handlers.forEach((handler) => {\n            names.push(handler.getName());\n        });\n        return names;\n    }\n}\nexports.MetadataFetcher = MetadataFetcher;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/nearcache/MetadataFetcher.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/nearcache/NearCache.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/nearcache/NearCache.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NearCacheImpl = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst EvictionPolicy_1 = __webpack_require__(/*! ../config/EvictionPolicy */ \"../shared/node_modules/hazelcast-client/lib/config/EvictionPolicy.js\");\nconst InMemoryFormat_1 = __webpack_require__(/*! ../config/InMemoryFormat */ \"../shared/node_modules/hazelcast-client/lib/config/InMemoryFormat.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst DataStoreHashMap_1 = __webpack_require__(/*! ./DataStoreHashMap */ \"../shared/node_modules/hazelcast-client/lib/nearcache/DataStoreHashMap.js\");\nconst DataRecord_1 = __webpack_require__(/*! ./DataRecord */ \"../shared/node_modules/hazelcast-client/lib/nearcache/DataRecord.js\");\nconst StaleReadDetector_1 = __webpack_require__(/*! ./StaleReadDetector */ \"../shared/node_modules/hazelcast-client/lib/nearcache/StaleReadDetector.js\");\n/** @internal */\nclass NearCacheImpl {\n    constructor(nearCacheConfig, serializationService) {\n        this.staleReadDetector = StaleReadDetector_1.alwaysFreshDetector;\n        this.reservationCounter = Long.ZERO;\n        this.evictedCount = 0;\n        this.expiredCount = 0;\n        this.missCount = 0;\n        this.hitCount = 0;\n        this.creationTime = Date.now();\n        this.serializationService = serializationService;\n        this.name = nearCacheConfig.name;\n        this.invalidateOnChange = nearCacheConfig.invalidateOnChange;\n        this.maxIdleSeconds = nearCacheConfig.maxIdleSeconds;\n        this.inMemoryFormat = nearCacheConfig.inMemoryFormat;\n        this.timeToLiveSeconds = nearCacheConfig.timeToLiveSeconds;\n        this.evictionPolicy = nearCacheConfig.evictionPolicy;\n        this.evictionMaxSize = nearCacheConfig.evictionMaxSize;\n        this.evictionSamplingCount = nearCacheConfig.evictionSamplingCount;\n        this.evictionSamplingPoolSize = nearCacheConfig.evictionSamplingPoolSize;\n        if (this.evictionPolicy === EvictionPolicy_1.EvictionPolicy.LFU) {\n            this.compareFunc = DataRecord_1.DataRecord.lfuComp;\n        }\n        else if (this.evictionPolicy === EvictionPolicy_1.EvictionPolicy.LRU) {\n            this.compareFunc = DataRecord_1.DataRecord.lruComp;\n        }\n        else if (this.evictionPolicy === EvictionPolicy_1.EvictionPolicy.RANDOM) {\n            this.compareFunc = DataRecord_1.DataRecord.randomComp;\n        }\n        else {\n            this.compareFunc = undefined;\n        }\n        this.evictionCandidatePool = [];\n        this.internalStore = new DataStoreHashMap_1.DataKeyedHashMap();\n        this.ready = Util_1.DeferredPromise();\n    }\n    setReady() {\n        this.ready.resolve();\n    }\n    getName() {\n        return this.name;\n    }\n    nextReservationId() {\n        const res = this.reservationCounter;\n        this.reservationCounter = this.reservationCounter.add(1);\n        return res;\n    }\n    tryReserveForUpdate(key) {\n        const internalRecord = this.internalStore.get(key);\n        const resId = this.nextReservationId();\n        if (internalRecord === undefined) {\n            this.doEvictionIfRequired();\n            const dr = new DataRecord_1.DataRecord(key, undefined, undefined, this.timeToLiveSeconds);\n            dr.casStatus(DataRecord_1.DataRecord.READ_PERMITTED, resId);\n            this.internalStore.set(key, dr);\n            return resId;\n        }\n        if (internalRecord.casStatus(DataRecord_1.DataRecord.READ_PERMITTED, resId)) {\n            return resId;\n        }\n        return DataRecord_1.DataRecord.NOT_RESERVED;\n    }\n    tryPublishReserved(key, value, reservationId) {\n        const internalRecord = this.internalStore.get(key);\n        if (internalRecord && internalRecord.casStatus(reservationId, DataRecord_1.DataRecord.READ_PERMITTED)) {\n            if (this.inMemoryFormat === InMemoryFormat_1.InMemoryFormat.OBJECT) {\n                internalRecord.value = this.serializationService.toObject(value);\n            }\n            else {\n                internalRecord.value = this.serializationService.toData(value);\n            }\n            internalRecord.setCreationTime();\n            this.initInvalidationMetadata(internalRecord);\n        }\n        else if (internalRecord === undefined) {\n            return undefined;\n        }\n        else {\n            if (this.inMemoryFormat === InMemoryFormat_1.InMemoryFormat.BINARY) {\n                return this.serializationService.toObject(internalRecord.value);\n            }\n            else {\n                return internalRecord.value;\n            }\n        }\n    }\n    setStaleReadDetector(staleReadDetector) {\n        this.staleReadDetector = staleReadDetector;\n    }\n    /**\n     * Creates a new {DataRecord} for given key and value. Then, puts the record in near cache.\n     * If the number of records in near cache exceeds {evictionMaxSize}, it removes expired items first.\n     * If there is no expired item, it triggers an invalidation process to create free space.\n     * @param key\n     * @param value\n     */\n    put(key, value) {\n        this.doEvictionIfRequired();\n        if (this.inMemoryFormat === InMemoryFormat_1.InMemoryFormat.OBJECT) {\n            value = this.serializationService.toObject(value);\n        }\n        else {\n            value = this.serializationService.toData(value);\n        }\n        const dr = new DataRecord_1.DataRecord(key, value, undefined, this.timeToLiveSeconds);\n        this.initInvalidationMetadata(dr);\n        this.internalStore.set(key, dr);\n    }\n    /**\n     *\n     * @param key\n     * @returns the value if present in near cache, 'undefined' if not\n     */\n    get(key) {\n        return this.ready.promise.then(() => {\n            const dr = this.internalStore.get(key);\n            if (dr === undefined) {\n                this.missCount++;\n                return undefined;\n            }\n            if (this.staleReadDetector.isStaleRead(key, dr)) {\n                this.internalStore.delete(key);\n                this.missCount++;\n                return undefined;\n            }\n            if (dr.isExpired(this.maxIdleSeconds)) {\n                this.expireRecord(key);\n                this.missCount++;\n                return undefined;\n            }\n            dr.setAccessTime();\n            dr.hitRecord();\n            this.hitCount++;\n            if (this.inMemoryFormat === InMemoryFormat_1.InMemoryFormat.BINARY) {\n                return this.serializationService.toObject(dr.value);\n            }\n            else {\n                return dr.value;\n            }\n        });\n    }\n    invalidate(key) {\n        this.internalStore.delete(key);\n    }\n    clear() {\n        this.internalStore.clear();\n    }\n    isInvalidatedOnChange() {\n        return this.invalidateOnChange;\n    }\n    getStatistics() {\n        const stats = {\n            creationTime: this.creationTime,\n            evictedCount: this.evictedCount,\n            expiredCount: this.expiredCount,\n            missCount: this.missCount,\n            hitCount: this.hitCount,\n            entryCount: this.internalStore.size,\n        };\n        return stats;\n    }\n    isEvictionRequired() {\n        return this.evictionPolicy !== EvictionPolicy_1.EvictionPolicy.NONE && this.evictionMaxSize <= this.internalStore.size;\n    }\n    doEvictionIfRequired() {\n        if (!this.isEvictionRequired()) {\n            return;\n        }\n        if (this.recomputeEvictionPool() > 0) {\n            return;\n        }\n        else {\n            this.evictRecord(this.evictionCandidatePool[0].key);\n            this.evictionCandidatePool = this.evictionCandidatePool.slice(1);\n        }\n    }\n    /**\n     * @returns number of expired elements.\n     */\n    recomputeEvictionPool() {\n        const arr = Array.from(this.internalStore.values());\n        Util_1.shuffleArray(arr);\n        const newCandidates = arr.slice(0, this.evictionSamplingCount);\n        const cleanedNewCandidates = newCandidates.filter(this.filterExpiredRecord, this);\n        const expiredCount = newCandidates.length - cleanedNewCandidates.length;\n        if (expiredCount > 0) {\n            return expiredCount;\n        }\n        this.evictionCandidatePool.push(...cleanedNewCandidates);\n        this.evictionCandidatePool.sort(this.compareFunc);\n        this.evictionCandidatePool = this.evictionCandidatePool.slice(0, this.evictionSamplingPoolSize);\n        return 0;\n    }\n    filterExpiredRecord(candidate) {\n        if (candidate.isExpired(this.maxIdleSeconds)) {\n            this.expireRecord(candidate.key);\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    expireRecord(key) {\n        if (this.internalStore.delete(key)) {\n            this.expiredCount++;\n        }\n    }\n    evictRecord(key) {\n        if (this.internalStore.delete(key)) {\n            this.evictedCount++;\n        }\n    }\n    initInvalidationMetadata(dr) {\n        if (this.staleReadDetector === StaleReadDetector_1.alwaysFreshDetector) {\n            return;\n        }\n        const partitionId = this.staleReadDetector.getPartitionId(dr.key);\n        const metadataContainer = this.staleReadDetector.getMetadataContainer(partitionId);\n        dr.setInvalidationSequence(metadataContainer.getSequence());\n        dr.setUuid(metadataContainer.getUuid());\n    }\n}\nexports.NearCacheImpl = NearCacheImpl;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/nearcache/NearCache.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/nearcache/NearCacheManager.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/nearcache/NearCacheManager.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NearCacheManager = void 0;\nconst NearCache_1 = __webpack_require__(/*! ./NearCache */ \"../shared/node_modules/hazelcast-client/lib/nearcache/NearCache.js\");\n/** @internal */\nclass NearCacheManager {\n    constructor(client) {\n        this.caches = new Map();\n        this.client = client;\n    }\n    getOrCreateNearCache(name) {\n        let nearCache = this.caches.get(name);\n        if (nearCache == null) {\n            const config = this.client.getConfig();\n            nearCache = new NearCache_1.NearCacheImpl(config.getNearCacheConfig(name), this.client.getSerializationService());\n            this.caches.set(name, nearCache);\n        }\n        return nearCache;\n    }\n    destroyNearCache(name) {\n        const nearCache = this.caches.get(name);\n        if (nearCache != null) {\n            this.caches.delete(name);\n            nearCache.clear();\n        }\n    }\n    destroyAllNearCaches() {\n        this.caches.forEach((cache) => {\n            cache.clear();\n        });\n        this.caches.clear();\n    }\n    listAllNearCaches() {\n        return Array.from(this.caches.values());\n    }\n    clearAllNearCaches() {\n        for (const nearCache of this.listAllNearCaches()) {\n            nearCache.clear();\n        }\n    }\n}\nexports.NearCacheManager = NearCacheManager;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/nearcache/NearCacheManager.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/nearcache/RepairingHandler.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/nearcache/RepairingHandler.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RepairingHandler = void 0;\nconst MetadataContainer_1 = __webpack_require__(/*! ./MetadataContainer */ \"../shared/node_modules/hazelcast-client/lib/nearcache/MetadataContainer.js\");\n/** @internal */\nclass RepairingHandler {\n    constructor(name, partitionService, nearCache, localUuid) {\n        this.nearCache = nearCache;\n        this.name = name;\n        this.partitionService = partitionService;\n        this.partitionCount = this.partitionService.getPartitionCount();\n        this.localUuid = localUuid;\n        this.containers = [];\n        for (let i = 0; i < this.partitionCount; i++) {\n            this.containers[i] = new MetadataContainer_1.MetadataContainer();\n        }\n    }\n    initUuid(partitionIdUuidPairsList) {\n        for (const item of partitionIdUuidPairsList) {\n            const partitionId = item[0];\n            const partitionUuid = item[1];\n            this.getMetadataContainer(partitionId).setUuid(partitionUuid);\n        }\n    }\n    initSequence(partitionIdSequencePairsList) {\n        const list = partitionIdSequencePairsList[1];\n        for (const item of list) {\n            const partitionId = item[0];\n            const partitionSequence = item[1];\n            this.getMetadataContainer(partitionId).setSequence(partitionSequence);\n        }\n    }\n    handle(key, sourceUuid, partitionUuid, sequence) {\n        // apply invalidation if it's not originated by local member/client (because local\n        // Near Caches are invalidated immediately there is no need to invalidate them twice)\n        if (!this.localUuid.equals(sourceUuid)) {\n            if (key == null) {\n                this.nearCache.clear();\n            }\n            else {\n                this.nearCache.invalidate(key);\n            }\n        }\n        const partitionId = this.getPartitionIdOrDefault(key);\n        this.checkOrRepairSequence(partitionId, sequence);\n        this.checkOrRepairUuid(partitionId, partitionUuid);\n    }\n    handleBatch(keys, sourceUuids, partitionUuids, sequences) {\n        for (let i = 0; i < keys.length; i++) {\n            this.handle(keys[i], sourceUuids[i], partitionUuids[i], sequences[i]);\n        }\n    }\n    checkOrRepairSequence(partitionId, nextSequence, viaAntiEntropy = false) {\n        const metadata = this.getMetadataContainer(partitionId);\n        const current = metadata.getSequence();\n        if (current.greaterThanOrEqual(nextSequence)) {\n            return;\n        }\n        metadata.setSequence(nextSequence);\n        let missed = nextSequence.subtract(current);\n        if (!viaAntiEntropy) {\n            missed = missed.subtract(1);\n        }\n        if (missed.greaterThan(0)) {\n            metadata.increaseMissedSequenceCount(missed);\n        }\n    }\n    checkOrRepairUuid(partitionId, newuuid) {\n        const metadata = this.getMetadataContainer(partitionId);\n        const currentUuid = metadata.getUuid();\n        if (currentUuid != null && currentUuid.equals(newuuid)) {\n            return;\n        }\n        metadata.setUuid(newuuid);\n        metadata.reset();\n    }\n    updateLastKnownStaleSequence(metadataContainer) {\n        const lastStaleSequence = metadataContainer.getStaleSequence();\n        const lastSequence = metadataContainer.getSequence();\n        if (lastStaleSequence.lessThan(lastSequence)) {\n            metadataContainer.setStaleSequence(lastSequence);\n        }\n    }\n    getMetadataContainer(partitionId) {\n        return this.containers[partitionId];\n    }\n    getName() {\n        return this.name;\n    }\n    getPartitionIdOrDefault(key) {\n        if (key != null) {\n            return this.partitionService.getPartitionId(key);\n        }\n        else {\n            return this.partitionService.getPartitionId(this.name);\n        }\n    }\n}\nexports.RepairingHandler = RepairingHandler;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/nearcache/RepairingHandler.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/nearcache/RepairingTask.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/nearcache/RepairingTask.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RepairingTask = void 0;\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst MetadataFetcher_1 = __webpack_require__(/*! ./MetadataFetcher */ \"../shared/node_modules/hazelcast-client/lib/nearcache/MetadataFetcher.js\");\nconst RepairingHandler_1 = __webpack_require__(/*! ./RepairingHandler */ \"../shared/node_modules/hazelcast-client/lib/nearcache/RepairingHandler.js\");\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst PROPERTY_MAX_RECONCILIATION_INTERVAL_SECONDS = 'hazelcast.invalidation.reconciliation.interval.seconds';\nconst PROPERTY_MIN_RECONCILIATION_INTERVAL_SECONDS = 'hazelcast.invalidation.min.reconciliation.interval.seconds';\nconst PROPERTY_MAX_TOLERATED_MISS_COUNT = 'hazelcast.invalidation.max.tolerated.miss.count';\n/** @internal */\nclass RepairingTask {\n    constructor(client) {\n        this.client = client;\n        this.logger = this.client.getLoggingService().getLogger();\n        const config = this.client.getConfig();\n        this.minAllowedReconciliationSeconds = config.properties[PROPERTY_MIN_RECONCILIATION_INTERVAL_SECONDS];\n        const requestedReconciliationSeconds = config.properties[PROPERTY_MAX_RECONCILIATION_INTERVAL_SECONDS];\n        this.reconcilliationInterval = this.getReconciliationIntervalMillis(requestedReconciliationSeconds);\n        this.handlers = new Map();\n        this.localUuid = this.client.getLocalEndpoint().uuid;\n        this.maxToleratedMissCount = config.properties[PROPERTY_MAX_TOLERATED_MISS_COUNT];\n        this.metadataFetcher = new MetadataFetcher_1.MetadataFetcher(client);\n        this.partitionCount = this.client.getPartitionService().getPartitionCount();\n    }\n    registerAndGetHandler(objectName, nearCache) {\n        let handler = this.handlers.get(objectName);\n        if (handler !== undefined) {\n            return Promise.resolve(handler);\n        }\n        const partitionService = this.client.getPartitionService();\n        handler = new RepairingHandler_1.RepairingHandler(objectName, partitionService, nearCache, this.localUuid);\n        return this.metadataFetcher.initHandler(handler).then(() => {\n            this.handlers.set(objectName, handler);\n            if (this.antientropyTaskHandle === undefined) {\n                this.start();\n            }\n            return handler;\n        });\n    }\n    deregisterHandler(objectName) {\n        this.handlers.delete(objectName);\n    }\n    start() {\n        assert(this.reconcilliationInterval > 0);\n        this.antientropyTaskHandle = setInterval(this.antiEntropyTask.bind(this), this.reconcilliationInterval);\n    }\n    shutdown() {\n        if (this.antientropyTaskHandle != null) {\n            clearInterval(this.antientropyTaskHandle);\n        }\n    }\n    antiEntropyTask() {\n        if (this.client.getLifecycleService().isRunning()) {\n            this.handlers.forEach((handler) => {\n                if (this.isAboveMaxToleratedMissCount(handler)) {\n                    this.updateLastKnownStaleSequences(handler);\n                }\n            });\n            this.metadataFetcher.fetchMetadata(this.handlers);\n        }\n        else {\n            this.shutdown();\n            this.logger.debug('RepairingTask', 'Anti entropy task was on although client was not running.' +\n                'Anti entropy task was shutdown forcibly.');\n        }\n    }\n    isAboveMaxToleratedMissCount(handler) {\n        let totalMissCount = Long.fromNumber(0);\n        for (let i = 0; i < this.partitionCount; i++) {\n            const added = handler.getMetadataContainer(i).getMissedSequenceCount();\n            totalMissCount = totalMissCount.add(added);\n            if (totalMissCount.greaterThanOrEqual(this.maxToleratedMissCount)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    updateLastKnownStaleSequences(handler) {\n        for (let i = 0; i < this.partitionCount; i++) {\n            const container = handler.getMetadataContainer(i);\n            const missedCount = container.getMissedSequenceCount();\n            if (missedCount.notEquals(0)) {\n                container.increaseMissedSequenceCount(missedCount.negate());\n                handler.updateLastKnownStaleSequence(container);\n            }\n        }\n    }\n    getReconciliationIntervalMillis(seconds) {\n        if (seconds === 0 || seconds >= this.minAllowedReconciliationSeconds) {\n            return seconds * 1000;\n        }\n        else {\n            const message = 'Reconciliation interval can be at least ' + this.minAllowedReconciliationSeconds + ' seconds ' +\n                'if not 0. Configured interval is ' + seconds + ' seconds. ' +\n                'Note: configuring a value of 0 seconds disables the reconciliation task.';\n            throw new RangeError(message);\n        }\n    }\n}\nexports.RepairingTask = RepairingTask;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/nearcache/RepairingTask.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/nearcache/StaleReadDetector.js":
/*!**********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/nearcache/StaleReadDetector.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.alwaysFreshDetector = exports.StaleReadDetectorImpl = void 0;\n/** @internal */\nclass StaleReadDetectorImpl {\n    constructor(handler, partitionService) {\n        this.repairingHandler = handler;\n        this.partitionService = partitionService;\n    }\n    isStaleRead(key, record) {\n        const metadata = this.getMetadataContainer(this.getPartitionId(record.key));\n        return !record.hasSameUuid(metadata.getUuid()) || record.getInvalidationSequence().lessThan(metadata.getStaleSequence());\n    }\n    getMetadataContainer(partitionId) {\n        return this.repairingHandler.getMetadataContainer(partitionId);\n    }\n    getPartitionId(key) {\n        return this.partitionService.getPartitionId(key);\n    }\n}\nexports.StaleReadDetectorImpl = StaleReadDetectorImpl;\nclass AlwaysFreshStaleReadDetectorImpl {\n    isStaleRead(key, record) {\n        return false;\n    }\n    getPartitionId(key) {\n        return 0;\n    }\n    getMetadataContainer(partitionId) {\n        return null;\n    }\n}\n/** @internal */\nexports.alwaysFreshDetector = new AlwaysFreshStaleReadDetectorImpl();\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/nearcache/StaleReadDetector.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/network/ClientConnection.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/network/ClientConnection.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientConnection = exports.FragmentedClientMessageHandler = exports.ClientMessageReader = exports.DirectWriter = exports.PipelinedWriter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst BuildInfo_1 = __webpack_require__(/*! ../BuildInfo */ \"../shared/node_modules/hazelcast-client/lib/BuildInfo.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst ClientMessage_1 = __webpack_require__(/*! ../protocol/ClientMessage */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js\");\nconst FROZEN_ARRAY = Object.freeze([]);\nconst PROPERTY_PIPELINING_ENABLED = 'hazelcast.client.autopipelining.enabled';\nconst PROPERTY_PIPELINING_THRESHOLD = 'hazelcast.client.autopipelining.threshold.bytes';\nconst PROPERTY_NO_DELAY = 'hazelcast.client.socket.no.delay';\n/** @internal */\nclass PipelinedWriter extends events_1.EventEmitter {\n    constructor(socket, threshold) {\n        super();\n        this.queue = [];\n        this.scheduled = false;\n        this.socket = socket;\n        this.threshold = threshold;\n    }\n    write(buffer, resolver) {\n        if (this.error) {\n            // if there was a write error, it's useless to keep writing to the socket\n            return process.nextTick(() => resolver.reject(this.error));\n        }\n        this.queue.push({ buffer, resolver });\n        this.schedule();\n    }\n    schedule() {\n        if (!this.scheduled) {\n            this.scheduled = true;\n            // nextTick allows queue to be processed on the current event loop phase\n            process.nextTick(() => this.process());\n        }\n    }\n    process() {\n        if (this.error) {\n            return;\n        }\n        const buffers = [];\n        const resolvers = [];\n        let totalLength = 0;\n        while (this.queue.length > 0 && totalLength < this.threshold) {\n            const item = this.queue.shift();\n            const data = item.buffer;\n            totalLength += data.length;\n            buffers.push(data);\n            resolvers.push(item.resolver);\n        }\n        if (totalLength === 0) {\n            this.scheduled = false;\n            return;\n        }\n        // coalesce buffers and write to the socket: no further writes until flushed\n        const merged = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers, totalLength);\n        this.socket.write(merged, (err) => {\n            if (err) {\n                this.handleError(err, resolvers);\n                return;\n            }\n            this.emit('write');\n            for (const r of resolvers) {\n                r.resolve();\n            }\n            if (this.queue.length === 0) {\n                // will start running on the next message\n                this.scheduled = false;\n                return;\n            }\n            // setImmediate allows IO between writes\n            setImmediate(() => this.process());\n        });\n    }\n    handleError(err, sentResolvers) {\n        this.error = new core_1.IOError(err);\n        for (const r of sentResolvers) {\n            r.reject(this.error);\n        }\n        // no more items can be added now\n        const q = this.queue;\n        this.queue = FROZEN_ARRAY;\n        for (const it of q) {\n            it.resolver.reject(this.error);\n        }\n    }\n}\nexports.PipelinedWriter = PipelinedWriter;\n/** @internal */\nclass DirectWriter extends events_1.EventEmitter {\n    constructor(socket) {\n        super();\n        this.socket = socket;\n    }\n    write(buffer, resolver) {\n        this.socket.write(buffer, (err) => {\n            if (err) {\n                resolver.reject(new core_1.IOError(err));\n                return;\n            }\n            this.emit('write');\n            resolver.resolve();\n        });\n    }\n}\nexports.DirectWriter = DirectWriter;\n/** @internal */\nclass ClientMessageReader {\n    constructor() {\n        this.chunks = [];\n        this.chunksTotalSize = 0;\n        this.frameSize = 0;\n        this.flags = 0;\n        this.clientMessage = null;\n    }\n    append(buffer) {\n        this.chunksTotalSize += buffer.length;\n        this.chunks.push(buffer);\n    }\n    read() {\n        for (;;) {\n            if (this.readFrame()) {\n                if (this.clientMessage.endFrame.isFinalFrame()) {\n                    const message = this.clientMessage;\n                    this.reset();\n                    return message;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    readFrame() {\n        if (this.chunksTotalSize < ClientMessage_1.SIZE_OF_FRAME_LENGTH_AND_FLAGS) {\n            // we don't have even the frame length and flags ready\n            return false;\n        }\n        if (this.frameSize === 0) {\n            this.readFrameSizeAndFlags();\n        }\n        if (this.chunksTotalSize < this.frameSize) {\n            return false;\n        }\n        let buf = this.chunks.length === 1 ? this.chunks[0] : Buffer.concat(this.chunks, this.chunksTotalSize);\n        if (this.chunksTotalSize > this.frameSize) {\n            if (this.chunks.length === 1) {\n                this.chunks[0] = buf.slice(this.frameSize);\n            }\n            else {\n                this.chunks = [buf.slice(this.frameSize)];\n            }\n            buf = buf.slice(ClientMessage_1.SIZE_OF_FRAME_LENGTH_AND_FLAGS, this.frameSize);\n        }\n        else {\n            this.chunks = [];\n            buf = buf.slice(ClientMessage_1.SIZE_OF_FRAME_LENGTH_AND_FLAGS);\n        }\n        this.chunksTotalSize -= this.frameSize;\n        this.frameSize = 0;\n        // No need to reset flags since it will be overwritten on the next readFrameSizeAndFlags call.\n        const frame = new ClientMessage_1.Frame(buf, this.flags);\n        if (this.clientMessage == null) {\n            this.clientMessage = ClientMessage_1.ClientMessage.createForDecode(frame);\n        }\n        else {\n            this.clientMessage.addFrame(frame);\n        }\n        return true;\n    }\n    reset() {\n        this.clientMessage = null;\n    }\n    readFrameSizeAndFlags() {\n        if (this.chunks[0].length >= ClientMessage_1.SIZE_OF_FRAME_LENGTH_AND_FLAGS) {\n            this.frameSize = this.chunks[0].readInt32LE(0);\n            this.flags = this.chunks[0].readUInt16LE(BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n            return;\n        }\n        let readChunksSize = 0;\n        for (let i = 0; i < this.chunks.length; i++) {\n            readChunksSize += this.chunks[i].length;\n            if (readChunksSize >= ClientMessage_1.SIZE_OF_FRAME_LENGTH_AND_FLAGS) {\n                const merged = Buffer.concat(this.chunks.slice(0, i + 1), readChunksSize);\n                this.frameSize = merged.readInt32LE(0);\n                this.flags = merged.readUInt16LE(BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n                return;\n            }\n        }\n        throw new Error('Detected illegal internal call in ClientMessageReader!');\n    }\n}\nexports.ClientMessageReader = ClientMessageReader;\n/** @internal */\nclass FragmentedClientMessageHandler {\n    constructor(logger) {\n        this.fragmentedMessages = new Map();\n        this.logger = logger;\n    }\n    handleFragmentedMessage(clientMessage, callback) {\n        const fragmentationFrame = clientMessage.startFrame;\n        const fragmentationId = clientMessage.getFragmentationId();\n        clientMessage.dropFragmentationFrame();\n        if (fragmentationFrame.hasBeginFragmentFlag()) {\n            this.fragmentedMessages.set(fragmentationId, clientMessage);\n        }\n        else {\n            const existingMessage = this.fragmentedMessages.get(fragmentationId);\n            if (existingMessage == null) {\n                this.logger.debug('FragmentedClientMessageHandler', 'A fragmented message without the begin part is received. Fragmentation id: ' + fragmentationId);\n                return;\n            }\n            existingMessage.merge(clientMessage);\n            if (fragmentationFrame.hasEndFragmentFlag()) {\n                this.fragmentedMessages.delete(fragmentationId);\n                callback(existingMessage);\n            }\n        }\n    }\n}\nexports.FragmentedClientMessageHandler = FragmentedClientMessageHandler;\n/** @internal */\nclass ClientConnection {\n    constructor(client, remoteAddress, socket, connectionId) {\n        this.startTime = Date.now();\n        const enablePipelining = client.getConfig().properties[PROPERTY_PIPELINING_ENABLED];\n        const pipeliningThreshold = client.getConfig().properties[PROPERTY_PIPELINING_THRESHOLD];\n        const noDelay = client.getConfig().properties[PROPERTY_NO_DELAY];\n        socket.setNoDelay(noDelay);\n        this.client = client;\n        this.socket = socket;\n        this.remoteAddress = remoteAddress;\n        this.localAddress = new core_1.AddressImpl(socket.localAddress, socket.localPort);\n        this.lastReadTimeMillis = 0;\n        this.closedTime = 0;\n        this.connectedServerVersion = BuildInfo_1.BuildInfo.UNKNOWN_VERSION_ID;\n        this.writer = enablePipelining ? new PipelinedWriter(socket, pipeliningThreshold) : new DirectWriter(socket);\n        this.writer.on('write', () => {\n            this.lastWriteTimeMillis = Date.now();\n        });\n        this.reader = new ClientMessageReader();\n        this.connectionId = connectionId;\n        this.logger = this.client.getLoggingService().getLogger();\n        this.fragmentedMessageHandler = new FragmentedClientMessageHandler(this.logger);\n    }\n    /**\n     * Returns the address of local port that is associated with this connection.\n     * @returns\n     */\n    getLocalAddress() {\n        return this.localAddress;\n    }\n    /**\n     * Returns the address of remote node that is associated with this connection.\n     * @returns\n     */\n    getRemoteAddress() {\n        return this.remoteAddress;\n    }\n    setRemoteAddress(address) {\n        this.remoteAddress = address;\n    }\n    getRemoteUuid() {\n        return this.remoteUuid;\n    }\n    setRemoteUuid(remoteUuid) {\n        this.remoteUuid = remoteUuid;\n    }\n    write(buffer) {\n        const deferred = Util_1.DeferredPromise();\n        this.writer.write(buffer, deferred);\n        return deferred.promise;\n    }\n    setConnectedServerVersion(versionString) {\n        this.connectedServerVersion = BuildInfo_1.BuildInfo.calculateServerVersionFromString(versionString);\n    }\n    getConnectedServerVersion() {\n        return this.connectedServerVersion;\n    }\n    /**\n     * Closes this connection.\n     */\n    close(reason, cause) {\n        if (this.closedTime !== 0) {\n            return;\n        }\n        this.closedTime = Date.now();\n        this.closedCause = cause;\n        this.closedReason = reason;\n        this.logClose();\n        this.socket.end();\n        this.client.getConnectionManager().onConnectionClose(this);\n    }\n    isAlive() {\n        return this.closedTime === 0;\n    }\n    getStartTime() {\n        return this.startTime;\n    }\n    getLastReadTimeMillis() {\n        return this.lastReadTimeMillis;\n    }\n    getLastWriteTimeMillis() {\n        return this.lastWriteTimeMillis;\n    }\n    equals(other) {\n        if (other == null) {\n            return false;\n        }\n        return this.connectionId === other.connectionId;\n    }\n    toString() {\n        return 'ClientConnection{'\n            + 'alive=' + this.isAlive()\n            + ', connectionId=' + this.connectionId\n            + ', remoteAddress=' + this.remoteAddress\n            + '}';\n    }\n    /**\n     * Registers a function to pass received data on 'data' events on this connection.\n     * @param callback\n     */\n    registerResponseCallback(callback) {\n        this.socket.on('data', (buffer) => {\n            this.lastReadTimeMillis = Date.now();\n            this.reader.append(buffer);\n            let clientMessage = this.reader.read();\n            while (clientMessage !== null) {\n                if (clientMessage.startFrame.hasUnfragmentedMessageFlag()) {\n                    callback(clientMessage);\n                }\n                else {\n                    this.fragmentedMessageHandler.handleFragmentedMessage(clientMessage, callback);\n                }\n                clientMessage = this.reader.read();\n            }\n        });\n    }\n    logClose() {\n        let message = this.toString() + ' closed. Reason: ';\n        if (this.closedReason != null) {\n            message += this.closedReason;\n        }\n        else if (this.closedCause != null) {\n            message += this.closedCause.name + '[' + this.closedCause.message + ']';\n        }\n        else {\n            message += 'Socket explicitly closed';\n        }\n        if (this.client.getLifecycleService().isRunning()) {\n            if (this.closedCause == null) {\n                this.logger.info('Connection', message);\n            }\n            else {\n                this.logger.warn('Connection', message);\n            }\n        }\n        else {\n            this.logger.trace('Connection', message);\n        }\n    }\n}\nexports.ClientConnection = ClientConnection;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/network/ClientConnection.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/network/ClientConnectionManager.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/network/ClientConnectionManager.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientConnectionManager = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst ClientConnection_1 = __webpack_require__(/*! ./ClientConnection */ \"../shared/node_modules/hazelcast-client/lib/network/ClientConnection.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst BasicSSLOptionsFactory_1 = __webpack_require__(/*! ../connection/BasicSSLOptionsFactory */ \"../shared/node_modules/hazelcast-client/lib/connection/BasicSSLOptionsFactory.js\");\nconst HeartbeatManager_1 = __webpack_require__(/*! ./HeartbeatManager */ \"../shared/node_modules/hazelcast-client/lib/network/HeartbeatManager.js\");\nconst UuidUtil_1 = __webpack_require__(/*! ../util/UuidUtil */ \"../shared/node_modules/hazelcast-client/lib/util/UuidUtil.js\");\nconst WaitStrategy_1 = __webpack_require__(/*! ./WaitStrategy */ \"../shared/node_modules/hazelcast-client/lib/network/WaitStrategy.js\");\nconst ConnectionStrategyConfig_1 = __webpack_require__(/*! ../config/ConnectionStrategyConfig */ \"../shared/node_modules/hazelcast-client/lib/config/ConnectionStrategyConfig.js\");\nconst LifecycleService_1 = __webpack_require__(/*! ../LifecycleService */ \"../shared/node_modules/hazelcast-client/lib/LifecycleService.js\");\nconst BuildInfo_1 = __webpack_require__(/*! ../BuildInfo */ \"../shared/node_modules/hazelcast-client/lib/BuildInfo.js\");\nconst ClientAuthenticationCustomCodec_1 = __webpack_require__(/*! ../codec/ClientAuthenticationCustomCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientAuthenticationCustomCodec.js\");\nconst ClientAuthenticationCodec_1 = __webpack_require__(/*! ../codec/ClientAuthenticationCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientAuthenticationCodec.js\");\nconst AuthenticationStatus_1 = __webpack_require__(/*! ../protocol/AuthenticationStatus */ \"../shared/node_modules/hazelcast-client/lib/protocol/AuthenticationStatus.js\");\nconst InvocationService_1 = __webpack_require__(/*! ../invocation/InvocationService */ \"../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js\");\nconst CONNECTION_REMOVED_EVENT_NAME = 'connectionRemoved';\nconst CONNECTION_ADDED_EVENT_NAME = 'connectionAdded';\nconst CLIENT_TYPE = 'NJS';\nconst SERIALIZATION_VERSION = 1;\nconst SET_TIMEOUT_MAX_DELAY = 2147483647;\nconst BINARY_PROTOCOL_VERSION = Buffer.from('CP2');\nvar ClientState;\n(function (ClientState) {\n    /**\n     * Clients start with this state. Once a client connects to a cluster,\n     * it directly switches to {@link INITIALIZED_ON_CLUSTER} instead of\n     * {@link CONNECTED_TO_CLUSTER} because on startup a client has no\n     * local state to send to the cluster.\n     */\n    ClientState[ClientState[\"INITIAL\"] = 0] = \"INITIAL\";\n    /**\n     * When a client switches to a new cluster, it moves to this state.\n     * It means that the client has connected to a new cluster but not sent\n     * its local state to the new cluster yet.\n     */\n    ClientState[ClientState[\"CONNECTED_TO_CLUSTER\"] = 1] = \"CONNECTED_TO_CLUSTER\";\n    /**\n     * When a client sends its local state to the cluster it has connected,\n     * it switches to this state. When a client loses all connections to\n     * the current cluster and connects to a new cluster, its state goes\n     * back to {@link CONNECTED_TO_CLUSTER}.\n     * <p>\n     * Invocations are allowed in this state.\n     */\n    ClientState[ClientState[\"INITIALIZED_ON_CLUSTER\"] = 2] = \"INITIALIZED_ON_CLUSTER\";\n})(ClientState || (ClientState = {}));\n/**\n * Maintains connections between the client and members of the cluster.\n * @internal\n */\nclass ClientConnectionManager extends events_1.EventEmitter {\n    constructor(client) {\n        super();\n        this.connectionIdCounter = 0;\n        this.alive = false;\n        this.clientUuid = UuidUtil_1.UuidUtil.generate(false);\n        this.activeConnections = new Map();\n        this.pendingConnections = new Map();\n        this.clientState = ClientState.INITIAL;\n        this.connectingAddresses = new Set();\n        this.client = client;\n        this.loadBalancer = client.getLoadBalancer();\n        this.labels = client.getConfig().clientLabels;\n        this.logger = this.client.getLoggingService().getLogger();\n        this.connectionTimeoutMillis = this.initConnectionTimeoutMillis();\n        this.heartbeatManager = new HeartbeatManager_1.HeartbeatManager(client, this);\n        this.authenticationTimeout = this.heartbeatManager.getHeartbeatTimeout();\n        this.shuffleMemberList = client.getConfig().properties['hazelcast.client.shuffle.member.list'];\n        this.isSmartRoutingEnabled = client.getConfig().network.smartRouting;\n        this.waitStrategy = this.initWaitStrategy(client.getConfig());\n        const connectionStrategyConfig = client.getConfig().connectionStrategy;\n        this.asyncStart = connectionStrategyConfig.asyncStart;\n        this.reconnectMode = connectionStrategyConfig.reconnectMode;\n    }\n    start() {\n        if (this.alive) {\n            return Promise.resolve();\n        }\n        this.alive = true;\n        this.heartbeatManager.start();\n        return this.connectToCluster()\n            .then(() => {\n            if (this.isSmartRoutingEnabled) {\n                this.reconnectToMembersTask = Util_1.scheduleWithRepetition(this.reconnectToMembers.bind(this), 1000, 1000);\n            }\n        });\n    }\n    connectToAllClusterMembers() {\n        if (!this.isSmartRoutingEnabled) {\n            return Promise.resolve();\n        }\n        const members = this.client.getClusterService().getMembers();\n        return this.tryConnectToAllClusterMembers(members);\n    }\n    shutdown() {\n        if (!this.alive) {\n            return;\n        }\n        this.alive = false;\n        if (this.isSmartRoutingEnabled) {\n            Util_1.cancelRepetitionTask(this.reconnectToMembersTask);\n        }\n        this.pendingConnections.forEach((pending) => {\n            pending.reject(new core_1.ClientNotActiveError('Hazelcast client is shutting down'));\n        });\n        this.activeConnections.forEach((connection) => {\n            connection.close('Hazelcast client is shutting down', null);\n        });\n        this.removeAllListeners(CONNECTION_REMOVED_EVENT_NAME);\n        this.removeAllListeners(CONNECTION_ADDED_EVENT_NAME);\n        this.heartbeatManager.shutdown();\n    }\n    getConnection(uuid) {\n        return this.activeConnections.get(uuid.toString());\n    }\n    checkIfInvocationAllowed() {\n        const state = this.clientState;\n        if (state === ClientState.INITIALIZED_ON_CLUSTER && this.activeConnections.size > 0) {\n            return null;\n        }\n        let error;\n        if (state === ClientState.INITIAL) {\n            if (this.asyncStart) {\n                error = new core_1.ClientOfflineError();\n            }\n            else {\n                error = new core_1.IOError('No connection found to cluster since the client is starting.');\n            }\n        }\n        else if (this.reconnectMode === ConnectionStrategyConfig_1.ReconnectMode.ASYNC) {\n            error = new core_1.ClientOfflineError();\n        }\n        else {\n            error = new core_1.IOError('No connection found to cluster.');\n        }\n        return error;\n    }\n    getActiveConnections() {\n        return Array.from(this.activeConnections.values());\n    }\n    isAlive() {\n        return this.alive;\n    }\n    getClientUuid() {\n        return this.clientUuid;\n    }\n    getOrConnect(address) {\n        if (!this.client.getLifecycleService().isRunning()) {\n            return Promise.reject(new core_1.ClientNotActiveError('Client is not active.'));\n        }\n        const connection = this.getConnectionFromAddress(address);\n        if (connection) {\n            return Promise.resolve(connection);\n        }\n        const addressKey = address.toString();\n        const pendingConnection = this.pendingConnections.get(addressKey);\n        if (pendingConnection) {\n            return pendingConnection.promise;\n        }\n        const connectionResolver = Util_1.DeferredPromise();\n        this.pendingConnections.set(addressKey, connectionResolver);\n        const processResponseCallback = (msg) => {\n            this.client.getInvocationService().processResponse(msg);\n        };\n        let translatedAddress;\n        let clientConnection;\n        this.translate(address)\n            .then((translated) => {\n            translatedAddress = translated;\n            if (translatedAddress == null) {\n                throw new RangeError(`Address Translator could not translate address ${address}`);\n            }\n            return this.triggerConnect(translatedAddress);\n        })\n            .then((socket) => {\n            clientConnection = new ClientConnection_1.ClientConnection(this.client, translatedAddress, socket, this.connectionIdCounter++);\n            return this.initiateCommunication(socket);\n        })\n            .then(() => clientConnection.registerResponseCallback(processResponseCallback))\n            .then(() => this.authenticateOnCluster(clientConnection))\n            .then(() => connectionResolver.resolve(clientConnection))\n            .catch((error) => connectionResolver.reject(error));\n        return connectionResolver.promise\n            .timeout(this.connectionTimeoutMillis, new core_1.HazelcastError(`Connection timed out to address ${address}.`))\n            .finally(() => this.pendingConnections.delete(addressKey));\n    }\n    getRandomConnection() {\n        if (this.isSmartRoutingEnabled) {\n            const member = this.loadBalancer.next();\n            if (member != null) {\n                const connection = this.getConnection(member.uuid);\n                if (connection != null) {\n                    return connection;\n                }\n            }\n        }\n        const iterator = this.activeConnections.values();\n        const next = iterator.next();\n        if (!next.done) {\n            return next.value;\n        }\n        else {\n            return null;\n        }\n    }\n    onConnectionClose(connection) {\n        const endpoint = connection.getRemoteAddress();\n        const memberUuid = connection.getRemoteUuid();\n        if (endpoint == null) {\n            this.logger.trace('ConnectionManager', 'Destroying ' + connection +\n                ', but it has endpoint set to null -> not removing it from a connection map');\n            return;\n        }\n        if (memberUuid != null && this.activeConnections.delete(memberUuid.toString())) {\n            this.logger.info('ConnectionManager', 'Removed connection to endpoint: ' +\n                endpoint + ':' + memberUuid + ', connection: ' + connection);\n            if (this.activeConnections.size === 0) {\n                if (this.clientState === ClientState.INITIALIZED_ON_CLUSTER) {\n                    this.emitLifecycleEvent(LifecycleService_1.LifecycleState.DISCONNECTED);\n                }\n                this.triggerClusterReconnection();\n            }\n            this.emitConnectionRemovedEvent(connection);\n        }\n        else {\n            this.logger.trace('ConnectionManager', 'Destroying a connection, but there is no mapping ' +\n                endpoint + ':' + memberUuid + '->' + connection + ' in the connection map.)');\n        }\n    }\n    initWaitStrategy(config) {\n        const connectionStrategyConfig = config.connectionStrategy;\n        const retryConfig = connectionStrategyConfig.connectionRetry;\n        return new WaitStrategy_1.WaitStrategy(retryConfig.initialBackoffMillis, retryConfig.maxBackoffMillis, retryConfig.multiplier, retryConfig.clusterConnectTimeoutMillis, retryConfig.jitter, this.logger);\n    }\n    initConnectionTimeoutMillis() {\n        const networkConfig = this.client.getConfig().network;\n        const connTimeout = networkConfig.connectionTimeout;\n        return connTimeout === 0 ? SET_TIMEOUT_MAX_DELAY : connTimeout;\n    }\n    connectToCluster() {\n        if (this.asyncStart) {\n            return this.submitConnectToClusterTask();\n        }\n        else {\n            return this.doConnectToCluster();\n        }\n    }\n    submitConnectToClusterTask() {\n        if (this.connectToClusterTaskSubmitted) {\n            return Promise.resolve();\n        }\n        this.doConnectToCluster()\n            .then(() => {\n            this.connectToClusterTaskSubmitted = false;\n            if (this.activeConnections.size === 0) {\n                this.logger.warn('ConnectionManager', 'No connection to cluster ' + this.clusterId);\n                return this.submitConnectToClusterTask();\n            }\n        })\n            .catch((error) => {\n            this.logger.warn('ConnectionManager', 'Could not connect to any cluster, shutting down ' +\n                'the client: ' + error.message);\n            this.shutdownClient();\n        });\n        this.connectToClusterTaskSubmitted = true;\n        return Promise.resolve();\n    }\n    doConnectToCluster() {\n        const triedAddresses = new Set();\n        this.waitStrategy.reset();\n        return this.tryConnectingToAddresses(triedAddresses)\n            .then((isConnected) => {\n            if (isConnected) {\n                return;\n            }\n            this.logger.info('ConnectionManager', 'Unable to connect any address from the cluster ' +\n                'with the name: ' + this.client.getConfig().clusterName +\n                '. The following addresses were tried: ' +\n                Array.from(triedAddresses));\n            const message = this.client.getLifecycleService().isRunning()\n                ? 'Unable to connect any cluster.' : 'Client is being shutdown.';\n            throw new core_1.IllegalStateError(message);\n        });\n    }\n    tryConnectingToAddresses(triedAddresses) {\n        return this.getPossibleMemberAddresses()\n            .then((addresses) => {\n            return this.tryConnectingToAddress(0, addresses, triedAddresses);\n        })\n            .then((isConnected) => {\n            if (isConnected) {\n                return true;\n            }\n            // If the address providers load no addresses (which seems to be possible),\n            // then the above loop is not entered and the lifecycle check is missing,\n            // hence we need to repeat the same check at this point.\n            if (!this.client.getLifecycleService().isRunning()) {\n                return Promise.reject(new core_1.ClientNotActiveError('Client is not active.'));\n            }\n            return this.waitStrategy.sleep()\n                .then((notTimedOut) => {\n                if (notTimedOut) {\n                    return this.tryConnectingToAddresses(triedAddresses);\n                }\n                return false;\n            });\n        })\n            .catch(core_1.ClientNotAllowedInClusterError, core_1.InvalidConfigurationError, (error) => {\n            this.logger.warn('ConnectionManager', 'Stopped trying on the cluster: ' +\n                this.client.getConfig().clusterName + ' reason: ' + error.message);\n            return false;\n        });\n    }\n    tryConnectingToAddress(index, addresses, triedAddresses) {\n        if (index >= addresses.length) {\n            return Promise.resolve(false);\n        }\n        const address = addresses[index];\n        if (!this.client.getLifecycleService().isRunning()) {\n            return Promise.reject(new core_1.ClientNotActiveError('Client is not active.'));\n        }\n        triedAddresses.add(address.toString());\n        return this.connect(address)\n            .then((connection) => {\n            if (connection != null) {\n                return true;\n            }\n            return this.tryConnectingToAddress(index + 1, addresses, triedAddresses);\n        });\n    }\n    connect(address) {\n        this.logger.info('ConnectionManager', 'Trying to connect to ' + address);\n        return this.getOrConnect(address)\n            .catch((error) => {\n            this.logger.warn('ConnectionManager', 'Error during initial connection to ' + address + ' ' +\n                error);\n            return null;\n        });\n    }\n    emitLifecycleEvent(state) {\n        this.client.getLifecycleService().emitLifecycleEvent(state);\n    }\n    getPossibleMemberAddresses() {\n        const addresses = this.client.getClusterService().getMembers()\n            .map(((member) => member.address.toString()));\n        if (this.shuffleMemberList) {\n            Util_1.shuffleArray(addresses);\n        }\n        const addressProvider = this.client.getAddressProvider();\n        return addressProvider.loadAddresses()\n            .catch((error) => {\n            this.logger.warn('ConnectionManager', 'Error from AddressProvider ' + addressProvider +\n                ', error: ' + error.message);\n            return new Array();\n        })\n            .then((providerAddresses) => {\n            if (this.shuffleMemberList) {\n                Util_1.shuffleArray(providerAddresses);\n            }\n            const allAddresses = Array.from(new Set([...addresses, ...providerAddresses]));\n            const result = [];\n            for (const address of allAddresses) {\n                result.push(...Util_1.AddressHelper.getSocketAddresses(address));\n            }\n            return result;\n        });\n    }\n    getConnectionFromAddress(address) {\n        for (const connection of this.getActiveConnections()) {\n            if (connection.getRemoteAddress().equals(address)) {\n                return connection;\n            }\n        }\n        return null;\n    }\n    initiateCommunication(socket) {\n        // Send the protocol version\n        const deferred = Util_1.DeferredPromise();\n        socket.write(BINARY_PROTOCOL_VERSION, (err) => {\n            if (err) {\n                deferred.reject(err);\n            }\n            deferred.resolve();\n        });\n        return deferred.promise;\n    }\n    triggerConnect(translatedAddress) {\n        if (this.client.getConfig().network.ssl.enabled) {\n            if (this.client.getConfig().network.ssl.sslOptions) {\n                const opts = this.client.getConfig().network.ssl.sslOptions;\n                return this.connectTLSSocket(translatedAddress, opts);\n            }\n            else if (this.client.getConfig().network.ssl.sslOptionsFactory\n                || this.client.getConfig().network.ssl.sslOptionsFactoryProperties) {\n                const factoryProperties = this.client.getConfig().network.ssl.sslOptionsFactoryProperties;\n                let factory = this.client.getConfig().network.ssl.sslOptionsFactory;\n                if (factory == null) {\n                    factory = new BasicSSLOptionsFactory_1.BasicSSLOptionsFactory();\n                }\n                return factory.init(factoryProperties).then(() => {\n                    return this.connectTLSSocket(translatedAddress, factory.getSSLOptions());\n                });\n            }\n            else {\n                // the default behavior when ssl is enabled\n                const opts = this.client.getConfig().network.ssl.sslOptions = {\n                    checkServerIdentity: () => null,\n                    rejectUnauthorized: true,\n                };\n                return this.connectTLSSocket(translatedAddress, opts);\n            }\n        }\n        else {\n            return this.connectNetSocket(translatedAddress);\n        }\n    }\n    connectTLSSocket(address, configOpts) {\n        const connectionResolver = Util_1.DeferredPromise();\n        const socket = tls.connect(address.port, address.host, configOpts);\n        socket.once('secureConnect', () => {\n            connectionResolver.resolve(socket);\n        });\n        socket.on('error', (e) => {\n            this.logger.warn('ConnectionManager', 'Could not connect to address ' + address.toString(), e);\n            connectionResolver.reject(e);\n            if (e.code === 'EPIPE' || e.code === 'ECONNRESET') {\n                const connection = this.getConnectionFromAddress(address);\n                if (connection != null) {\n                    this.onConnectionClose(connection);\n                }\n            }\n        });\n        return connectionResolver.promise;\n    }\n    connectNetSocket(address) {\n        const connectionResolver = Util_1.DeferredPromise();\n        const socket = net.connect(address.port, address.host);\n        socket.once('connect', () => {\n            connectionResolver.resolve(socket);\n        });\n        socket.on('error', (e) => {\n            this.logger.warn('ConnectionManager', 'Could not connect to address ' + address.toString(), e);\n            connectionResolver.reject(e);\n            if (e.code === 'EPIPE' || e.code === 'ECONNRESET') {\n                const connection = this.getConnectionFromAddress(address);\n                if (connection != null) {\n                    this.onConnectionClose(connection);\n                }\n            }\n        });\n        return connectionResolver.promise;\n    }\n    emitConnectionAddedEvent(connection) {\n        this.emit(CONNECTION_ADDED_EVENT_NAME, connection);\n    }\n    emitConnectionRemovedEvent(connection) {\n        this.emit(CONNECTION_REMOVED_EVENT_NAME, connection);\n    }\n    translate(target) {\n        const addressProvider = this.client.getAddressProvider();\n        return addressProvider.translate(target)\n            .catch((error) => {\n            this.logger.warn('ConnectionManager', 'Failed to translate address ' + target +\n                ' via address provider ' + error.message);\n            return Promise.reject(error);\n        });\n    }\n    triggerClusterReconnection() {\n        if (this.reconnectMode === ConnectionStrategyConfig_1.ReconnectMode.OFF) {\n            this.logger.info('ConnectionManager', 'RECONNECT MODE is off. Shutting down the client.');\n            this.shutdownClient();\n            return;\n        }\n        if (this.client.getLifecycleService().isRunning()) {\n            this.submitConnectToClusterTask();\n        }\n    }\n    shutdownClient() {\n        try {\n            this.client.getLifecycleService().shutdown();\n        }\n        catch (e) {\n            this.logger.error('ConnectionManager', `Error during client shutdown ${e}`);\n        }\n    }\n    // This method makes sure that the smart client has connection to all cluster members.\n    // This is called periodically.\n    reconnectToMembers() {\n        if (!this.client.getLifecycleService().isRunning()) {\n            return;\n        }\n        for (const member of this.client.getClusterService().getMembers()) {\n            const address = member.address;\n            if (this.getConnectionFromAddress(address) == null) {\n                if (this.connectingAddresses.has(address)) {\n                    continue;\n                }\n                if (this.getConnection(member.uuid) == null) {\n                    this.connectingAddresses.add(address);\n                    this.getOrConnect(address)\n                        .catch(() => {\n                        // no-op\n                    })\n                        .finally(() => {\n                        this.connectingAddresses.delete(address);\n                    });\n                }\n            }\n        }\n    }\n    authenticateOnCluster(connection) {\n        const request = this.encodeAuthenticationRequest();\n        const invocation = new InvocationService_1.Invocation(this.client, request);\n        invocation.connection = connection;\n        return this.client.getInvocationService()\n            .invokeUrgent(invocation)\n            .timeout(this.authenticationTimeout)\n            .catch((e) => {\n            connection.close('Failed to authenticate connection', e);\n            throw e;\n        })\n            .then((responseMessage) => {\n            const response = ClientAuthenticationCodec_1.ClientAuthenticationCodec.decodeResponse(responseMessage);\n            if (response.status === AuthenticationStatus_1.AuthenticationStatus.AUTHENTICATED) {\n                this.handleSuccessfulAuth(connection, response);\n            }\n            else {\n                let error;\n                switch (response.status) {\n                    case AuthenticationStatus_1.AuthenticationStatus.CREDENTIALS_FAILED:\n                        error = new core_1.AuthenticationError('Authentication failed. The configured cluster name on ' +\n                            'the client does not match the one configured in the cluster or ' +\n                            'the credentials set in the client security config could not be authenticated');\n                        break;\n                    case AuthenticationStatus_1.AuthenticationStatus.SERIALIZATION_VERSION_MISMATCH:\n                        error = new core_1.IllegalStateError('Server serialization version ' +\n                            'does not match to client.');\n                        break;\n                    case AuthenticationStatus_1.AuthenticationStatus.NOT_ALLOWED_IN_CLUSTER:\n                        error = new core_1.ClientNotAllowedInClusterError('Client is not allowed in the cluster');\n                        break;\n                    default:\n                        error = new core_1.AuthenticationError('Authentication status code not supported. Status: ' +\n                            response.status);\n                }\n                connection.close('Failed to authenticate connection', error);\n                return Promise.reject(error);\n            }\n        });\n    }\n    handleSuccessfulAuth(connection, response) {\n        this.checkPartitionCount(response.partitionCount);\n        connection.setConnectedServerVersion(response.serverHazelcastVersion);\n        connection.setRemoteAddress(response.address);\n        connection.setRemoteUuid(response.memberUuid);\n        const newClusterId = response.clusterId;\n        const initialConnection = this.activeConnections.size === 0;\n        const changedCluster = initialConnection && this.clusterId != null && !newClusterId.equals(this.clusterId);\n        if (changedCluster) {\n            this.logger.warn('ConnectionManager', 'Switching from current cluster: ' + this.clusterId +\n                ' to new cluster: ' + newClusterId);\n            this.client.onClusterRestart();\n        }\n        this.activeConnections.set(response.memberUuid.toString(), connection);\n        if (initialConnection) {\n            this.clusterId = newClusterId;\n            if (changedCluster) {\n                this.clientState = ClientState.CONNECTED_TO_CLUSTER;\n                this.initializeClientOnCluster(newClusterId);\n            }\n            else {\n                this.clientState = ClientState.INITIALIZED_ON_CLUSTER;\n                this.emitLifecycleEvent(LifecycleService_1.LifecycleState.CONNECTED);\n            }\n        }\n        this.logger.info('ConnectionManager', 'Authenticated with server ' +\n            response.address + ':' + response.memberUuid + ', server version: ' + response.serverHazelcastVersion +\n            ', local address: ' + connection.getLocalAddress());\n        this.emitConnectionAddedEvent(connection);\n        // It could happen that this connection is already closed and\n        // onConnectionClose() is called even before the block\n        // above is executed. In this case, now we have a closed but registered\n        // connection. We do a final check here to remove this connection\n        // if needed.\n        if (!connection.isAlive()) {\n            this.onConnectionClose(connection);\n        }\n    }\n    encodeAuthenticationRequest() {\n        const clusterName = this.client.getConfig().clusterName;\n        const clientVersion = BuildInfo_1.BuildInfo.getClientVersion();\n        const customCredentials = this.client.getConfig().customCredentials;\n        const clientName = this.client.getName();\n        let clientMessage;\n        if (customCredentials != null) {\n            const credentialsPayload = this.client.getSerializationService().toData(customCredentials).toBuffer();\n            clientMessage = ClientAuthenticationCustomCodec_1.ClientAuthenticationCustomCodec.encodeRequest(clusterName, credentialsPayload, this.clientUuid, CLIENT_TYPE, SERIALIZATION_VERSION, clientVersion, clientName, this.labels);\n        }\n        else {\n            clientMessage = ClientAuthenticationCodec_1.ClientAuthenticationCodec.encodeRequest(clusterName, null, null, this.clientUuid, CLIENT_TYPE, SERIALIZATION_VERSION, clientVersion, clientName, this.labels);\n        }\n        return clientMessage;\n    }\n    checkPartitionCount(newPartitionCount) {\n        const partitionService = this.client.getPartitionService();\n        if (!partitionService.checkAndSetPartitionCount(newPartitionCount)) {\n            throw new core_1.ClientNotAllowedInClusterError('Client can not work with this cluster because it has a different ' +\n                'partition count. Expected partition count: ' + partitionService.getPartitionCount() +\n                ', member partition count: ' + newPartitionCount);\n        }\n    }\n    initializeClientOnCluster(targetClusterId) {\n        if (!targetClusterId.equals(this.clusterId)) {\n            this.logger.warn('ConnectionManager', 'Won\\'t send client state to cluster: ' + targetClusterId +\n                ' because switched to a new cluster: ' + this.clusterId);\n            return;\n        }\n        return this.client.sendStateToCluster()\n            .then(() => {\n            if (targetClusterId.equals(this.clusterId)) {\n                this.logger.trace('ConnectionManager', 'Client state is sent to cluster: ' +\n                    targetClusterId);\n                this.clientState = ClientState.INITIALIZED_ON_CLUSTER;\n                this.emitLifecycleEvent(LifecycleService_1.LifecycleState.CONNECTED);\n            }\n            else {\n                this.logger.warn('ConnectionManager', 'Cannot set client state to initialized on ' +\n                    'cluster because current cluster id: ' + this.clusterId + ' is different than expected cluster id: ' +\n                    targetClusterId);\n            }\n        })\n            .catch((error) => {\n            const clusterName = this.client.getConfig().clusterName;\n            this.logger.warn('ConnectionManager', 'Failure during sending state to the cluster: ' +\n                error.message);\n            if (targetClusterId.equals(this.clusterId)) {\n                this.logger.warn('ConnectionManager', 'Retrying sending state to the cluster: ' +\n                    targetClusterId + ', name: ' + clusterName);\n                return this.initializeClientOnCluster(targetClusterId);\n            }\n        });\n    }\n    tryConnectToAllClusterMembers(members) {\n        const promises = [];\n        for (const member of members) {\n            promises.push(this.getOrConnect(member.address)\n                .catch(() => {\n                // No-op\n            }));\n        }\n        return Promise.all(promises)\n            .then(() => undefined);\n    }\n}\nexports.ClientConnectionManager = ClientConnectionManager;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/network/ClientConnectionManager.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/network/HeartbeatManager.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/network/HeartbeatManager.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HeartbeatManager = void 0;\nconst ClientPingCodec_1 = __webpack_require__(/*! ../codec/ClientPingCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientPingCodec.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst InvocationService_1 = __webpack_require__(/*! ../invocation/InvocationService */ \"../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js\");\nconst PROPERTY_HEARTBEAT_INTERVAL = 'hazelcast.client.heartbeat.interval';\nconst PROPERTY_HEARTBEAT_TIMEOUT = 'hazelcast.client.heartbeat.timeout';\n/**\n * HeartbeatManager manager used by connection manager.\n * @internal\n */\nclass HeartbeatManager {\n    constructor(client, connectionManager) {\n        this.client = client;\n        this.connectionManager = connectionManager;\n        this.logger = this.client.getLoggingService().getLogger();\n        this.heartbeatInterval = this.client.getConfig().properties[PROPERTY_HEARTBEAT_INTERVAL];\n        this.heartbeatTimeout = this.client.getConfig().properties[PROPERTY_HEARTBEAT_TIMEOUT];\n    }\n    /**\n     * Starts sending periodic heartbeat operations.\n     */\n    start() {\n        this.timer = Util_1.scheduleWithRepetition(this.heartbeatFunction.bind(this), this.heartbeatInterval, this.heartbeatInterval);\n    }\n    /**\n     * Cancels the periodic heartbeat operation.\n     */\n    shutdown() {\n        Util_1.cancelRepetitionTask(this.timer);\n    }\n    /**\n     * Returns the heartbeat timeout in milliseconds.\n     */\n    getHeartbeatTimeout() {\n        return this.heartbeatTimeout;\n    }\n    heartbeatFunction() {\n        if (!this.connectionManager.isAlive()) {\n            return;\n        }\n        const now = Date.now();\n        const activeConnections = this.connectionManager.getActiveConnections();\n        for (const connection of activeConnections) {\n            this.checkConnection(now, connection);\n        }\n    }\n    checkConnection(now, connection) {\n        if (!connection.isAlive()) {\n            return;\n        }\n        if (now - connection.getLastReadTimeMillis() > this.heartbeatTimeout) {\n            if (connection.isAlive()) {\n                this.logger.warn('HeartbeatManager', `Heartbeat failed over connection: ${connection}`);\n                this.onHeartbeatStopped(connection, 'Heartbeat timed out');\n            }\n        }\n        if (now - connection.getLastWriteTimeMillis() > this.heartbeatInterval) {\n            const request = ClientPingCodec_1.ClientPingCodec.encodeRequest();\n            const invocation = new InvocationService_1.Invocation(this.client, request);\n            invocation.connection = connection;\n            this.client.getInvocationService()\n                .invokeUrgent(invocation)\n                .catch(() => {\n                // No-op\n            });\n        }\n    }\n    onHeartbeatStopped(connection, reason) {\n        connection.close(reason, new core_1.TargetDisconnectedError(`Heartbeat timed out to connection ${connection}`));\n    }\n}\nexports.HeartbeatManager = HeartbeatManager;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/network/HeartbeatManager.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/network/WaitStrategy.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/network/WaitStrategy.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WaitStrategy = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\n/** @internal */\nclass WaitStrategy {\n    constructor(initialBackoffMillis, maxBackoffMillis, multiplier, clusterConnectTimeoutMillis, jitter, logger) {\n        this.initialBackoffMillis = initialBackoffMillis;\n        this.maxBackoffMillis = maxBackoffMillis;\n        this.multiplier = multiplier;\n        this.clusterConnectTimeoutMillis = clusterConnectTimeoutMillis;\n        this.jitter = jitter;\n        this.logger = logger;\n    }\n    reset() {\n        this.attempt = 0;\n        this.clusterConnectAttemptBegin = Date.now();\n        this.currentBackoffMillis = Math.min(this.maxBackoffMillis, this.initialBackoffMillis);\n    }\n    sleep() {\n        this.attempt++;\n        const currentTimeMillis = Date.now();\n        const timePassed = currentTimeMillis - this.clusterConnectAttemptBegin;\n        if (timePassed > this.clusterConnectTimeoutMillis) {\n            this.logger.warn('WaitStrategy', 'Unable to get live cluster connection, cluster connect timeout (' +\n                this.clusterConnectTimeoutMillis + ' millis) is reached. Attempt ' + this.attempt);\n            return Promise.resolve(false);\n        }\n        // random_between\n        // Random(-jitter * current_backoff, jitter * current_backoff)\n        let actualSleepTime = this.currentBackoffMillis\n            + this.currentBackoffMillis * this.jitter * (2.0 * Math.random() - 1.0);\n        actualSleepTime = Math.min(actualSleepTime, this.clusterConnectTimeoutMillis - timePassed);\n        this.logger.warn('WaitStrategy', 'Unable to get live cluster connection, retry in ' +\n            actualSleepTime + ' ms, attempt: ' + this.attempt + ', cluster connect timeout: ' +\n            this.clusterConnectTimeoutMillis + ' ms, max backoff millis: ' + this.maxBackoffMillis);\n        return Promise.delay(actualSleepTime)\n            .then(() => {\n            this.currentBackoffMillis = Math.min(Math.round(currentTimeMillis * this.multiplier), this.maxBackoffMillis);\n            return true;\n        });\n    }\n}\nexports.WaitStrategy = WaitStrategy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/network/WaitStrategy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/protocol/AnchorDataListHolder.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/protocol/AnchorDataListHolder.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AnchorDataListHolder = void 0;\n/** @internal */\nclass AnchorDataListHolder {\n    constructor(anchorPageList, anchorDataList) {\n        this.anchorPageList = anchorPageList;\n        this.anchorDataList = anchorDataList;\n    }\n    asAnchorList(serializationService) {\n        const anchorObjectList = new Array(this.anchorDataList.length);\n        for (let i = 0; i < this.anchorDataList.length; i++) {\n            const dataEntry = this.anchorDataList[i];\n            const pageNumber = this.anchorPageList[i];\n            const key = serializationService.toObject(dataEntry[0]);\n            const value = serializationService.toObject(dataEntry[1]);\n            anchorObjectList[i] = [pageNumber, [key, value]];\n        }\n        return anchorObjectList;\n    }\n}\nexports.AnchorDataListHolder = AnchorDataListHolder;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/protocol/AnchorDataListHolder.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/protocol/AuthenticationStatus.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/protocol/AuthenticationStatus.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AuthenticationStatus = void 0;\n/**\n * Status codes of authentication results.\n * @internal\n */\nvar AuthenticationStatus;\n(function (AuthenticationStatus) {\n    AuthenticationStatus[AuthenticationStatus[\"AUTHENTICATED\"] = 0] = \"AUTHENTICATED\";\n    AuthenticationStatus[AuthenticationStatus[\"CREDENTIALS_FAILED\"] = 1] = \"CREDENTIALS_FAILED\";\n    AuthenticationStatus[AuthenticationStatus[\"SERIALIZATION_VERSION_MISMATCH\"] = 2] = \"SERIALIZATION_VERSION_MISMATCH\";\n    AuthenticationStatus[AuthenticationStatus[\"NOT_ALLOWED_IN_CLUSTER\"] = 3] = \"NOT_ALLOWED_IN_CLUSTER\";\n})(AuthenticationStatus = exports.AuthenticationStatus || (exports.AuthenticationStatus = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/protocol/AuthenticationStatus.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientMessage = exports.END_FRAME = exports.BEGIN_FRAME = exports.NULL_FRAME = exports.Frame = exports.SIZE_OF_FRAME_LENGTH_AND_FLAGS = exports.IS_BACKUP_AWARE_FLAG = exports.DEFAULT_FLAGS = exports.PARTITION_ID_OFFSET = exports.RESPONSE_BACKUP_ACKS_OFFSET = void 0;\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst FixSizedTypesCodec_1 = __webpack_require__(/*! ../codec/builtin/FixSizedTypesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/FixSizedTypesCodec.js\");\nconst MESSAGE_TYPE_OFFSET = 0;\nconst CORRELATION_ID_OFFSET = MESSAGE_TYPE_OFFSET + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n/** @internal */\nexports.RESPONSE_BACKUP_ACKS_OFFSET = CORRELATION_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\n/** @internal */\nexports.PARTITION_ID_OFFSET = CORRELATION_ID_OFFSET + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst FRAGMENTATION_ID_OFFSET = 0;\n/** @internal */\nexports.DEFAULT_FLAGS = 0;\nconst BEGIN_FRAGMENT_FLAG = 1 << 15;\nconst END_FRAGMENT_FLAG = 1 << 14;\nconst UNFRAGMENTED_MESSAGE = BEGIN_FRAGMENT_FLAG | END_FRAGMENT_FLAG;\nconst IS_FINAL_FLAG = 1 << 13;\nconst BEGIN_DATA_STRUCTURE_FLAG = 1 << 12;\nconst END_DATA_STRUCTURE_FLAG = 1 << 11;\nconst IS_NULL_FLAG = 1 << 10;\nconst IS_EVENT_FLAG = 1 << 9;\n/** @internal */\nexports.IS_BACKUP_AWARE_FLAG = 1 << 8;\nconst IS_BACKUP_EVENT_FLAG = 1 << 7;\n/** @internal */\nexports.SIZE_OF_FRAME_LENGTH_AND_FLAGS = BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES + BitsUtil_1.BitsUtil.SHORT_SIZE_IN_BYTES;\n/** @internal */\nclass Frame {\n    constructor(content, flags) {\n        this.content = content;\n        this.flags = flags || exports.DEFAULT_FLAGS;\n    }\n    static createInitialFrame(size, flags = UNFRAGMENTED_MESSAGE) {\n        return new Frame(Buffer.allocUnsafe(size), flags);\n    }\n    getLength() {\n        return exports.SIZE_OF_FRAME_LENGTH_AND_FLAGS + this.content.length;\n    }\n    copy() {\n        const frame = new Frame(this.content, this.flags);\n        frame.next = this.next;\n        return frame;\n    }\n    deepCopy() {\n        const content = Buffer.from(this.content);\n        const frame = new Frame(content, this.flags);\n        frame.next = this.next;\n        return frame;\n    }\n    isBeginFrame() {\n        return this.isFlagSet(this.flags, BEGIN_DATA_STRUCTURE_FLAG);\n    }\n    isEndFrame() {\n        return this.isFlagSet(this.flags, END_DATA_STRUCTURE_FLAG);\n    }\n    isNullFrame() {\n        return this.isFlagSet(this.flags, IS_NULL_FLAG);\n    }\n    hasEventFlag() {\n        return this.isFlagSet(this.flags, IS_EVENT_FLAG);\n    }\n    hasBackupEventFlag() {\n        return this.isFlagSet(this.flags, IS_BACKUP_EVENT_FLAG);\n    }\n    isFinalFrame() {\n        return this.isFlagSet(this.flags, IS_FINAL_FLAG);\n    }\n    hasUnfragmentedMessageFlag() {\n        return this.isFlagSet(this.flags, UNFRAGMENTED_MESSAGE);\n    }\n    hasBeginFragmentFlag() {\n        return this.isFlagSet(this.flags, BEGIN_FRAGMENT_FLAG);\n    }\n    hasEndFragmentFlag() {\n        return this.isFlagSet(this.flags, END_FRAGMENT_FLAG);\n    }\n    addFlag(flag) {\n        this.flags |= flag;\n    }\n    isFlagSet(flags, flagMask) {\n        const i = flags & flagMask;\n        return i === flagMask;\n    }\n}\nexports.Frame = Frame;\n/** @internal */\nexports.NULL_FRAME = new Frame(Buffer.allocUnsafe(0), IS_NULL_FLAG);\n/** @internal */\nexports.BEGIN_FRAME = new Frame(Buffer.allocUnsafe(0), BEGIN_DATA_STRUCTURE_FLAG);\n/** @internal */\nexports.END_FRAME = new Frame(Buffer.allocUnsafe(0), END_DATA_STRUCTURE_FLAG);\n/** @internal */\nclass ClientMessage {\n    constructor(startFrame, endFrame) {\n        this.startFrame = startFrame;\n        this.endFrame = endFrame || startFrame;\n        this._nextFrame = startFrame;\n    }\n    static createForEncode() {\n        return new ClientMessage();\n    }\n    static createForDecode(startFrame, endFrame) {\n        return new ClientMessage(startFrame, endFrame);\n    }\n    getStartFrame() {\n        return this.startFrame;\n    }\n    nextFrame() {\n        const result = this._nextFrame;\n        if (this._nextFrame != null) {\n            this._nextFrame = this._nextFrame.next;\n        }\n        return result;\n    }\n    hasNextFrame() {\n        return this._nextFrame != null;\n    }\n    peekNextFrame() {\n        return this._nextFrame;\n    }\n    addFrame(frame) {\n        frame.next = null;\n        if (this.startFrame == null) {\n            this.startFrame = frame;\n            this.endFrame = frame;\n            this._nextFrame = frame;\n            return;\n        }\n        this.endFrame.next = frame;\n        this.endFrame = frame;\n    }\n    getMessageType() {\n        return this.startFrame.content.readInt32LE(MESSAGE_TYPE_OFFSET);\n    }\n    setMessageType(messageType) {\n        this.startFrame.content.writeInt32LE(messageType, MESSAGE_TYPE_OFFSET);\n    }\n    getCorrelationId() {\n        return FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(this.startFrame.content, CORRELATION_ID_OFFSET).toNumber();\n    }\n    setCorrelationId(correlationId) {\n        FixSizedTypesCodec_1.FixSizedTypesCodec.encodeLong(this.startFrame.content, CORRELATION_ID_OFFSET, correlationId);\n    }\n    getPartitionId() {\n        return this.startFrame.content.readInt32LE(exports.PARTITION_ID_OFFSET);\n    }\n    setPartitionId(partitionId) {\n        this.startFrame.content.writeInt32LE(partitionId, exports.PARTITION_ID_OFFSET);\n    }\n    getNumberOfBackupAcks() {\n        return this.startFrame.content.readUInt8(exports.RESPONSE_BACKUP_ACKS_OFFSET);\n    }\n    isRetryable() {\n        return this.retryable;\n    }\n    setRetryable(retryable) {\n        this.retryable = retryable;\n    }\n    getConnection() {\n        return this.connection;\n    }\n    setConnection(connection) {\n        this.connection = connection;\n    }\n    getTotalFrameLength() {\n        let frameLength = 0;\n        let currentFrame = this.startFrame;\n        while (currentFrame != null) {\n            frameLength += currentFrame.getLength();\n            currentFrame = currentFrame.next;\n        }\n        return frameLength;\n    }\n    getFragmentationId() {\n        return FixSizedTypesCodec_1.FixSizedTypesCodec.decodeLong(this.startFrame.content, FRAGMENTATION_ID_OFFSET).toNumber();\n    }\n    merge(fragment) {\n        // Should be called after calling dropFragmentationFrame() on the fragment\n        this.endFrame.next = fragment.startFrame;\n        this.endFrame = fragment.endFrame;\n    }\n    dropFragmentationFrame() {\n        this.startFrame = this.startFrame.next;\n        this._nextFrame = this._nextFrame.next;\n    }\n    copyWithNewCorrelationId() {\n        const startFrameCopy = this.startFrame.deepCopy();\n        const newMessage = new ClientMessage(startFrameCopy, this.endFrame);\n        newMessage.setCorrelationId(-1);\n        newMessage.retryable = this.retryable;\n        return newMessage;\n    }\n    toBuffer() {\n        const buffers = [];\n        let totalLength = 0;\n        let currentFrame = this.startFrame;\n        while (currentFrame != null) {\n            const isLastFrame = currentFrame.next == null;\n            const frameLengthAndFlags = Buffer.allocUnsafe(exports.SIZE_OF_FRAME_LENGTH_AND_FLAGS);\n            frameLengthAndFlags.writeInt32LE(currentFrame.content.length + exports.SIZE_OF_FRAME_LENGTH_AND_FLAGS, 0);\n            if (isLastFrame) {\n                frameLengthAndFlags.writeUInt16LE(currentFrame.flags | IS_FINAL_FLAG, BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n            }\n            else {\n                frameLengthAndFlags.writeUInt16LE(currentFrame.flags, BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n            }\n            totalLength += exports.SIZE_OF_FRAME_LENGTH_AND_FLAGS;\n            buffers.push(frameLengthAndFlags);\n            totalLength += currentFrame.content.length;\n            buffers.push(currentFrame.content);\n            currentFrame = currentFrame.next;\n        }\n        return Buffer.concat(buffers, totalLength);\n    }\n}\nexports.ClientMessage = ClientMessage;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/protocol/ClientMessage.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/protocol/ClientProtocolErrorCodes.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/protocol/ClientProtocolErrorCodes.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientProtocolErrorCodes = void 0;\n/** @internal */\nclass ClientProtocolErrorCodes {\n}\nexports.ClientProtocolErrorCodes = ClientProtocolErrorCodes;\nClientProtocolErrorCodes.UNDEFINED = 0;\nClientProtocolErrorCodes.ARRAY_INDEX_OUT_OF_BOUNDS = 1;\nClientProtocolErrorCodes.ARRAY_STORE = 2;\nClientProtocolErrorCodes.AUTHENTICATION = 3;\nClientProtocolErrorCodes.CACHE = 4;\nClientProtocolErrorCodes.CACHE_LOADER = 5;\nClientProtocolErrorCodes.CACHE_NOT_EXISTS = 6;\nClientProtocolErrorCodes.CACHE_WRITER = 7;\nClientProtocolErrorCodes.CALLER_NOT_MEMBER = 8;\nClientProtocolErrorCodes.CANCELLATION = 9;\nClientProtocolErrorCodes.CLASS_CAST = 10;\nClientProtocolErrorCodes.CLASS_NOT_FOUND = 11;\nClientProtocolErrorCodes.CONCURRENT_MODIFICATION = 12;\nClientProtocolErrorCodes.CONFIG_MISMATCH = 13;\nClientProtocolErrorCodes.DISTRIBUTED_OBJECT_DESTROYED = 14;\nClientProtocolErrorCodes.EOF = 15;\nClientProtocolErrorCodes.ENTRY_PROCESSOR = 16;\nClientProtocolErrorCodes.EXECUTION = 17;\nClientProtocolErrorCodes.HAZELCAST = 18;\nClientProtocolErrorCodes.HAZELCAST_INSTANCE_NOT_ACTIVE = 19;\nClientProtocolErrorCodes.HAZELCAST_OVERLOAD = 20;\nClientProtocolErrorCodes.HAZELCAST_SERIALIZATION = 21;\nClientProtocolErrorCodes.IO = 22;\nClientProtocolErrorCodes.ILLEGAL_ARGUMENT = 23;\nClientProtocolErrorCodes.ILLEGAL_ACCESS_EXCEPTION = 24;\nClientProtocolErrorCodes.ILLEGAL_ACCESS_ERROR = 25;\nClientProtocolErrorCodes.ILLEGAL_MONITOR_STATE = 26;\nClientProtocolErrorCodes.ILLEGAL_STATE = 27;\nClientProtocolErrorCodes.ILLEGAL_THREAD_STATE = 28;\nClientProtocolErrorCodes.INDEX_OUT_OF_BOUNDS = 29;\nClientProtocolErrorCodes.INTERRUPTED = 30;\nClientProtocolErrorCodes.INVALID_ADDRESS = 31;\nClientProtocolErrorCodes.INVALID_CONFIGURATION = 32;\nClientProtocolErrorCodes.MEMBER_LEFT = 33;\nClientProtocolErrorCodes.NEGATIVE_ARRAY_SIZE = 34;\nClientProtocolErrorCodes.NO_SUCH_ELEMENT = 35;\nClientProtocolErrorCodes.NOT_SERIALIZABLE = 36;\nClientProtocolErrorCodes.NULL_POINTER = 37;\nClientProtocolErrorCodes.OPERATION_TIMEOUT = 38;\nClientProtocolErrorCodes.PARTITION_MIGRATING = 39;\nClientProtocolErrorCodes.QUERY = 40;\nClientProtocolErrorCodes.QUERY_RESULT_SIZE_EXCEEDED = 41;\nClientProtocolErrorCodes.SPLIT_BRAIN_PROTECTION = 42;\nClientProtocolErrorCodes.REACHED_MAX_SIZE = 43;\nClientProtocolErrorCodes.REJECTED_EXECUTION = 44;\nClientProtocolErrorCodes.RESPONSE_ALREADY_SENT = 45;\nClientProtocolErrorCodes.RETRYABLE_HAZELCAST = 46;\nClientProtocolErrorCodes.RETRYABLE_IO = 47;\nClientProtocolErrorCodes.RUNTIME = 48;\nClientProtocolErrorCodes.SECURITY = 49;\nClientProtocolErrorCodes.SOCKET = 50;\nClientProtocolErrorCodes.STALE_SEQUENCE = 51;\nClientProtocolErrorCodes.TARGET_DISCONNECTED = 52;\nClientProtocolErrorCodes.TARGET_NOT_MEMBER = 53;\nClientProtocolErrorCodes.TIMEOUT = 54;\nClientProtocolErrorCodes.TOPIC_OVERLOAD = 55;\nClientProtocolErrorCodes.TRANSACTION = 56;\nClientProtocolErrorCodes.TRANSACTION_NOT_ACTIVE = 57;\nClientProtocolErrorCodes.TRANSACTION_TIMED_OUT = 58;\nClientProtocolErrorCodes.URI_SYNTAX = 59;\nClientProtocolErrorCodes.UTF_DATA_FORMAT = 60;\nClientProtocolErrorCodes.UNSUPPORTED_OPERATION = 61;\nClientProtocolErrorCodes.WRONG_TARGET = 62;\nClientProtocolErrorCodes.XA = 63;\nClientProtocolErrorCodes.ACCESS_CONTROL = 64;\nClientProtocolErrorCodes.LOGIN = 65;\nClientProtocolErrorCodes.UNSUPPORTED_CALLBACK = 66;\nClientProtocolErrorCodes.NO_DATA_MEMBER = 67;\nClientProtocolErrorCodes.REPLICATED_MAP_CANT_BE_CREATED = 68;\nClientProtocolErrorCodes.MAX_MESSAGE_SIZE_EXCEEDED = 69;\nClientProtocolErrorCodes.WAN_REPLICATION_QUEUE_FULL = 70;\nClientProtocolErrorCodes.ASSERTION_ERROR = 71;\nClientProtocolErrorCodes.OUT_OF_MEMORY_ERROR = 72;\nClientProtocolErrorCodes.STACK_OVERFLOW_ERROR = 73;\nClientProtocolErrorCodes.NATIVE_OUT_OF_MEMORY_ERROR = 74;\nClientProtocolErrorCodes.SERVICE_NOT_FOUND = 75;\nClientProtocolErrorCodes.STALE_TASK_ID = 76;\nClientProtocolErrorCodes.DUPLICATE_TASK = 77;\nClientProtocolErrorCodes.STALE_TASK = 78;\nClientProtocolErrorCodes.LOCAL_MEMBER_RESET = 79;\nClientProtocolErrorCodes.INDETERMINATE_OPERATION_STATE = 80;\nClientProtocolErrorCodes.FLAKE_ID_NODE_ID_OUT_OF_RANGE_EXCEPTION = 81;\nClientProtocolErrorCodes.TARGET_NOT_REPLICA_EXCEPTION = 82;\nClientProtocolErrorCodes.MUTATION_DISALLOWED_EXCEPTION = 83;\nClientProtocolErrorCodes.CONSISTENCY_LOST_EXCEPTION = 84;\nClientProtocolErrorCodes.SESSION_EXPIRED_EXCEPTION = 85;\nClientProtocolErrorCodes.WAIT_KEY_CANCELLED_EXCEPTION = 86;\nClientProtocolErrorCodes.LOCK_ACQUIRE_LIMIT_REACHED_EXCEPTION = 87;\nClientProtocolErrorCodes.LOCK_OWNERSHIP_LOST_EXCEPTION = 88;\nClientProtocolErrorCodes.CP_GROUP_DESTROYED_EXCEPTION = 89;\nClientProtocolErrorCodes.CANNOT_REPLICATE_EXCEPTION = 90;\nClientProtocolErrorCodes.LEADER_DEMOTED_EXCEPTION = 91;\nClientProtocolErrorCodes.STALE_APPEND_REQUEST_EXCEPTION = 92;\nClientProtocolErrorCodes.NOT_LEADER_EXCEPTION = 93;\nClientProtocolErrorCodes.VERSION_MISMATCH_EXCEPTION = 94;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/protocol/ClientProtocolErrorCodes.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/protocol/ErrorFactory.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/protocol/ErrorFactory.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientErrorFactory = void 0;\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst ClientProtocolErrorCodes_1 = __webpack_require__(/*! ./ClientProtocolErrorCodes */ \"../shared/node_modules/hazelcast-client/lib/protocol/ClientProtocolErrorCodes.js\");\nconst ErrorsCodec_1 = __webpack_require__(/*! ../codec/builtin/ErrorsCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/builtin/ErrorsCodec.js\");\n/** @internal */\nclass ClientErrorFactory {\n    constructor() {\n        this.codeToErrorConstructor = new Map();\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.ARRAY_INDEX_OUT_OF_BOUNDS, (m, c, s) => new core_1.ArrayIndexOutOfBoundsError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.ARRAY_STORE, (m, c, s) => new core_1.ArrayStoreError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.AUTHENTICATION, (m, c, s) => new core_1.AuthenticationError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.CALLER_NOT_MEMBER, (m, c, s) => new core_1.CallerNotMemberError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.CANCELLATION, (m, c, s) => new core_1.CancellationError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.CLASS_CAST, (m, c, s) => new core_1.ClassCastError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.CLASS_NOT_FOUND, (m, c, s) => new core_1.ClassNotFoundError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.CONCURRENT_MODIFICATION, (m, c, s) => new core_1.ConcurrentModificationError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.CONFIG_MISMATCH, (m, c, s) => new core_1.ConfigMismatchError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.DISTRIBUTED_OBJECT_DESTROYED, (m, c, s) => new core_1.DistributedObjectDestroyedError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.EOF, (m, c, s) => new core_1.IOError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.HAZELCAST, (m, c, s) => new core_1.HazelcastError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.HAZELCAST_INSTANCE_NOT_ACTIVE, (m, c, s) => new core_1.HazelcastInstanceNotActiveError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.HAZELCAST_OVERLOAD, (m, c, s) => new core_1.HazelcastError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.HAZELCAST_SERIALIZATION, (m, c, s) => new core_1.HazelcastSerializationError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.INDETERMINATE_OPERATION_STATE, (m, c, s) => new core_1.IndeterminateOperationStateError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.IO, (m, c, s) => new core_1.IOError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.ILLEGAL_ARGUMENT, (m, c, s) => new core_1.IllegalArgumentError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.ILLEGAL_STATE, (m, c, s) => new core_1.IllegalStateError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.INDEX_OUT_OF_BOUNDS, (m, c, s) => new core_1.IndexOutOfBoundsError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.INTERRUPTED, (m, c, s) => new core_1.InterruptedError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.INVALID_ADDRESS, (m, c, s) => new core_1.InvalidAddressError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.INVALID_CONFIGURATION, (m, c, s) => new core_1.InvalidConfigurationError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.MEMBER_LEFT, (m, c, s) => new core_1.MemberLeftError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.NEGATIVE_ARRAY_SIZE, (m, c, s) => new core_1.NegativeArraySizeError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.NO_SUCH_ELEMENT, (m, c, s) => new core_1.NoSuchElementError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.NOT_SERIALIZABLE, (m, c, s) => new core_1.IOError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.NULL_POINTER, (m, c, s) => new core_1.NullPointerError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.OPERATION_TIMEOUT, (m, c, s) => new core_1.InvocationTimeoutError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.PARTITION_MIGRATING, (m, c, s) => new core_1.PartitionMigratingError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.QUERY, (m, c, s) => new core_1.QueryError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.QUERY_RESULT_SIZE_EXCEEDED, (m, c, s) => new core_1.QueryError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.SPLIT_BRAIN_PROTECTION, (m, c, s) => new core_1.SplitBrainProtectionError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.REACHED_MAX_SIZE, (m, c, s) => new core_1.ReachedMaxSizeError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.RETRYABLE_HAZELCAST, (m, c, s) => new core_1.RetryableHazelcastError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.RETRYABLE_IO, (m, c, s) => new core_1.RetryableIOError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.SOCKET, (m, c, s) => new core_1.IOError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.STALE_SEQUENCE, (m, c, s) => new core_1.StaleSequenceError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.TARGET_DISCONNECTED, (m, c, s) => new core_1.TargetDisconnectedError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.TARGET_NOT_MEMBER, (m, c, s) => new core_1.TargetNotMemberError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.TOPIC_OVERLOAD, (m, c, s) => new core_1.TopicOverloadError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.TRANSACTION, (m, c, s) => new core_1.TransactionError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.TRANSACTION_NOT_ACTIVE, (m, c, s) => new core_1.TransactionNotActiveError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.TRANSACTION_TIMED_OUT, (m, c, s) => new core_1.TransactionTimedOutError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.UNSUPPORTED_OPERATION, (m, c, s) => new core_1.UnsupportedOperationError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.NO_DATA_MEMBER, (m, c, s) => new core_1.NoDataMemberInClusterError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.STALE_TASK_ID, (m, c, s) => new core_1.StaleTaskIdError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.FLAKE_ID_NODE_ID_OUT_OF_RANGE_EXCEPTION, (m, c, s) => new core_1.NodeIdOutOfRangeError(m, c, s));\n        this.register(ClientProtocolErrorCodes_1.ClientProtocolErrorCodes.CONSISTENCY_LOST_EXCEPTION, (m, c, s) => new core_1.ConsistencyLostError(m, c, s));\n    }\n    createErrorFromClientMessage(clientMessage) {\n        const errorHolders = ErrorsCodec_1.ErrorsCodec.decode(clientMessage);\n        return this.createError(errorHolders, 0);\n    }\n    createError(errorHolders, errorHolderIdx) {\n        if (errorHolderIdx === errorHolders.length) {\n            return null;\n        }\n        const errorHolder = errorHolders[errorHolderIdx];\n        const factoryFn = this.codeToErrorConstructor.get(errorHolder.errorCode);\n        let error;\n        if (factoryFn != null) {\n            error = factoryFn(errorHolder.message, this.createError(errorHolders, errorHolderIdx + 1), errorHolder.stackTraceElements);\n        }\n        else {\n            const msg = 'Class name: ' + errorHolder.className + ', Message: ' + errorHolder.message;\n            error = new core_1.UndefinedErrorCodeError(msg, this.createError(errorHolders, errorHolderIdx + 1), errorHolder.stackTraceElements);\n        }\n        return error;\n    }\n    register(code, errorFactory) {\n        this.codeToErrorConstructor.set(code, errorFactory);\n    }\n}\nexports.ClientErrorFactory = ClientErrorFactory;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/protocol/ErrorFactory.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/protocol/ErrorHolder.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/protocol/ErrorHolder.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ErrorHolder = void 0;\n/** @internal */\nclass ErrorHolder {\n    constructor(errorCode, className, message, stackTraceElements) {\n        this.errorCode = errorCode;\n        this.className = className;\n        this.message = message;\n        this.stackTraceElements = stackTraceElements;\n    }\n}\nexports.ErrorHolder = ErrorHolder;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/protocol/ErrorHolder.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/protocol/PagingPredicateHolder.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/protocol/PagingPredicateHolder.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PagingPredicateHolder = void 0;\nconst AnchorDataListHolder_1 = __webpack_require__(/*! ./AnchorDataListHolder */ \"../shared/node_modules/hazelcast-client/lib/protocol/AnchorDataListHolder.js\");\nconst Predicate_1 = __webpack_require__(/*! ../core/Predicate */ \"../shared/node_modules/hazelcast-client/lib/core/Predicate.js\");\n/** @internal */\nclass PagingPredicateHolder {\n    constructor(anchorDataListHolder, predicateData, comparatorData, pageSize, page, iterationTypeId, partitionKeyData) {\n        this.anchorDataListHolder = anchorDataListHolder;\n        this.predicateData = predicateData;\n        this.comparatorData = comparatorData;\n        this.pageSize = pageSize;\n        this.page = page;\n        this.iterationTypeId = iterationTypeId;\n        this.partitionKeyData = partitionKeyData;\n    }\n    static of(predicate, serializationService) {\n        if (predicate == null) {\n            return null;\n        }\n        return this.buildHolder(serializationService, predicate);\n    }\n    static buildHolder(serializationService, predicate) {\n        const anchorList = predicate.getAnchorList();\n        const anchorDataList = new Array(anchorList.length);\n        const pageList = new Array(anchorList.length);\n        for (let i = 0; i < anchorList.length; i++) {\n            const item = anchorList[i];\n            pageList[i] = item[0];\n            const anchorEntry = item[1];\n            anchorDataList[i] =\n                [serializationService.toData(anchorEntry[0]), serializationService.toData(anchorEntry[1])];\n        }\n        const anchorDataListHolder = new AnchorDataListHolder_1.AnchorDataListHolder(pageList, anchorDataList);\n        const predicateData = serializationService.toData(predicate.getPredicate());\n        const comparatorData = serializationService.toData(predicate.getComparator());\n        const iterationTypeId = Predicate_1.iterationTypeToId(predicate.getIterationType());\n        return new PagingPredicateHolder(anchorDataListHolder, predicateData, comparatorData, predicate.getPageSize(), predicate.getPage(), iterationTypeId, null);\n    }\n}\nexports.PagingPredicateHolder = PagingPredicateHolder;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/protocol/PagingPredicateHolder.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/protocol/StackTraceElement.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/protocol/StackTraceElement.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StackTraceElement = void 0;\n/** @internal */\nclass StackTraceElement {\n    constructor(className, methodName, fileName, lineNumber) {\n        this.className = className;\n        this.methodName = methodName;\n        this.fileName = fileName;\n        this.lineNumber = lineNumber;\n    }\n}\nexports.StackTraceElement = StackTraceElement;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/protocol/StackTraceElement.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/BaseProxy.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/BaseProxy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseProxy = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst BuildInfo_1 = __webpack_require__(/*! ../BuildInfo */ \"../shared/node_modules/hazelcast-client/lib/BuildInfo.js\");\n/**\n * Common super class for any proxy.\n * @internal\n */\nclass BaseProxy {\n    constructor(client, serviceName, name) {\n        this.client = client;\n        this.name = name;\n        this.serviceName = serviceName;\n    }\n    getPartitionKey() {\n        return this.name;\n    }\n    getName() {\n        return this.name;\n    }\n    getServiceName() {\n        return this.serviceName;\n    }\n    destroy() {\n        return this.client.getProxyManager().destroyProxy(this.name, this.serviceName).then(() => {\n            return this.postDestroy();\n        });\n    }\n    destroyLocally() {\n        return this.postDestroy();\n    }\n    postDestroy() {\n        return Promise.resolve();\n    }\n    /**\n     * Encodes a request from a codec and invokes it on owner node of given key.\n     * @param codec\n     * @param partitionKey\n     * @param codecArguments\n     * @returns\n     */\n    encodeInvokeOnKey(codec, partitionKey, ...codecArguments) {\n        const partitionId = this.client.getPartitionService().getPartitionId(partitionKey);\n        return this.encodeInvokeOnPartition(codec, partitionId, ...codecArguments);\n    }\n    /**\n     * Encodes a request from a codec and invokes it on any node.\n     * @param codec\n     * @param codecArguments\n     * @returns\n     */\n    encodeInvokeOnRandomTarget(codec, ...codecArguments) {\n        const clientMessage = codec.encodeRequest(this.name, ...codecArguments);\n        return this.client.getInvocationService().invokeOnRandomTarget(clientMessage);\n    }\n    encodeInvokeOnTarget(codec, target, ...codecArguments) {\n        const clientMessage = codec.encodeRequest(this.name, ...codecArguments);\n        return this.client.getInvocationService().invokeOnTarget(clientMessage, target);\n    }\n    /**\n     * Encodes a request from a codec and invokes it on owner node of given partition.\n     * @param codec\n     * @param partitionId\n     * @param codecArguments\n     * @returns\n     */\n    encodeInvokeOnPartition(codec, partitionId, ...codecArguments) {\n        const clientMessage = codec.encodeRequest(this.name, ...codecArguments);\n        return this.client.getInvocationService().invokeOnPartition(clientMessage, partitionId);\n    }\n    /**\n     * Serializes an object according to serialization settings of the client.\n     * @param object\n     * @returns\n     */\n    toData(object) {\n        return this.client.getSerializationService().toData(object);\n    }\n    /**\n     * De-serializes an object from binary form according to serialization settings of the client.\n     * @param data\n     * @returns {any}\n     */\n    toObject(data) {\n        return this.client.getSerializationService().toObject(data);\n    }\n    getConnectedServerVersion() {\n        const activeConnections = this.client.getConnectionManager().getActiveConnections();\n        for (const address in activeConnections) {\n            return activeConnections[address].getConnectedServerVersion();\n        }\n        return BuildInfo_1.BuildInfo.UNKNOWN_VERSION_ID;\n    }\n}\nexports.BaseProxy = BaseProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/BaseProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/EntryListener.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/EntryListener.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryEvent = void 0;\n/**\n * Map Entry event.\n */\nclass EntryEvent {\n    constructor(name, key, value, oldValue, mergingValue, member) {\n        this.name = name;\n        this.key = key;\n        this.value = value;\n        this.oldValue = oldValue;\n        this.mergingValue = mergingValue;\n        this.member = member;\n    }\n}\nexports.EntryEvent = EntryEvent;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/EntryListener.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/EventType.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/EventType.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventType = void 0;\n/** @internal */\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"ADDED\"] = 1] = \"ADDED\";\n    EventType[EventType[\"REMOVED\"] = 2] = \"REMOVED\";\n    EventType[EventType[\"UPDATED\"] = 4] = \"UPDATED\";\n    EventType[EventType[\"EVICTED\"] = 8] = \"EVICTED\";\n    EventType[EventType[\"EXPIRED\"] = 16] = \"EXPIRED\";\n    EventType[EventType[\"EVICT_ALL\"] = 32] = \"EVICT_ALL\";\n    EventType[EventType[\"CLEAR_ALL\"] = 64] = \"CLEAR_ALL\";\n    EventType[EventType[\"MERGED\"] = 128] = \"MERGED\";\n    EventType[EventType[\"INVALIDATION\"] = 256] = \"INVALIDATION\";\n    EventType[EventType[\"LOADED\"] = 512] = \"LOADED\";\n})(EventType = exports.EventType || (exports.EventType = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/EventType.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/FlakeIdGenerator.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/FlakeIdGenerator.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/FlakeIdGenerator.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/IAtomicLong.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/IAtomicLong.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/IAtomicLong.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/IList.js":
/*!******************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/IList.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/IList.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/IMap.js":
/*!*****************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/IMap.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/IMap.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/IQueue.js":
/*!*******************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/IQueue.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/IQueue.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/ISet.js":
/*!*****************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/ISet.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/ISet.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/ITopic.js":
/*!*******************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/ITopic.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/ITopic.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/ItemListener.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/ItemListener.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ItemEventType = exports.ItemEvent = void 0;\n/**\n * IQueue, ISet, IList item event.\n */\nclass ItemEvent {\n    /** @internal */\n    constructor(name, eventType, item, member) {\n        this.name = name;\n        this.eventType = eventType;\n        this.item = item;\n        this.member = member;\n    }\n}\nexports.ItemEvent = ItemEvent;\n/** @internal */\nvar ItemEventType;\n(function (ItemEventType) {\n    ItemEventType[ItemEventType[\"ADDED\"] = 1] = \"ADDED\";\n    ItemEventType[ItemEventType[\"REMOVED\"] = 2] = \"REMOVED\";\n})(ItemEventType = exports.ItemEventType || (exports.ItemEventType = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/ItemListener.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/ListProxy.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/ListProxy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListProxy = void 0;\nconst ListAddAllCodec_1 = __webpack_require__(/*! ../codec/ListAddAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListAddAllCodec.js\");\nconst ListAddAllWithIndexCodec_1 = __webpack_require__(/*! ../codec/ListAddAllWithIndexCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListAddAllWithIndexCodec.js\");\nconst ListAddCodec_1 = __webpack_require__(/*! ../codec/ListAddCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListAddCodec.js\");\nconst ListAddListenerCodec_1 = __webpack_require__(/*! ../codec/ListAddListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListAddListenerCodec.js\");\nconst ListAddWithIndexCodec_1 = __webpack_require__(/*! ../codec/ListAddWithIndexCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListAddWithIndexCodec.js\");\nconst ListClearCodec_1 = __webpack_require__(/*! ../codec/ListClearCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListClearCodec.js\");\nconst ListCompareAndRemoveAllCodec_1 = __webpack_require__(/*! ../codec/ListCompareAndRemoveAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListCompareAndRemoveAllCodec.js\");\nconst ListCompareAndRetainAllCodec_1 = __webpack_require__(/*! ../codec/ListCompareAndRetainAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListCompareAndRetainAllCodec.js\");\nconst ListContainsAllCodec_1 = __webpack_require__(/*! ../codec/ListContainsAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListContainsAllCodec.js\");\nconst ListContainsCodec_1 = __webpack_require__(/*! ../codec/ListContainsCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListContainsCodec.js\");\nconst ListGetAllCodec_1 = __webpack_require__(/*! ../codec/ListGetAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListGetAllCodec.js\");\nconst ListGetCodec_1 = __webpack_require__(/*! ../codec/ListGetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListGetCodec.js\");\nconst ListIndexOfCodec_1 = __webpack_require__(/*! ../codec/ListIndexOfCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListIndexOfCodec.js\");\nconst ListIsEmptyCodec_1 = __webpack_require__(/*! ../codec/ListIsEmptyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListIsEmptyCodec.js\");\nconst ListLastIndexOfCodec_1 = __webpack_require__(/*! ../codec/ListLastIndexOfCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListLastIndexOfCodec.js\");\nconst ListRemoveCodec_1 = __webpack_require__(/*! ../codec/ListRemoveCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListRemoveCodec.js\");\nconst ListRemoveListenerCodec_1 = __webpack_require__(/*! ../codec/ListRemoveListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListRemoveListenerCodec.js\");\nconst ListRemoveWithIndexCodec_1 = __webpack_require__(/*! ../codec/ListRemoveWithIndexCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListRemoveWithIndexCodec.js\");\nconst ListSetCodec_1 = __webpack_require__(/*! ../codec/ListSetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListSetCodec.js\");\nconst ListSizeCodec_1 = __webpack_require__(/*! ../codec/ListSizeCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListSizeCodec.js\");\nconst ListSubCodec_1 = __webpack_require__(/*! ../codec/ListSubCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ListSubCodec.js\");\nconst ItemListener_1 = __webpack_require__(/*! ./ItemListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/ItemListener.js\");\nconst PartitionSpecificProxy_1 = __webpack_require__(/*! ./PartitionSpecificProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/PartitionSpecificProxy.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\n/** @internal */\nclass ListProxy extends PartitionSpecificProxy_1.PartitionSpecificProxy {\n    add(element) {\n        return this.encodeInvoke(ListAddCodec_1.ListAddCodec, this.toData(element))\n            .then((clientMessage) => {\n            const response = ListAddAllCodec_1.ListAddAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    addAll(elements) {\n        return this.encodeInvoke(ListAddAllCodec_1.ListAddAllCodec, this.serializeList(elements))\n            .then((clientMessage) => {\n            const response = ListAddAllCodec_1.ListAddAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    addAllAt(index, elements) {\n        return this.encodeInvoke(ListAddAllWithIndexCodec_1.ListAddAllWithIndexCodec, index, this.serializeList(elements))\n            .then((clientMessage) => {\n            const response = ListAddAllWithIndexCodec_1.ListAddAllWithIndexCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    addAt(index, element) {\n        return this.encodeInvoke(ListAddWithIndexCodec_1.ListAddWithIndexCodec, index, this.toData(element)).then();\n    }\n    clear() {\n        return this.encodeInvoke(ListClearCodec_1.ListClearCodec).then();\n    }\n    contains(entry) {\n        return this.encodeInvoke(ListContainsCodec_1.ListContainsCodec, this.toData(entry))\n            .then((clientMessage) => {\n            const response = ListContainsCodec_1.ListContainsCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    containsAll(elements) {\n        return this.encodeInvoke(ListContainsAllCodec_1.ListContainsAllCodec, this.serializeList(elements))\n            .then((clientMessage) => {\n            const response = ListContainsAllCodec_1.ListContainsAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    isEmpty() {\n        return this.encodeInvoke(ListIsEmptyCodec_1.ListIsEmptyCodec)\n            .then((clientMessage) => {\n            const response = ListIsEmptyCodec_1.ListIsEmptyCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    remove(entry) {\n        return this.encodeInvoke(ListRemoveCodec_1.ListRemoveCodec, this.toData(entry))\n            .then((clientMessage) => {\n            const response = ListRemoveCodec_1.ListRemoveCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    removeAll(elements) {\n        return this.encodeInvoke(ListCompareAndRemoveAllCodec_1.ListCompareAndRemoveAllCodec, this.serializeList(elements))\n            .then((clientMessage) => {\n            const response = ListCompareAndRemoveAllCodec_1.ListCompareAndRemoveAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    retainAll(elements) {\n        return this.encodeInvoke(ListCompareAndRetainAllCodec_1.ListCompareAndRetainAllCodec, this.serializeList(elements))\n            .then((clientMessage) => {\n            const response = ListCompareAndRetainAllCodec_1.ListCompareAndRetainAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    removeAt(index) {\n        return this.encodeInvoke(ListRemoveWithIndexCodec_1.ListRemoveWithIndexCodec, index)\n            .then((clientMessage) => {\n            const response = ListRemoveWithIndexCodec_1.ListRemoveWithIndexCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    get(index) {\n        return this.encodeInvoke(ListGetCodec_1.ListGetCodec, index)\n            .then((clientMessage) => {\n            const response = ListGetCodec_1.ListGetCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    set(index, element) {\n        return this.encodeInvoke(ListSetCodec_1.ListSetCodec, index, this.toData(element))\n            .then((clientMessage) => {\n            const response = ListSetCodec_1.ListSetCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    indexOf(element) {\n        return this.encodeInvoke(ListIndexOfCodec_1.ListIndexOfCodec, this.toData(element))\n            .then((clientMessage) => {\n            const response = ListIndexOfCodec_1.ListIndexOfCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    lastIndexOf(element) {\n        return this.encodeInvoke(ListLastIndexOfCodec_1.ListLastIndexOfCodec, this.toData(element))\n            .then((clientMessage) => {\n            const response = ListLastIndexOfCodec_1.ListLastIndexOfCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    size() {\n        return this.encodeInvoke(ListSizeCodec_1.ListSizeCodec)\n            .then((clientMessage) => {\n            const response = ListSizeCodec_1.ListSizeCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    subList(start, end) {\n        return this.encodeInvoke(ListSubCodec_1.ListSubCodec, start, end)\n            .then((clientMessage) => {\n            const response = ListSubCodec_1.ListSubCodec.decodeResponse(clientMessage);\n            return new core_1.ReadOnlyLazyList(response.response, this.client.getSerializationService());\n        });\n    }\n    toArray() {\n        return this.encodeInvoke(ListGetAllCodec_1.ListGetAllCodec)\n            .then((clientMessage) => {\n            const response = ListGetAllCodec_1.ListGetAllCodec.decodeResponse(clientMessage);\n            return response.response.map(this.toObject.bind(this));\n        });\n    }\n    addItemListener(listener, includeValue) {\n        const listenerHandler = (message) => {\n            ListAddListenerCodec_1.ListAddListenerCodec.handle(message, (element, uuid, eventType) => {\n                const responseObject = element ? this.toObject(element) : null;\n                const member = this.client.getClusterService().getMember(uuid);\n                const name = this.name;\n                const itemEvent = new ItemListener_1.ItemEvent(name, eventType, responseObject, member);\n                if (eventType === ItemListener_1.ItemEventType.ADDED && listener.itemAdded) {\n                    listener.itemAdded.apply(null, [itemEvent]);\n                }\n                else if (eventType === ItemListener_1.ItemEventType.REMOVED && listener.itemRemoved) {\n                    listener.itemRemoved.apply(null, [itemEvent]);\n                }\n            });\n        };\n        const codec = this.createItemListener(this.name, includeValue);\n        return this.client.getListenerService().registerListener(codec, listenerHandler);\n    }\n    removeItemListener(registrationId) {\n        return this.client.getListenerService().deregisterListener(registrationId);\n    }\n    serializeList(input) {\n        return input.map((each) => {\n            return this.toData(each);\n        });\n    }\n    createItemListener(name, includeValue) {\n        return {\n            encodeAddRequest(localOnly) {\n                return ListAddListenerCodec_1.ListAddListenerCodec.encodeRequest(name, includeValue, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return ListAddListenerCodec_1.ListAddListenerCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return ListRemoveListenerCodec_1.ListRemoveListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n}\nexports.ListProxy = ListProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/ListProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/LockReferenceIdGenerator.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/LockReferenceIdGenerator.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LockReferenceIdGenerator = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\n/** @internal */\nclass LockReferenceIdGenerator {\n    constructor() {\n        this.counter = Long.fromNumber(0);\n    }\n    getNextReferenceId() {\n        this.counter = this.counter.add(1);\n        return this.counter;\n    }\n}\nexports.LockReferenceIdGenerator = LockReferenceIdGenerator;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/LockReferenceIdGenerator.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/MapListener.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/MapListener.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapEvent = void 0;\n/**\n * Used for map-wide events.\n */\nclass MapEvent {\n    constructor(name, numberOfAffectedEntries, member) {\n        this.name = name;\n        this.numberOfAffectedEntries = numberOfAffectedEntries;\n        this.member = member;\n    }\n}\nexports.MapEvent = MapEvent;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/MapListener.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/MapProxy.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/MapProxy.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapProxy = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst MapAddEntryListenerCodec_1 = __webpack_require__(/*! ../codec/MapAddEntryListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerCodec.js\");\nconst MapAddEntryListenerToKeyCodec_1 = __webpack_require__(/*! ../codec/MapAddEntryListenerToKeyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerToKeyCodec.js\");\nconst MapAddEntryListenerToKeyWithPredicateCodec_1 = __webpack_require__(/*! ../codec/MapAddEntryListenerToKeyWithPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerToKeyWithPredicateCodec.js\");\nconst MapAddEntryListenerWithPredicateCodec_1 = __webpack_require__(/*! ../codec/MapAddEntryListenerWithPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapAddEntryListenerWithPredicateCodec.js\");\nconst MapAddIndexCodec_1 = __webpack_require__(/*! ../codec/MapAddIndexCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapAddIndexCodec.js\");\nconst MapAggregateCodec_1 = __webpack_require__(/*! ../codec/MapAggregateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapAggregateCodec.js\");\nconst MapAggregateWithPredicateCodec_1 = __webpack_require__(/*! ../codec/MapAggregateWithPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapAggregateWithPredicateCodec.js\");\nconst MapClearCodec_1 = __webpack_require__(/*! ../codec/MapClearCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapClearCodec.js\");\nconst MapContainsKeyCodec_1 = __webpack_require__(/*! ../codec/MapContainsKeyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapContainsKeyCodec.js\");\nconst MapContainsValueCodec_1 = __webpack_require__(/*! ../codec/MapContainsValueCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapContainsValueCodec.js\");\nconst MapDeleteCodec_1 = __webpack_require__(/*! ../codec/MapDeleteCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapDeleteCodec.js\");\nconst MapEntriesWithPredicateCodec_1 = __webpack_require__(/*! ../codec/MapEntriesWithPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapEntriesWithPredicateCodec.js\");\nconst MapEntrySetCodec_1 = __webpack_require__(/*! ../codec/MapEntrySetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapEntrySetCodec.js\");\nconst MapEvictAllCodec_1 = __webpack_require__(/*! ../codec/MapEvictAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapEvictAllCodec.js\");\nconst MapEvictCodec_1 = __webpack_require__(/*! ../codec/MapEvictCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapEvictCodec.js\");\nconst MapExecuteOnAllKeysCodec_1 = __webpack_require__(/*! ../codec/MapExecuteOnAllKeysCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnAllKeysCodec.js\");\nconst MapExecuteOnKeyCodec_1 = __webpack_require__(/*! ../codec/MapExecuteOnKeyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnKeyCodec.js\");\nconst MapExecuteOnKeysCodec_1 = __webpack_require__(/*! ../codec/MapExecuteOnKeysCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapExecuteOnKeysCodec.js\");\nconst MapExecuteWithPredicateCodec_1 = __webpack_require__(/*! ../codec/MapExecuteWithPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapExecuteWithPredicateCodec.js\");\nconst MapFlushCodec_1 = __webpack_require__(/*! ../codec/MapFlushCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapFlushCodec.js\");\nconst MapForceUnlockCodec_1 = __webpack_require__(/*! ../codec/MapForceUnlockCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapForceUnlockCodec.js\");\nconst MapGetAllCodec_1 = __webpack_require__(/*! ../codec/MapGetAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapGetAllCodec.js\");\nconst MapGetCodec_1 = __webpack_require__(/*! ../codec/MapGetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapGetCodec.js\");\nconst MapGetEntryViewCodec_1 = __webpack_require__(/*! ../codec/MapGetEntryViewCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapGetEntryViewCodec.js\");\nconst MapIsEmptyCodec_1 = __webpack_require__(/*! ../codec/MapIsEmptyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapIsEmptyCodec.js\");\nconst MapIsLockedCodec_1 = __webpack_require__(/*! ../codec/MapIsLockedCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapIsLockedCodec.js\");\nconst MapKeySetCodec_1 = __webpack_require__(/*! ../codec/MapKeySetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapKeySetCodec.js\");\nconst MapKeySetWithPagingPredicateCodec_1 = __webpack_require__(/*! ../codec/MapKeySetWithPagingPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapKeySetWithPagingPredicateCodec.js\");\nconst MapKeySetWithPredicateCodec_1 = __webpack_require__(/*! ../codec/MapKeySetWithPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapKeySetWithPredicateCodec.js\");\nconst MapLoadAllCodec_1 = __webpack_require__(/*! ../codec/MapLoadAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapLoadAllCodec.js\");\nconst MapLoadGivenKeysCodec_1 = __webpack_require__(/*! ../codec/MapLoadGivenKeysCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapLoadGivenKeysCodec.js\");\nconst MapLockCodec_1 = __webpack_require__(/*! ../codec/MapLockCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapLockCodec.js\");\nconst MapPutAllCodec_1 = __webpack_require__(/*! ../codec/MapPutAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapPutAllCodec.js\");\nconst MapPutCodec_1 = __webpack_require__(/*! ../codec/MapPutCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapPutCodec.js\");\nconst MapPutIfAbsentCodec_1 = __webpack_require__(/*! ../codec/MapPutIfAbsentCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapPutIfAbsentCodec.js\");\nconst MapPutTransientCodec_1 = __webpack_require__(/*! ../codec/MapPutTransientCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapPutTransientCodec.js\");\nconst MapRemoveCodec_1 = __webpack_require__(/*! ../codec/MapRemoveCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapRemoveCodec.js\");\nconst MapRemoveEntryListenerCodec_1 = __webpack_require__(/*! ../codec/MapRemoveEntryListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapRemoveEntryListenerCodec.js\");\nconst MapRemoveIfSameCodec_1 = __webpack_require__(/*! ../codec/MapRemoveIfSameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapRemoveIfSameCodec.js\");\nconst MapReplaceCodec_1 = __webpack_require__(/*! ../codec/MapReplaceCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapReplaceCodec.js\");\nconst MapReplaceIfSameCodec_1 = __webpack_require__(/*! ../codec/MapReplaceIfSameCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapReplaceIfSameCodec.js\");\nconst MapSetCodec_1 = __webpack_require__(/*! ../codec/MapSetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapSetCodec.js\");\nconst MapSizeCodec_1 = __webpack_require__(/*! ../codec/MapSizeCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapSizeCodec.js\");\nconst MapTryLockCodec_1 = __webpack_require__(/*! ../codec/MapTryLockCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapTryLockCodec.js\");\nconst MapTryPutCodec_1 = __webpack_require__(/*! ../codec/MapTryPutCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapTryPutCodec.js\");\nconst MapTryRemoveCodec_1 = __webpack_require__(/*! ../codec/MapTryRemoveCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapTryRemoveCodec.js\");\nconst MapUnlockCodec_1 = __webpack_require__(/*! ../codec/MapUnlockCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapUnlockCodec.js\");\nconst MapValuesCodec_1 = __webpack_require__(/*! ../codec/MapValuesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapValuesCodec.js\");\nconst MapValuesWithPagingPredicateCodec_1 = __webpack_require__(/*! ../codec/MapValuesWithPagingPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapValuesWithPagingPredicateCodec.js\");\nconst MapValuesWithPredicateCodec_1 = __webpack_require__(/*! ../codec/MapValuesWithPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapValuesWithPredicateCodec.js\");\nconst EventType_1 = __webpack_require__(/*! ./EventType */ \"../shared/node_modules/hazelcast-client/lib/proxy/EventType.js\");\nconst SimpleEntryView_1 = __webpack_require__(/*! ../core/SimpleEntryView */ \"../shared/node_modules/hazelcast-client/lib/core/SimpleEntryView.js\");\nconst MapListener_1 = __webpack_require__(/*! ./MapListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/MapListener.js\");\nconst Predicate_1 = __webpack_require__(/*! ../core/Predicate */ \"../shared/node_modules/hazelcast-client/lib/core/Predicate.js\");\nconst ReadOnlyLazyList_1 = __webpack_require__(/*! ../core/ReadOnlyLazyList */ \"../shared/node_modules/hazelcast-client/lib/core/ReadOnlyLazyList.js\");\nconst DefaultPredicates_1 = __webpack_require__(/*! ../serialization/DefaultPredicates */ \"../shared/node_modules/hazelcast-client/lib/serialization/DefaultPredicates.js\");\nconst SerializationUtil = __webpack_require__(/*! ../serialization/SerializationUtil */ \"../shared/node_modules/hazelcast-client/lib/serialization/SerializationUtil.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst BaseProxy_1 = __webpack_require__(/*! ./BaseProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/BaseProxy.js\");\nconst EntryListener_1 = __webpack_require__(/*! ./EntryListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/EntryListener.js\");\nconst IndexUtil_1 = __webpack_require__(/*! ../util/IndexUtil */ \"../shared/node_modules/hazelcast-client/lib/util/IndexUtil.js\");\nconst PagingPredicateHolder_1 = __webpack_require__(/*! ../protocol/PagingPredicateHolder */ \"../shared/node_modules/hazelcast-client/lib/protocol/PagingPredicateHolder.js\");\nconst MapEntriesWithPagingPredicateCodec_1 = __webpack_require__(/*! ../codec/MapEntriesWithPagingPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapEntriesWithPagingPredicateCodec.js\");\n/** @internal */\nclass MapProxy extends BaseProxy_1.BaseProxy {\n    aggregate(aggregator) {\n        Util_1.assertNotNull(aggregator);\n        const aggregatorData = this.toData(aggregator);\n        return this.encodeInvokeOnRandomTarget(MapAggregateCodec_1.MapAggregateCodec, aggregatorData)\n            .then((clientMessage) => {\n            const response = MapAggregateCodec_1.MapAggregateCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    aggregateWithPredicate(aggregator, predicate) {\n        Util_1.assertNotNull(aggregator);\n        Util_1.assertNotNull(predicate);\n        this.checkNotPagingPredicate(predicate);\n        const aggregatorData = this.toData(aggregator);\n        const predicateData = this.toData(predicate);\n        return this.encodeInvokeOnRandomTarget(MapAggregateWithPredicateCodec_1.MapAggregateWithPredicateCodec, aggregatorData, predicateData)\n            .then((clientMessage) => {\n            const response = MapAggregateWithPredicateCodec_1.MapAggregateWithPredicateCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    executeOnKeys(keys, entryProcessor) {\n        Util_1.assertNotNull(keys);\n        Util_1.assertArray(keys);\n        if (keys.length === 0) {\n            return Promise.resolve([]);\n        }\n        else {\n            const toObject = this.toObject.bind(this);\n            const keysData = SerializationUtil.serializeList(this.toData.bind(this), keys);\n            const proData = this.toData(entryProcessor);\n            return this.encodeInvokeOnRandomTarget(MapExecuteOnKeysCodec_1.MapExecuteOnKeysCodec, proData, keysData)\n                .then((clientMessage) => {\n                const response = MapExecuteOnKeysCodec_1.MapExecuteOnKeysCodec.decodeResponse(clientMessage);\n                return SerializationUtil.deserializeEntryList(toObject, response.response);\n            });\n        }\n    }\n    executeOnKey(key, entryProcessor) {\n        Util_1.assertNotNull(key);\n        Util_1.assertNotNull(entryProcessor);\n        const keyData = this.toData(key);\n        const proData = this.toData(entryProcessor);\n        return this.executeOnKeyInternal(keyData, proData);\n    }\n    executeOnEntries(entryProcessor, predicate = null) {\n        Util_1.assertNotNull(entryProcessor);\n        const proData = this.toData(entryProcessor);\n        const toObject = this.toObject.bind(this);\n        if (predicate == null) {\n            return this.encodeInvokeOnRandomTarget(MapExecuteOnAllKeysCodec_1.MapExecuteOnAllKeysCodec, proData)\n                .then((clientMessage) => {\n                const response = MapExecuteOnAllKeysCodec_1.MapExecuteOnAllKeysCodec.decodeResponse(clientMessage);\n                return SerializationUtil.deserializeEntryList(toObject, response.response);\n            });\n        }\n        else {\n            const predData = this.toData(predicate);\n            return this.encodeInvokeOnRandomTarget(MapExecuteWithPredicateCodec_1.MapExecuteWithPredicateCodec, proData, predData)\n                .then((clientMessage) => {\n                const response = MapExecuteWithPredicateCodec_1.MapExecuteWithPredicateCodec.decodeResponse(clientMessage);\n                return SerializationUtil.deserializeEntryList(toObject, response.response);\n            });\n        }\n    }\n    entrySetWithPredicate(predicate) {\n        Util_1.assertNotNull(predicate);\n        const toObject = this.toObject.bind(this);\n        if (predicate instanceof DefaultPredicates_1.PagingPredicateImpl) {\n            predicate.setIterationType(Predicate_1.IterationType.ENTRY);\n            const serializationService = this.client.getSerializationService();\n            const pagingPredicateHolder = PagingPredicateHolder_1.PagingPredicateHolder.of(predicate, serializationService);\n            return this.encodeInvokeOnRandomTarget(MapEntriesWithPagingPredicateCodec_1.MapEntriesWithPagingPredicateCodec, pagingPredicateHolder)\n                .then((clientMessage) => {\n                const response = MapEntriesWithPagingPredicateCodec_1.MapEntriesWithPagingPredicateCodec.decodeResponse(clientMessage);\n                predicate.setAnchorList(response.anchorDataList.asAnchorList(serializationService));\n                return SerializationUtil.deserializeEntryList(toObject, response.response);\n            });\n        }\n        else {\n            const pData = this.toData(predicate);\n            return this.encodeInvokeOnRandomTarget(MapEntriesWithPredicateCodec_1.MapEntriesWithPredicateCodec, pData)\n                .then((clientMessage) => {\n                const response = MapEntriesWithPredicateCodec_1.MapEntriesWithPredicateCodec.decodeResponse(clientMessage);\n                return SerializationUtil.deserializeEntryList(toObject, response.response);\n            });\n        }\n    }\n    keySetWithPredicate(predicate) {\n        Util_1.assertNotNull(predicate);\n        const toObject = this.toObject.bind(this);\n        if (predicate instanceof DefaultPredicates_1.PagingPredicateImpl) {\n            predicate.setIterationType(Predicate_1.IterationType.KEY);\n            const serializationService = this.client.getSerializationService();\n            const pagingPredicateHolder = PagingPredicateHolder_1.PagingPredicateHolder.of(predicate, serializationService);\n            return this.encodeInvokeOnRandomTarget(MapKeySetWithPagingPredicateCodec_1.MapKeySetWithPagingPredicateCodec, pagingPredicateHolder)\n                .then((clientMessage) => {\n                const response = MapKeySetWithPagingPredicateCodec_1.MapKeySetWithPagingPredicateCodec.decodeResponse(clientMessage);\n                predicate.setAnchorList(response.anchorDataList.asAnchorList(serializationService));\n                return response.response.map(toObject);\n            });\n        }\n        else {\n            const predicateData = this.toData(predicate);\n            return this.encodeInvokeOnRandomTarget(MapKeySetWithPredicateCodec_1.MapKeySetWithPredicateCodec, predicateData)\n                .then((clientMessage) => {\n                const response = MapKeySetWithPredicateCodec_1.MapKeySetWithPredicateCodec.decodeResponse(clientMessage);\n                return response.response.map(toObject);\n            });\n        }\n    }\n    valuesWithPredicate(predicate) {\n        Util_1.assertNotNull(predicate);\n        if (predicate instanceof DefaultPredicates_1.PagingPredicateImpl) {\n            predicate.setIterationType(Predicate_1.IterationType.VALUE);\n            const serializationService = this.client.getSerializationService();\n            const pagingPredicateHolder = PagingPredicateHolder_1.PagingPredicateHolder.of(predicate, serializationService);\n            return this.encodeInvokeOnRandomTarget(MapValuesWithPagingPredicateCodec_1.MapValuesWithPagingPredicateCodec, pagingPredicateHolder)\n                .then((clientMessage) => {\n                const response = MapValuesWithPagingPredicateCodec_1.MapValuesWithPagingPredicateCodec.decodeResponse(clientMessage);\n                predicate.setAnchorList(response.anchorDataList.asAnchorList(serializationService));\n                return new ReadOnlyLazyList_1.ReadOnlyLazyList(response.response, serializationService);\n            });\n        }\n        else {\n            const predicateData = this.toData(predicate);\n            return this.encodeInvokeOnRandomTarget(MapValuesWithPredicateCodec_1.MapValuesWithPredicateCodec, predicateData)\n                .then((clientMessage) => {\n                const response = MapValuesWithPredicateCodec_1.MapValuesWithPredicateCodec.decodeResponse(clientMessage);\n                return new ReadOnlyLazyList_1.ReadOnlyLazyList(response.response, this.client.getSerializationService());\n            });\n        }\n    }\n    addEntryListenerWithPredicate(listener, predicate, key, includeValue) {\n        return this.addEntryListenerInternal(listener, predicate, key, includeValue);\n    }\n    containsKey(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.containsKeyInternal(keyData);\n    }\n    containsValue(value) {\n        Util_1.assertNotNull(value);\n        const valueData = this.toData(value);\n        return this.encodeInvokeOnRandomTarget(MapContainsValueCodec_1.MapContainsValueCodec, valueData)\n            .then((clientMessage) => {\n            const response = MapContainsValueCodec_1.MapContainsValueCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    put(key, value, ttl = -1) {\n        Util_1.assertNotNull(key);\n        Util_1.assertNotNull(value);\n        const keyData = this.toData(key);\n        const valueData = this.toData(value);\n        return this.putInternal(keyData, valueData, ttl);\n    }\n    putAll(pairs) {\n        return this.putAllInternal(pairs, true);\n    }\n    setAll(pairs) {\n        return this.putAllInternal(pairs, false);\n    }\n    get(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.getInternal(keyData);\n    }\n    remove(key, value = null) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.removeInternal(keyData, value);\n    }\n    size() {\n        return this.encodeInvokeOnRandomTarget(MapSizeCodec_1.MapSizeCodec)\n            .then((clientMessage) => {\n            const response = MapSizeCodec_1.MapSizeCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    clear() {\n        return this.encodeInvokeOnRandomTarget(MapClearCodec_1.MapClearCodec).then();\n    }\n    isEmpty() {\n        return this.encodeInvokeOnRandomTarget(MapIsEmptyCodec_1.MapIsEmptyCodec)\n            .then((clientMessage) => {\n            const response = MapIsEmptyCodec_1.MapIsEmptyCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    getAll(keys) {\n        Util_1.assertNotNull(keys);\n        Util_1.assertArray(keys);\n        const partitionService = this.client.getPartitionService();\n        const partitionsToKeys = {};\n        let key;\n        for (const i in keys) {\n            key = keys[i];\n            const keyData = this.toData(key);\n            const pId = partitionService.getPartitionId(keyData);\n            if (!partitionsToKeys[pId]) {\n                partitionsToKeys[pId] = [];\n            }\n            partitionsToKeys[pId].push(keyData);\n        }\n        const result = [];\n        return this.getAllInternal(partitionsToKeys, result).then(function () {\n            return result;\n        });\n    }\n    delete(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.deleteInternal(keyData);\n    }\n    entrySet() {\n        return this.encodeInvokeOnRandomTarget(MapEntrySetCodec_1.MapEntrySetCodec)\n            .then((clientMessage) => {\n            const response = MapEntrySetCodec_1.MapEntrySetCodec.decodeResponse(clientMessage);\n            return SerializationUtil.deserializeEntryList(this.toObject.bind(this), response.response);\n        });\n    }\n    evict(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.evictInternal(keyData);\n    }\n    evictAll() {\n        return this.encodeInvokeOnRandomTarget(MapEvictAllCodec_1.MapEvictAllCodec).then();\n    }\n    flush() {\n        return this.encodeInvokeOnRandomTarget(MapFlushCodec_1.MapFlushCodec).then();\n    }\n    lock(key, ttl = -1) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MapLockCodec_1.MapLockCodec, keyData, keyData, 0, ttl, 0).then();\n    }\n    isLocked(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MapIsLockedCodec_1.MapIsLockedCodec, keyData, keyData)\n            .then((clientMessage) => {\n            const response = MapIsLockedCodec_1.MapIsLockedCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    unlock(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MapUnlockCodec_1.MapUnlockCodec, keyData, keyData, 0, 0).then();\n    }\n    forceUnlock(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MapForceUnlockCodec_1.MapForceUnlockCodec, keyData, keyData, 0).then();\n    }\n    keySet() {\n        return this.encodeInvokeOnRandomTarget(MapKeySetCodec_1.MapKeySetCodec)\n            .then((clientMessage) => {\n            const response = MapKeySetCodec_1.MapKeySetCodec.decodeResponse(clientMessage);\n            return response.response.map(this.toObject.bind(this));\n        });\n    }\n    loadAll(keys = null, replaceExistingValues = true) {\n        if (keys == null) {\n            return this.encodeInvokeOnRandomTarget(MapLoadAllCodec_1.MapLoadAllCodec, replaceExistingValues).then();\n        }\n        else {\n            const toData = this.toData.bind(this);\n            const keysData = keys.map(toData);\n            return this.encodeInvokeOnRandomTarget(MapLoadGivenKeysCodec_1.MapLoadGivenKeysCodec, keysData, replaceExistingValues).then();\n        }\n    }\n    putIfAbsent(key, value, ttl = -1) {\n        Util_1.assertNotNull(key);\n        Util_1.assertNotNull(value);\n        const keyData = this.toData(key);\n        const valueData = this.toData(value);\n        return this.putIfAbsentInternal(keyData, valueData, ttl);\n    }\n    putTransient(key, value, ttl = -1) {\n        Util_1.assertNotNull(key);\n        Util_1.assertNotNull(value);\n        const keyData = this.toData(key);\n        const valueData = this.toData(value);\n        return this.putTransientInternal(keyData, valueData, ttl);\n    }\n    replace(key, newValue) {\n        Util_1.assertNotNull(key);\n        Util_1.assertNotNull(newValue);\n        const keyData = this.toData(key);\n        const newValueData = this.toData(newValue);\n        return this.replaceInternal(keyData, newValueData);\n    }\n    replaceIfSame(key, oldValue, newValue) {\n        Util_1.assertNotNull(key);\n        Util_1.assertNotNull(oldValue);\n        Util_1.assertNotNull(newValue);\n        const keyData = this.toData(key);\n        const newValueData = this.toData(newValue);\n        const oldValueData = this.toData(oldValue);\n        return this.replaceIfSameInternal(keyData, oldValueData, newValueData);\n    }\n    set(key, value, ttl = -1) {\n        Util_1.assertNotNull(key);\n        Util_1.assertNotNull(value);\n        const keyData = this.toData(key);\n        const valueData = this.toData(value);\n        return this.setInternal(keyData, valueData, ttl);\n    }\n    values() {\n        return this.encodeInvokeOnRandomTarget(MapValuesCodec_1.MapValuesCodec)\n            .then((clientMessage) => {\n            const response = MapValuesCodec_1.MapValuesCodec.decodeResponse(clientMessage);\n            return new ReadOnlyLazyList_1.ReadOnlyLazyList(response.response, this.client.getSerializationService());\n        });\n    }\n    getEntryView(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MapGetEntryViewCodec_1.MapGetEntryViewCodec, keyData, keyData, 0)\n            .then((clientMessage) => {\n            const response = MapGetEntryViewCodec_1.MapGetEntryViewCodec.decodeResponse(clientMessage);\n            const dataEntryView = response.response;\n            if (dataEntryView == null) {\n                return null;\n            }\n            return new SimpleEntryView_1.SimpleEntryView(this.toObject(dataEntryView.key), this.toObject(dataEntryView.value), dataEntryView.cost, dataEntryView.creationTime, dataEntryView.expirationTime, dataEntryView.hits, dataEntryView.lastAccessTime, dataEntryView.lastStoredTime, dataEntryView.lastUpdateTime, dataEntryView.version, dataEntryView.ttl, response.maxIdle);\n        });\n    }\n    addIndex(indexConfig) {\n        Util_1.assertNotNull(indexConfig);\n        const normalizedConfig = IndexUtil_1.IndexUtil.validateAndNormalize(this.name, indexConfig);\n        return this.encodeInvokeOnRandomTarget(MapAddIndexCodec_1.MapAddIndexCodec, normalizedConfig).then();\n    }\n    tryLock(key, timeout = 0, lease = -1) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MapTryLockCodec_1.MapTryLockCodec, keyData, keyData, 0, lease, timeout, 0)\n            .then((clientMessage) => {\n            const response = MapTryLockCodec_1.MapTryLockCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    tryPut(key, value, timeout) {\n        Util_1.assertNotNull(key);\n        Util_1.assertNotNull(value);\n        const keyData = this.toData(key);\n        const valueData = this.toData(value);\n        return this.tryPutInternal(keyData, valueData, timeout);\n    }\n    tryRemove(key, timeout) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.tryRemoveInternal(keyData, timeout);\n    }\n    addEntryListener(listener, key, includeValue = false) {\n        return this.addEntryListenerInternal(listener, undefined, key, includeValue);\n    }\n    removeEntryListener(listenerId) {\n        return this.client.getListenerService().deregisterListener(listenerId);\n    }\n    executeOnKeyInternal(keyData, proData) {\n        return this.encodeInvokeOnKey(MapExecuteOnKeyCodec_1.MapExecuteOnKeyCodec, keyData, proData, keyData, 1)\n            .then((clientMessage) => {\n            const response = MapExecuteOnKeyCodec_1.MapExecuteOnKeyCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    containsKeyInternal(keyData) {\n        return this.encodeInvokeOnKey(MapContainsKeyCodec_1.MapContainsKeyCodec, keyData, keyData, 0)\n            .then((clientMessage) => {\n            const response = MapContainsKeyCodec_1.MapContainsKeyCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    putInternal(keyData, valueData, ttl) {\n        return this.encodeInvokeOnKey(MapPutCodec_1.MapPutCodec, keyData, keyData, valueData, 0, ttl)\n            .then((clientMessage) => {\n            const response = MapPutCodec_1.MapPutCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    finalizePutAll(partitionsToKeys) {\n        // No-op\n    }\n    getInternal(keyData) {\n        return this.encodeInvokeOnKey(MapGetCodec_1.MapGetCodec, keyData, keyData, 0)\n            .then((clientMessage) => {\n            const response = MapGetCodec_1.MapGetCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    removeInternal(keyData, value = null) {\n        if (value == null) {\n            return this.encodeInvokeOnKey(MapRemoveCodec_1.MapRemoveCodec, keyData, keyData, 0)\n                .then((clientMessage) => {\n                const response = MapRemoveCodec_1.MapRemoveCodec.decodeResponse(clientMessage);\n                return this.toObject(response.response);\n            });\n        }\n        else {\n            const valueData = this.toData(value);\n            return this.encodeInvokeOnKey(MapRemoveIfSameCodec_1.MapRemoveIfSameCodec, keyData, keyData, valueData, 0)\n                .then((clientMessage) => {\n                const response = MapRemoveIfSameCodec_1.MapRemoveIfSameCodec.decodeResponse(clientMessage);\n                return response.response;\n            });\n        }\n    }\n    getAllInternal(partitionsToKeys, result = []) {\n        const partitionPromises = [];\n        for (const partition in partitionsToKeys) {\n            partitionPromises.push(this.encodeInvokeOnPartition(MapGetAllCodec_1.MapGetAllCodec, Number(partition), partitionsToKeys[partition])\n                .then((clientMessage) => {\n                const response = MapGetAllCodec_1.MapGetAllCodec.decodeResponse(clientMessage);\n                return response.response;\n            }));\n        }\n        const toObject = this.toObject.bind(this);\n        const deserializeEntry = function (entry) {\n            return [toObject(entry[0]), toObject(entry[1])];\n        };\n        return Promise.all(partitionPromises).then(function (serializedEntryArrayArray) {\n            const serializedEntryArray = Array.prototype.concat.apply([], serializedEntryArrayArray);\n            result.push(...(serializedEntryArray.map(deserializeEntry)));\n            return serializedEntryArray;\n        });\n    }\n    deleteInternal(keyData) {\n        return this.encodeInvokeOnKey(MapDeleteCodec_1.MapDeleteCodec, keyData, keyData, 0).then();\n    }\n    evictInternal(keyData) {\n        return this.encodeInvokeOnKey(MapEvictCodec_1.MapEvictCodec, keyData, keyData, 0)\n            .then((clientMessage) => {\n            const response = MapEvictCodec_1.MapEvictCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    putIfAbsentInternal(keyData, valueData, ttl) {\n        return this.encodeInvokeOnKey(MapPutIfAbsentCodec_1.MapPutIfAbsentCodec, keyData, keyData, valueData, 0, ttl)\n            .then((clientMessage) => {\n            const response = MapPutIfAbsentCodec_1.MapPutIfAbsentCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    putTransientInternal(keyData, valueData, ttl) {\n        return this.encodeInvokeOnKey(MapPutTransientCodec_1.MapPutTransientCodec, keyData, keyData, valueData, 0, ttl).then();\n    }\n    replaceInternal(keyData, newValueData) {\n        return this.encodeInvokeOnKey(MapReplaceCodec_1.MapReplaceCodec, keyData, keyData, newValueData, 0)\n            .then((clientMessage) => {\n            const response = MapReplaceCodec_1.MapReplaceCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    replaceIfSameInternal(keyData, oldValueData, newValueData) {\n        return this.encodeInvokeOnKey(MapReplaceIfSameCodec_1.MapReplaceIfSameCodec, keyData, keyData, oldValueData, newValueData, 0)\n            .then((clientMessage) => {\n            const response = MapReplaceIfSameCodec_1.MapReplaceIfSameCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    setInternal(keyData, valueData, ttl) {\n        return this.encodeInvokeOnKey(MapSetCodec_1.MapSetCodec, keyData, keyData, valueData, 0, ttl).then();\n    }\n    tryPutInternal(keyData, valueData, timeout) {\n        return this.encodeInvokeOnKey(MapTryPutCodec_1.MapTryPutCodec, keyData, keyData, valueData, 0, timeout)\n            .then((clientMessage) => {\n            const response = MapTryPutCodec_1.MapTryPutCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    tryRemoveInternal(keyData, timeout) {\n        return this.encodeInvokeOnKey(MapTryRemoveCodec_1.MapTryRemoveCodec, keyData, keyData, 0, timeout)\n            .then((clientMessage) => {\n            const response = MapTryRemoveCodec_1.MapTryRemoveCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    putAllInternal(pairs, triggerMapLoader) {\n        const partitionService = this.client.getPartitionService();\n        const partitionsToKeys = {};\n        for (const pair of pairs) {\n            const keyData = this.toData(pair[0]);\n            const pId = partitionService.getPartitionId(keyData);\n            if (!partitionsToKeys[pId]) {\n                partitionsToKeys[pId] = [];\n            }\n            partitionsToKeys[pId].push([keyData, this.toData(pair[1])]);\n        }\n        const partitionPromises = [];\n        for (const partition in partitionsToKeys) {\n            partitionPromises.push(this.encodeInvokeOnPartition(MapPutAllCodec_1.MapPutAllCodec, Number(partition), partitionsToKeys[partition], triggerMapLoader)\n                .then(() => this.finalizePutAll(partitionsToKeys)));\n        }\n        return Promise.all(partitionPromises).then();\n    }\n    addEntryListenerInternal(listener, predicate, key, includeValue) {\n        let flags = null;\n        const conversionTable = {\n            added: EventType_1.EventType.ADDED,\n            mapCleared: EventType_1.EventType.CLEAR_ALL,\n            evicted: EventType_1.EventType.EVICTED,\n            mapEvicted: EventType_1.EventType.EVICT_ALL,\n            merged: EventType_1.EventType.MERGED,\n            removed: EventType_1.EventType.REMOVED,\n            updated: EventType_1.EventType.UPDATED,\n            expired: EventType_1.EventType.EXPIRED,\n            loaded: EventType_1.EventType.LOADED,\n        };\n        for (const funcName in conversionTable) {\n            if (listener[funcName]) {\n                flags = flags | conversionTable[funcName];\n            }\n        }\n        const toObject = this.toObject.bind(this);\n        const entryEventHandler = (key, value, oldValue, mergingValue, eventType, uuid, numberOfAffectedEntries) => {\n            const member = this.client.getClusterService().getMember(uuid);\n            const name = this.name;\n            key = toObject(key);\n            value = toObject(value);\n            oldValue = toObject(oldValue);\n            mergingValue = toObject(mergingValue);\n            const entryEvent = new EntryListener_1.EntryEvent(name, key, value, oldValue, mergingValue, member);\n            const mapEvent = new MapListener_1.MapEvent(name, numberOfAffectedEntries, member);\n            switch (eventType) {\n                case EventType_1.EventType.ADDED:\n                    listener.added.apply(null, [entryEvent]);\n                    break;\n                case EventType_1.EventType.REMOVED:\n                    listener.removed.apply(null, [entryEvent]);\n                    break;\n                case EventType_1.EventType.UPDATED:\n                    listener.updated.apply(null, [entryEvent]);\n                    break;\n                case EventType_1.EventType.EVICTED:\n                    listener.evicted.apply(null, [entryEvent]);\n                    break;\n                case EventType_1.EventType.EVICT_ALL:\n                    listener.mapEvicted.apply(null, [mapEvent]);\n                    break;\n                case EventType_1.EventType.CLEAR_ALL:\n                    listener.mapCleared.apply(null, [mapEvent]);\n                    break;\n                case EventType_1.EventType.MERGED:\n                    listener.merged.apply(null, [entryEvent]);\n                    break;\n                case EventType_1.EventType.EXPIRED:\n                    listener.expired.apply(null, [entryEvent]);\n                    break;\n                case EventType_1.EventType.LOADED:\n                    listener.loaded.apply(null, [entryEvent]);\n                    break;\n            }\n        };\n        let codec;\n        let listenerHandler;\n        if (key && predicate) {\n            const keyData = this.toData(key);\n            const predicateData = this.toData(predicate);\n            codec = this.createEntryListenerToKeyWithPredicate(this.name, keyData, predicateData, includeValue, flags);\n            listenerHandler = MapAddEntryListenerToKeyWithPredicateCodec_1.MapAddEntryListenerToKeyWithPredicateCodec.handle;\n        }\n        else if (key && !predicate) {\n            const keyData = this.toData(key);\n            codec = this.createEntryListenerToKey(this.name, keyData, includeValue, flags);\n            listenerHandler = MapAddEntryListenerToKeyCodec_1.MapAddEntryListenerToKeyCodec.handle;\n        }\n        else if (!key && predicate) {\n            const predicateData = this.toData(predicate);\n            codec = this.createEntryListenerWithPredicate(this.name, predicateData, includeValue, flags);\n            listenerHandler = MapAddEntryListenerWithPredicateCodec_1.MapAddEntryListenerWithPredicateCodec.handle;\n        }\n        else {\n            codec = this.createEntryListener(this.name, includeValue, flags);\n            listenerHandler = MapAddEntryListenerCodec_1.MapAddEntryListenerCodec.handle;\n        }\n        return this.client.getListenerService()\n            .registerListener(codec, (m) => {\n            listenerHandler(m, entryEventHandler);\n        });\n    }\n    createEntryListenerToKey(name, keyData, includeValue, flags) {\n        return {\n            encodeAddRequest(localOnly) {\n                return MapAddEntryListenerToKeyCodec_1.MapAddEntryListenerToKeyCodec.encodeRequest(name, keyData, includeValue, flags, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return MapAddEntryListenerToKeyCodec_1.MapAddEntryListenerToKeyCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return MapRemoveEntryListenerCodec_1.MapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n    createEntryListenerToKeyWithPredicate(name, keyData, predicateData, includeValue, flags) {\n        return {\n            encodeAddRequest(localOnly) {\n                return MapAddEntryListenerToKeyWithPredicateCodec_1.MapAddEntryListenerToKeyWithPredicateCodec.encodeRequest(name, keyData, predicateData, includeValue, flags, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return MapAddEntryListenerToKeyWithPredicateCodec_1.MapAddEntryListenerToKeyWithPredicateCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return MapRemoveEntryListenerCodec_1.MapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n    createEntryListenerWithPredicate(name, predicateData, includeValue, flags) {\n        return {\n            encodeAddRequest(localOnly) {\n                return MapAddEntryListenerWithPredicateCodec_1.MapAddEntryListenerWithPredicateCodec.encodeRequest(name, predicateData, includeValue, flags, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return MapAddEntryListenerWithPredicateCodec_1.MapAddEntryListenerWithPredicateCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return MapRemoveEntryListenerCodec_1.MapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n    createEntryListener(name, includeValue, flags) {\n        return {\n            encodeAddRequest(localOnly) {\n                return MapAddEntryListenerCodec_1.MapAddEntryListenerCodec.encodeRequest(name, includeValue, flags, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return MapAddEntryListenerCodec_1.MapAddEntryListenerCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return MapRemoveEntryListenerCodec_1.MapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n    checkNotPagingPredicate(v) {\n        if (v instanceof DefaultPredicates_1.PagingPredicateImpl) {\n            throw new RangeError('Paging predicate is not supported.');\n        }\n    }\n}\nexports.MapProxy = MapProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/MapProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/MessageListener.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/MessageListener.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Message = void 0;\n/**\n * Message of Reliable Topic.\n */\nclass Message {\n}\nexports.Message = Message;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/MessageListener.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/MultiMap.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/MultiMap.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/MultiMap.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/MultiMapProxy.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/MultiMapProxy.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiMapProxy = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst MultiMapForceUnlockCodec_1 = __webpack_require__(/*! ../codec/MultiMapForceUnlockCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapForceUnlockCodec.js\");\nconst MultiMapIsLockedCodec_1 = __webpack_require__(/*! ../codec/MultiMapIsLockedCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapIsLockedCodec.js\");\nconst MultiMapLockCodec_1 = __webpack_require__(/*! ../codec/MultiMapLockCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapLockCodec.js\");\nconst MultiMapTryLockCodec_1 = __webpack_require__(/*! ../codec/MultiMapTryLockCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapTryLockCodec.js\");\nconst MultiMapUnlockCodec_1 = __webpack_require__(/*! ../codec/MultiMapUnlockCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapUnlockCodec.js\");\nconst EventType_1 = __webpack_require__(/*! ./EventType */ \"../shared/node_modules/hazelcast-client/lib/proxy/EventType.js\");\nconst EntryListener_1 = __webpack_require__(/*! ./EntryListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/EntryListener.js\");\nconst MultiMapAddEntryListenerCodec_1 = __webpack_require__(/*! ../codec/MultiMapAddEntryListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapAddEntryListenerCodec.js\");\nconst MultiMapAddEntryListenerToKeyCodec_1 = __webpack_require__(/*! ../codec/MultiMapAddEntryListenerToKeyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapAddEntryListenerToKeyCodec.js\");\nconst MultiMapClearCodec_1 = __webpack_require__(/*! ../codec/MultiMapClearCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapClearCodec.js\");\nconst MultiMapContainsEntryCodec_1 = __webpack_require__(/*! ../codec/MultiMapContainsEntryCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsEntryCodec.js\");\nconst MultiMapContainsKeyCodec_1 = __webpack_require__(/*! ../codec/MultiMapContainsKeyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsKeyCodec.js\");\nconst MultiMapContainsValueCodec_1 = __webpack_require__(/*! ../codec/MultiMapContainsValueCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapContainsValueCodec.js\");\nconst MultiMapEntrySetCodec_1 = __webpack_require__(/*! ../codec/MultiMapEntrySetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapEntrySetCodec.js\");\nconst MultiMapGetCodec_1 = __webpack_require__(/*! ../codec/MultiMapGetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapGetCodec.js\");\nconst MultiMapKeySetCodec_1 = __webpack_require__(/*! ../codec/MultiMapKeySetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapKeySetCodec.js\");\nconst MultiMapPutCodec_1 = __webpack_require__(/*! ../codec/MultiMapPutCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapPutCodec.js\");\nconst MultiMapRemoveCodec_1 = __webpack_require__(/*! ../codec/MultiMapRemoveCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveCodec.js\");\nconst MultiMapRemoveEntryCodec_1 = __webpack_require__(/*! ../codec/MultiMapRemoveEntryCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveEntryCodec.js\");\nconst MultiMapRemoveEntryListenerCodec_1 = __webpack_require__(/*! ../codec/MultiMapRemoveEntryListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapRemoveEntryListenerCodec.js\");\nconst MultiMapSizeCodec_1 = __webpack_require__(/*! ../codec/MultiMapSizeCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapSizeCodec.js\");\nconst MultiMapValueCountCodec_1 = __webpack_require__(/*! ../codec/MultiMapValueCountCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapValueCountCodec.js\");\nconst MultiMapValuesCodec_1 = __webpack_require__(/*! ../codec/MultiMapValuesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapValuesCodec.js\");\nconst BaseProxy_1 = __webpack_require__(/*! ./BaseProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/BaseProxy.js\");\nconst MapListener_1 = __webpack_require__(/*! ./MapListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/MapListener.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst SerializationUtil = __webpack_require__(/*! ../serialization/SerializationUtil */ \"../shared/node_modules/hazelcast-client/lib/serialization/SerializationUtil.js\");\nconst MultiMapPutAllCodec_1 = __webpack_require__(/*! ../codec/MultiMapPutAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MultiMapPutAllCodec.js\");\n/** @internal */\nclass MultiMapProxy extends BaseProxy_1.BaseProxy {\n    constructor() {\n        super(...arguments);\n        this.lockReferenceIdGenerator = this.client.getLockReferenceIdGenerator();\n        this.deserializeList = (items) => {\n            return items.map(this.toObject.bind(this));\n        };\n    }\n    put(key, value) {\n        const keyData = this.toData(key);\n        const valueData = this.toData(value);\n        return this.encodeInvokeOnKey(MultiMapPutCodec_1.MultiMapPutCodec, keyData, keyData, valueData, 1)\n            .then((clientMessage) => {\n            const response = MultiMapPutCodec_1.MultiMapPutCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    get(key) {\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MultiMapGetCodec_1.MultiMapGetCodec, keyData, keyData, 1)\n            .then((clientMessage) => {\n            const response = MultiMapGetCodec_1.MultiMapGetCodec.decodeResponse(clientMessage);\n            return new core_1.ReadOnlyLazyList(response.response, this.client.getSerializationService());\n        });\n    }\n    remove(key, value) {\n        const keyData = this.toData(key);\n        const valueData = this.toData(value);\n        return this.encodeInvokeOnKey(MultiMapRemoveEntryCodec_1.MultiMapRemoveEntryCodec, keyData, keyData, valueData, 1)\n            .then((clientMessage) => {\n            const response = MultiMapRemoveEntryCodec_1.MultiMapRemoveEntryCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    removeAll(key) {\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MultiMapRemoveCodec_1.MultiMapRemoveCodec, keyData, keyData, 1)\n            .then((clientMessage) => {\n            const response = MultiMapRemoveCodec_1.MultiMapRemoveCodec.decodeResponse(clientMessage);\n            return new core_1.ReadOnlyLazyList(response.response, this.client.getSerializationService());\n        });\n    }\n    keySet() {\n        return this.encodeInvokeOnRandomTarget(MultiMapKeySetCodec_1.MultiMapKeySetCodec)\n            .then((clientMessage) => {\n            const response = MultiMapKeySetCodec_1.MultiMapKeySetCodec.decodeResponse(clientMessage);\n            return this.deserializeList(response.response);\n        });\n    }\n    values() {\n        return this.encodeInvokeOnRandomTarget(MultiMapValuesCodec_1.MultiMapValuesCodec)\n            .then((clientMessage) => {\n            const response = MultiMapValuesCodec_1.MultiMapValuesCodec.decodeResponse(clientMessage);\n            return new core_1.ReadOnlyLazyList(response.response, this.client.getSerializationService());\n        });\n    }\n    entrySet() {\n        return this.encodeInvokeOnRandomTarget(MultiMapEntrySetCodec_1.MultiMapEntrySetCodec)\n            .then((clientMessage) => {\n            const response = MultiMapEntrySetCodec_1.MultiMapEntrySetCodec.decodeResponse(clientMessage);\n            return SerializationUtil.deserializeEntryList(this.toObject.bind(this), response.response);\n        });\n    }\n    containsKey(key) {\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MultiMapContainsKeyCodec_1.MultiMapContainsKeyCodec, keyData, keyData, 1)\n            .then((clientMessage) => {\n            const response = MultiMapContainsKeyCodec_1.MultiMapContainsKeyCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    containsValue(value) {\n        const valueData = this.toData(value);\n        return this.encodeInvokeOnRandomTarget(MultiMapContainsValueCodec_1.MultiMapContainsValueCodec, valueData)\n            .then((clientMessage) => {\n            const response = MultiMapContainsValueCodec_1.MultiMapContainsValueCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    containsEntry(key, value) {\n        const keyData = this.toData(key);\n        const valueData = this.toData(value);\n        return this.encodeInvokeOnKey(MultiMapContainsEntryCodec_1.MultiMapContainsEntryCodec, keyData, keyData, valueData, 1)\n            .then((clientMessage) => {\n            const response = MultiMapContainsEntryCodec_1.MultiMapContainsEntryCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    size() {\n        return this.encodeInvokeOnRandomTarget(MultiMapSizeCodec_1.MultiMapSizeCodec)\n            .then((clientMessage) => {\n            const response = MultiMapSizeCodec_1.MultiMapSizeCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    clear() {\n        return this.encodeInvokeOnRandomTarget(MultiMapClearCodec_1.MultiMapClearCodec).then();\n    }\n    valueCount(key) {\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MultiMapValueCountCodec_1.MultiMapValueCountCodec, keyData, keyData, 1)\n            .then((clientMessage) => {\n            const response = MultiMapValueCountCodec_1.MultiMapValueCountCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    addEntryListener(listener, key, includeValue = true) {\n        const toObject = this.toObject.bind(this);\n        const entryEventHandler = (keyData, valueData, oldValueData, mergingValueData, eventType, uuid, numberOfAffectedEntries) => {\n            const member = this.client.getClusterService().getMember(uuid);\n            const name = this.name;\n            key = toObject(keyData);\n            const value = toObject(valueData);\n            const oldValue = toObject(oldValueData);\n            const mergingValue = toObject(mergingValueData);\n            const entryEvent = new EntryListener_1.EntryEvent(name, key, value, oldValue, mergingValue, member);\n            const mapEvent = new MapListener_1.MapEvent(name, numberOfAffectedEntries, member);\n            // Multi map only supports these three event types\n            switch (eventType) {\n                case EventType_1.EventType.ADDED:\n                    if (listener.added) {\n                        listener.added.apply(null, [entryEvent]);\n                    }\n                    break;\n                case EventType_1.EventType.REMOVED:\n                    if (listener.removed) {\n                        listener.removed.apply(null, [entryEvent]);\n                    }\n                    break;\n                case EventType_1.EventType.CLEAR_ALL:\n                    if (listener.mapCleared) {\n                        listener.mapCleared.apply(null, [mapEvent]);\n                    }\n                    break;\n            }\n        };\n        if (key) {\n            const keyData = this.toData(key);\n            const handler = (m) => {\n                MultiMapAddEntryListenerToKeyCodec_1.MultiMapAddEntryListenerToKeyCodec.handle(m, entryEventHandler);\n            };\n            const codec = this.createEntryListenerToKey(this.name, keyData, includeValue);\n            return this.client.getListenerService().registerListener(codec, handler);\n        }\n        else {\n            const listenerHandler = (m) => {\n                MultiMapAddEntryListenerCodec_1.MultiMapAddEntryListenerCodec.handle(m, entryEventHandler);\n            };\n            const codec = this.createEntryListener(this.name, includeValue);\n            return this.client.getListenerService().registerListener(codec, listenerHandler);\n        }\n    }\n    removeEntryListener(listenerId) {\n        return this.client.getListenerService().deregisterListener(listenerId);\n    }\n    lock(key, leaseMillis = -1) {\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MultiMapLockCodec_1.MultiMapLockCodec, keyData, keyData, 1, leaseMillis, this.nextSequence())\n            .then();\n    }\n    isLocked(key) {\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MultiMapIsLockedCodec_1.MultiMapIsLockedCodec, keyData, keyData)\n            .then((clientMessage) => {\n            const response = MultiMapIsLockedCodec_1.MultiMapIsLockedCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    tryLock(key, timeoutMillis = 0, leaseMillis = -1) {\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MultiMapTryLockCodec_1.MultiMapTryLockCodec, keyData, keyData, 1, leaseMillis, timeoutMillis, this.nextSequence())\n            .then((clientMessage) => {\n            const response = MultiMapTryLockCodec_1.MultiMapTryLockCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    unlock(key) {\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MultiMapUnlockCodec_1.MultiMapUnlockCodec, keyData, keyData, 1, this.nextSequence()).then();\n    }\n    forceUnlock(key) {\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(MultiMapForceUnlockCodec_1.MultiMapForceUnlockCodec, keyData, keyData, this.nextSequence()).then();\n    }\n    putAll(pairs) {\n        if (pairs.length === 0) {\n            return Promise.resolve();\n        }\n        const dataPairs = [];\n        for (const pair of pairs) {\n            const valuesData = SerializationUtil.serializeList(this.toData.bind(this), pair[1]);\n            dataPairs.push([this.toData(pair[0]), valuesData]);\n        }\n        const partitionService = this.client.getPartitionService();\n        const partitionToDataPairs = new Map();\n        for (const dataPair of dataPairs) {\n            const partitionId = partitionService.getPartitionId(dataPair[0]);\n            let partitionedDataPairs = partitionToDataPairs.get(partitionId);\n            if (partitionedDataPairs == null) {\n                partitionedDataPairs = [];\n                partitionToDataPairs.set(partitionId, partitionedDataPairs);\n            }\n            partitionedDataPairs.push(dataPair);\n        }\n        const partitionPromises = [];\n        partitionToDataPairs.forEach((pair, partitionId) => {\n            partitionPromises.push(this.encodeInvokeOnPartition(MultiMapPutAllCodec_1.MultiMapPutAllCodec, partitionId, pair));\n        });\n        return Promise.all(partitionPromises).then();\n    }\n    nextSequence() {\n        return this.lockReferenceIdGenerator.getNextReferenceId();\n    }\n    createEntryListenerToKey(name, keyData, includeValue) {\n        return {\n            encodeAddRequest(localOnly) {\n                return MultiMapAddEntryListenerToKeyCodec_1.MultiMapAddEntryListenerToKeyCodec.encodeRequest(name, keyData, includeValue, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return MultiMapAddEntryListenerToKeyCodec_1.MultiMapAddEntryListenerToKeyCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return MultiMapRemoveEntryListenerCodec_1.MultiMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n    createEntryListener(name, includeValue) {\n        return {\n            encodeAddRequest(localOnly) {\n                return MultiMapAddEntryListenerCodec_1.MultiMapAddEntryListenerCodec.encodeRequest(name, includeValue, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return MultiMapAddEntryListenerCodec_1.MultiMapAddEntryListenerCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return MultiMapRemoveEntryListenerCodec_1.MultiMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n}\nexports.MultiMapProxy = MultiMapProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/MultiMapProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/NearCachedMapProxy.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/NearCachedMapProxy.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NearCachedMapProxy = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst MapAddNearCacheInvalidationListenerCodec_1 = __webpack_require__(/*! ../codec/MapAddNearCacheInvalidationListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapAddNearCacheInvalidationListenerCodec.js\");\nconst MapRemoveEntryListenerCodec_1 = __webpack_require__(/*! ../codec/MapRemoveEntryListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/MapRemoveEntryListenerCodec.js\");\nconst EventType_1 = __webpack_require__(/*! ./EventType */ \"../shared/node_modules/hazelcast-client/lib/proxy/EventType.js\");\nconst StaleReadDetector_1 = __webpack_require__(/*! ../nearcache/StaleReadDetector */ \"../shared/node_modules/hazelcast-client/lib/nearcache/StaleReadDetector.js\");\nconst MapProxy_1 = __webpack_require__(/*! ./MapProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/MapProxy.js\");\n/** @internal */\nclass NearCachedMapProxy extends MapProxy_1.MapProxy {\n    constructor(client, servicename, name) {\n        super(client, servicename, name);\n        this.nearCache = this.client.getNearCacheManager().getOrCreateNearCache(name);\n        if (this.nearCache.isInvalidatedOnChange()) {\n            this.addNearCacheInvalidationListener().then((id) => {\n                this.invalidationListenerId = id;\n                this.nearCache.setReady();\n            });\n        }\n        else {\n            this.nearCache.setReady();\n        }\n    }\n    clear() {\n        return super.clear().then(this.invalidateCacheAndReturn.bind(this));\n    }\n    evictAll() {\n        this.nearCache.clear();\n        return super.evictAll().then(this.invalidateCacheAndReturn.bind(this));\n    }\n    containsKeyInternal(keyData) {\n        return this.nearCache.get(keyData).then((cachedValue) => {\n            if (cachedValue !== undefined) {\n                return Promise.resolve(cachedValue != null);\n            }\n            else {\n                return super.containsKeyInternal(keyData);\n            }\n        });\n    }\n    deleteInternal(keyData) {\n        this.nearCache.invalidate(keyData);\n        return super.deleteInternal(keyData).then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    evictInternal(key) {\n        return super.evictInternal(key).then(this.invalidateCacheEntryAndReturn.bind(this, key));\n    }\n    finalizePutAll(partitionsToKeysData) {\n        for (const partition in partitionsToKeysData) {\n            partitionsToKeysData[partition].forEach((entry) => {\n                this.nearCache.invalidate(entry[0]);\n            });\n        }\n    }\n    postDestroy() {\n        return this.removeNearCacheInvalidationListener().then(() => {\n            this.client.getNearCacheManager().destroyNearCache(this.name);\n        }).then(() => {\n            return super.postDestroy();\n        });\n    }\n    putIfAbsentInternal(keyData, valueData, ttl) {\n        return super.putIfAbsentInternal(keyData, valueData, ttl).then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    putTransientInternal(keyData, valueData, ttl) {\n        return super\n            .putTransientInternal(keyData, valueData, ttl).then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    executeOnKeyInternal(keyData, proData) {\n        return super.executeOnKeyInternal(keyData, proData).then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    putInternal(keyData, valueData, ttl) {\n        return super.putInternal(keyData, valueData, ttl).then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    getInternal(keyData) {\n        return this.nearCache.get(keyData).then((cachedValue) => {\n            if (cachedValue !== undefined) {\n                return Promise.resolve(cachedValue);\n            }\n            else {\n                const reservation = this.nearCache.tryReserveForUpdate(keyData);\n                return super.getInternal(keyData).then((val) => {\n                    this.nearCache.tryPublishReserved(keyData, val, reservation);\n                    return val;\n                }).catch((err) => {\n                    throw err;\n                });\n            }\n        });\n    }\n    tryRemoveInternal(keyData, timeout) {\n        return super.tryRemoveInternal(keyData, timeout).then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    removeInternal(keyData, value) {\n        return super.removeInternal(keyData, value).then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    getAllInternal(partitionsToKeys, result = []) {\n        const promises = [];\n        try {\n            for (const partition in partitionsToKeys) {\n                let partitionArray = partitionsToKeys[partition];\n                for (let i = partitionArray.length - 1; i >= 0; i--) {\n                    const key = partitionArray[i];\n                    promises.push(this.nearCache.get(key).then((cachedResult) => {\n                        if (cachedResult !== undefined) {\n                            result.push([this.toObject(partitionArray[i]), cachedResult]);\n                            partitionArray = partitionArray.splice(i, 1);\n                        }\n                    }));\n                }\n            }\n        }\n        catch (err) {\n            return Promise.resolve([]);\n        }\n        return Promise.all(promises).then(() => {\n            const reservations = [];\n            for (const partition in partitionsToKeys) {\n                const partitionArray = partitionsToKeys[partition];\n                for (const key of partitionArray) {\n                    reservations.push(this.nearCache.tryReserveForUpdate(key));\n                }\n            }\n            return super.getAllInternal(partitionsToKeys, result).then((serializedEntryArray) => {\n                serializedEntryArray.forEach((serializedEntry, index) => {\n                    const key = serializedEntry[0];\n                    const value = serializedEntry[1];\n                    this.nearCache.tryPublishReserved(key, value, reservations[index]);\n                });\n                return result;\n            });\n        });\n    }\n    replaceIfSameInternal(keyData, oldValueData, newValueData) {\n        return super.replaceIfSameInternal(keyData, oldValueData, newValueData)\n            .then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    replaceInternal(keyData, valueData) {\n        return super.replaceInternal(keyData, valueData).then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    setInternal(keyData, valueData, ttl) {\n        return super.setInternal(keyData, valueData, ttl).then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    tryPutInternal(keyData, valueData, timeout) {\n        return super.tryPutInternal(keyData, valueData, timeout)\n            .then(this.invalidateCacheEntryAndReturn.bind(this, keyData));\n    }\n    removeNearCacheInvalidationListener() {\n        this.client.getRepairingTask().deregisterHandler(this.name);\n        return this.client.getListenerService().deregisterListener(this.invalidationListenerId);\n    }\n    invalidateCacheEntryAndReturn(keyData, retVal) {\n        this.nearCache.invalidate(keyData);\n        return retVal;\n    }\n    invalidateCacheAndReturn(retVal) {\n        this.nearCache.clear();\n        return retVal;\n    }\n    addNearCacheInvalidationListener() {\n        const codec = this.createInvalidationListenerCodec(this.name, EventType_1.EventType.INVALIDATION);\n        return this.createNearCacheEventHandler().then((handler) => {\n            return this.client.getListenerService().registerListener(codec, handler);\n        });\n    }\n    createInvalidationListenerCodec(name, flags) {\n        return {\n            encodeAddRequest(localOnly) {\n                return MapAddNearCacheInvalidationListenerCodec_1.MapAddNearCacheInvalidationListenerCodec.encodeRequest(name, flags, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return MapAddNearCacheInvalidationListenerCodec_1.MapAddNearCacheInvalidationListenerCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return MapRemoveEntryListenerCodec_1.MapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n    createNearCacheEventHandler() {\n        const repairingTask = this.client.getRepairingTask();\n        return repairingTask.registerAndGetHandler(this.getName(), this.nearCache).then((repairingHandler) => {\n            const staleReadDetector = new StaleReadDetector_1.StaleReadDetectorImpl(repairingHandler, this.client.getPartitionService());\n            this.nearCache.setStaleReadDetector(staleReadDetector);\n            const handle = function (key, sourceUuid, partitionUuid, sequence) {\n                repairingHandler.handle(key, sourceUuid, partitionUuid, sequence);\n            };\n            const handleBatch = function (keys, sourceUuids, partititonUuids, sequences) {\n                repairingHandler.handleBatch(keys, sourceUuids, partititonUuids, sequences);\n            };\n            return function (m) {\n                MapAddNearCacheInvalidationListenerCodec_1.MapAddNearCacheInvalidationListenerCodec.handle(m, handle, handleBatch);\n            };\n        });\n    }\n}\nexports.NearCachedMapProxy = NearCachedMapProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/NearCachedMapProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/OverflowPolicy.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/OverflowPolicy.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.overflowPolicyToId = exports.OverflowPolicy = void 0;\n/**\n * Overflow policy for Ringbuffer and Reliable Topic operations.\n */\nvar OverflowPolicy;\n(function (OverflowPolicy) {\n    /**\n     * The new item will overwrite the oldest one regardless of the\n     * configured time-to-live.\n     */\n    OverflowPolicy[\"OVERWRITE\"] = \"OVERWRITE\";\n    /**\n     * Add operations will keep failing until an oldest item in this\n     * ringbuffer will reach its time-to-live.\n     */\n    OverflowPolicy[\"FAIL\"] = \"FAIL\";\n})(OverflowPolicy = exports.OverflowPolicy || (exports.OverflowPolicy = {}));\n/** @internal */\nexports.overflowPolicyToId = (type) => {\n    switch (type) {\n        case OverflowPolicy.OVERWRITE:\n            return 0;\n        case OverflowPolicy.FAIL:\n            return 1;\n        default:\n            throw new TypeError('Unexpected type value: ' + type);\n    }\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/OverflowPolicy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/PNCounter.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/PNCounter.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/PNCounter.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/PNCounterProxy.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/PNCounterProxy.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNCounterProxy = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst PNCounterAddCodec_1 = __webpack_require__(/*! ../codec/PNCounterAddCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/PNCounterAddCodec.js\");\nconst PNCounterGetCodec_1 = __webpack_require__(/*! ../codec/PNCounterGetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/PNCounterGetCodec.js\");\nconst PNCounterGetConfiguredReplicaCountCodec_1 = __webpack_require__(/*! ../codec/PNCounterGetConfiguredReplicaCountCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/PNCounterGetConfiguredReplicaCountCodec.js\");\nconst MemberSelector_1 = __webpack_require__(/*! ../core/MemberSelector */ \"../shared/node_modules/hazelcast-client/lib/core/MemberSelector.js\");\nconst VectorClock_1 = __webpack_require__(/*! ./VectorClock */ \"../shared/node_modules/hazelcast-client/lib/proxy/VectorClock.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst BaseProxy_1 = __webpack_require__(/*! ./BaseProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/BaseProxy.js\");\n/** @internal */\nclass PNCounterProxy extends BaseProxy_1.BaseProxy {\n    constructor() {\n        super(...arguments);\n        this.lastObservedVectorClock = new VectorClock_1.VectorClock();\n        this.maximumReplicaCount = 0;\n    }\n    get() {\n        return this.invokeInternal(PNCounterProxy.EMPTY_ARRAY, null, PNCounterGetCodec_1.PNCounterGetCodec);\n    }\n    getAndAdd(delta) {\n        return this.invokeInternal(PNCounterProxy.EMPTY_ARRAY, null, PNCounterAddCodec_1.PNCounterAddCodec, delta, true);\n    }\n    addAndGet(delta) {\n        return this.invokeInternal(PNCounterProxy.EMPTY_ARRAY, null, PNCounterAddCodec_1.PNCounterAddCodec, delta, false);\n    }\n    getAndSubtract(delta) {\n        if (!Long.isLong(delta)) {\n            delta = Long.fromNumber(delta);\n        }\n        return this.invokeInternal(PNCounterProxy.EMPTY_ARRAY, null, PNCounterAddCodec_1.PNCounterAddCodec, delta.neg(), true);\n    }\n    subtractAndGet(delta) {\n        if (!Long.isLong(delta)) {\n            delta = Long.fromNumber(delta);\n        }\n        return this.invokeInternal(PNCounterProxy.EMPTY_ARRAY, null, PNCounterAddCodec_1.PNCounterAddCodec, delta.neg(), false);\n    }\n    decrementAndGet() {\n        return this.invokeInternal(PNCounterProxy.EMPTY_ARRAY, null, PNCounterAddCodec_1.PNCounterAddCodec, Long.fromNumber(-1), false);\n    }\n    incrementAndGet() {\n        return this.invokeInternal(PNCounterProxy.EMPTY_ARRAY, null, PNCounterAddCodec_1.PNCounterAddCodec, Long.fromNumber(1), false);\n    }\n    getAndDecrement() {\n        return this.invokeInternal(PNCounterProxy.EMPTY_ARRAY, null, PNCounterAddCodec_1.PNCounterAddCodec, Long.fromNumber(-1), true);\n    }\n    getAndIncrement() {\n        return this.invokeInternal(PNCounterProxy.EMPTY_ARRAY, null, PNCounterAddCodec_1.PNCounterAddCodec, Long.fromNumber(1), true);\n    }\n    reset() {\n        this.lastObservedVectorClock = new VectorClock_1.VectorClock();\n        return Promise.resolve();\n    }\n    invokeInternal(excludedAddresses, lastError, codec, ...codecArgs) {\n        return this.getCRDTOperationTarget(excludedAddresses).then((target) => {\n            if (target == null) {\n                if (lastError) {\n                    throw lastError;\n                }\n                else {\n                    throw new core_1.NoDataMemberInClusterError('Cannot invoke operations on a CRDT ' +\n                        'because the cluster does not contain any data members');\n                }\n            }\n            return this.encodeInvokeInternal(target, codec, ...codecArgs).then((result) => {\n                this.updateObservedReplicaTimestamps(result.replicaTimestamps);\n                return result.value;\n            }).catch((err) => {\n                if (excludedAddresses === PNCounterProxy.EMPTY_ARRAY) {\n                    excludedAddresses = [];\n                }\n                excludedAddresses.push(target);\n                return this.invokeInternal(excludedAddresses, err, codec, ...codecArgs);\n            });\n        });\n    }\n    encodeInvokeInternal(target, codec, ...codecArguments) {\n        return this.encodeInvokeOnTarget(codec, target.uuid, ...codecArguments, this.lastObservedVectorClock.entrySet(), target.uuid)\n            .then((clientMessage) => {\n            return codec.decodeResponse(clientMessage);\n        });\n    }\n    getCRDTOperationTarget(excludedAddresses) {\n        if (this.currentTargetReplicaAddress != null &&\n            !excludedAddresses.some(this.currentTargetReplicaAddress.equals.bind(this.currentTargetReplicaAddress))) {\n            return Promise.resolve(this.currentTargetReplicaAddress);\n        }\n        else {\n            return this.chooseTargetReplica(excludedAddresses).then((target) => {\n                this.currentTargetReplicaAddress = target;\n                return target;\n            });\n        }\n    }\n    chooseTargetReplica(excludedAddresses) {\n        return this.getReplicaAddresses(excludedAddresses).then((replicaAddresses) => {\n            if (replicaAddresses.length === 0) {\n                return null;\n            }\n            return replicaAddresses[Util_1.randomInt(replicaAddresses.length)];\n        });\n    }\n    getReplicaAddresses(excludedAddresses) {\n        const dataMembers = this.client.getClusterService().getMembers(MemberSelector_1.dataMemberSelector);\n        return this.getMaxConfiguredReplicaCount().then((replicaCount) => {\n            const currentCount = Math.min(replicaCount, dataMembers.length);\n            const replicaAddresses = [];\n            for (let i = 0; i < currentCount; i++) {\n                const memberAddress = dataMembers[i];\n                if (!excludedAddresses.some(memberAddress.equals.bind(memberAddress))) {\n                    replicaAddresses.push(memberAddress);\n                }\n            }\n            return replicaAddresses;\n        });\n    }\n    getMaxConfiguredReplicaCount() {\n        if (this.maximumReplicaCount > 0) {\n            return Promise.resolve(this.maximumReplicaCount);\n        }\n        else {\n            return this.encodeInvokeOnRandomTarget(PNCounterGetConfiguredReplicaCountCodec_1.PNCounterGetConfiguredReplicaCountCodec)\n                .then((clientMessage) => {\n                const response = PNCounterGetConfiguredReplicaCountCodec_1.PNCounterGetConfiguredReplicaCountCodec.decodeResponse(clientMessage);\n                this.maximumReplicaCount = response.response;\n                return this.maximumReplicaCount;\n            });\n        }\n    }\n    updateObservedReplicaTimestamps(observedTimestamps) {\n        const observedClock = this.toVectorClock(observedTimestamps);\n        if (observedClock.isAfter(this.lastObservedVectorClock)) {\n            this.lastObservedVectorClock = observedClock;\n        }\n    }\n    toVectorClock(timestamps) {\n        const vectorClock = new VectorClock_1.VectorClock();\n        timestamps.forEach((entry) => {\n            vectorClock.setReplicaTimestamp(entry[0], entry[1]);\n        });\n        return vectorClock;\n    }\n}\nexports.PNCounterProxy = PNCounterProxy;\nPNCounterProxy.EMPTY_ARRAY = [];\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/PNCounterProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/PartitionSpecificProxy.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/PartitionSpecificProxy.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PartitionSpecificProxy = void 0;\nconst BaseProxy_1 = __webpack_require__(/*! ./BaseProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/BaseProxy.js\");\n/** @internal */\nclass PartitionSpecificProxy extends BaseProxy_1.BaseProxy {\n    constructor(client, serviceName, name) {\n        super(client, serviceName, name);\n        this.partitionId = this.client.getPartitionService().getPartitionId(this.getPartitionKey());\n    }\n    encodeInvoke(codec, ...codecArguments) {\n        return this.encodeInvokeOnPartition(codec, this.partitionId, ...codecArguments);\n    }\n}\nexports.PartitionSpecificProxy = PartitionSpecificProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/PartitionSpecificProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/ProxyManager.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/ProxyManager.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProxyManager = exports.NAMESPACE_SEPARATOR = void 0;\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst ClientAddDistributedObjectListenerCodec_1 = __webpack_require__(/*! ../codec/ClientAddDistributedObjectListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientAddDistributedObjectListenerCodec.js\");\nconst ClientCreateProxyCodec_1 = __webpack_require__(/*! ../codec/ClientCreateProxyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientCreateProxyCodec.js\");\nconst ClientDestroyProxyCodec_1 = __webpack_require__(/*! ../codec/ClientDestroyProxyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientDestroyProxyCodec.js\");\nconst ClientRemoveDistributedObjectListenerCodec_1 = __webpack_require__(/*! ../codec/ClientRemoveDistributedObjectListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientRemoveDistributedObjectListenerCodec.js\");\nconst InvocationService_1 = __webpack_require__(/*! ../invocation/InvocationService */ \"../shared/node_modules/hazelcast-client/lib/invocation/InvocationService.js\");\nconst FlakeIdGeneratorProxy_1 = __webpack_require__(/*! ./flakeid/FlakeIdGeneratorProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/flakeid/FlakeIdGeneratorProxy.js\");\nconst ListProxy_1 = __webpack_require__(/*! ./ListProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/ListProxy.js\");\nconst MapProxy_1 = __webpack_require__(/*! ./MapProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/MapProxy.js\");\nconst MultiMapProxy_1 = __webpack_require__(/*! ./MultiMapProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/MultiMapProxy.js\");\nconst NearCachedMapProxy_1 = __webpack_require__(/*! ./NearCachedMapProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/NearCachedMapProxy.js\");\nconst PNCounterProxy_1 = __webpack_require__(/*! ./PNCounterProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/PNCounterProxy.js\");\nconst QueueProxy_1 = __webpack_require__(/*! ./QueueProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/QueueProxy.js\");\nconst ReplicatedMapProxy_1 = __webpack_require__(/*! ./ReplicatedMapProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/ReplicatedMapProxy.js\");\nconst RingbufferProxy_1 = __webpack_require__(/*! ./ringbuffer/RingbufferProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/ringbuffer/RingbufferProxy.js\");\nconst SetProxy_1 = __webpack_require__(/*! ./SetProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/SetProxy.js\");\nconst ReliableTopicProxy_1 = __webpack_require__(/*! ./topic/ReliableTopicProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicProxy.js\");\nconst DistributedObjectListener_1 = __webpack_require__(/*! ../core/DistributedObjectListener */ \"../shared/node_modules/hazelcast-client/lib/core/DistributedObjectListener.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst ClientCreateProxiesCodec_1 = __webpack_require__(/*! ../codec/ClientCreateProxiesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientCreateProxiesCodec.js\");\n/** @internal */\nexports.NAMESPACE_SEPARATOR = '/';\nconst RINGBUFFER_PREFIX = '_hz_rb_';\n/** @internal */\nclass ProxyManager {\n    constructor(client) {\n        this.service = {};\n        this.proxies = new Map();\n        this.client = client;\n    }\n    init() {\n        this.service[ProxyManager.MAP_SERVICE] = MapProxy_1.MapProxy;\n        this.service[ProxyManager.SET_SERVICE] = SetProxy_1.SetProxy;\n        this.service[ProxyManager.QUEUE_SERVICE] = QueueProxy_1.QueueProxy;\n        this.service[ProxyManager.LIST_SERVICE] = ListProxy_1.ListProxy;\n        this.service[ProxyManager.MULTIMAP_SERVICE] = MultiMapProxy_1.MultiMapProxy;\n        this.service[ProxyManager.RINGBUFFER_SERVICE] = RingbufferProxy_1.RingbufferProxy;\n        this.service[ProxyManager.REPLICATEDMAP_SERVICE] = ReplicatedMapProxy_1.ReplicatedMapProxy;\n        this.service[ProxyManager.FLAKEID_SERVICE] = FlakeIdGeneratorProxy_1.FlakeIdGeneratorProxy;\n        this.service[ProxyManager.PNCOUNTER_SERVICE] = PNCounterProxy_1.PNCounterProxy;\n        this.service[ProxyManager.RELIABLETOPIC_SERVICE] = ReliableTopicProxy_1.ReliableTopicProxy;\n    }\n    getOrCreateProxy(name, serviceName, createAtServer = true) {\n        const fullName = serviceName + exports.NAMESPACE_SEPARATOR + name;\n        if (this.proxies.has(fullName)) {\n            return this.proxies.get(fullName);\n        }\n        const deferred = Util_1.DeferredPromise();\n        this.proxies.set(fullName, deferred.promise);\n        let createProxyPromise;\n        if (createAtServer) {\n            createProxyPromise = this.createProxy(name, serviceName);\n        }\n        else {\n            createProxyPromise = Promise.resolve();\n        }\n        createProxyPromise\n            .then(() => {\n            return this.initializeLocalProxy(name, serviceName, createAtServer);\n        })\n            .then((localProxy) => {\n            deferred.resolve(localProxy);\n        })\n            .catch((error) => {\n            this.proxies.delete(fullName);\n            deferred.reject(error);\n        });\n        return deferred.promise;\n    }\n    createDistributedObjectsOnCluster() {\n        const proxyEntries = new Array(this.proxies.size);\n        let index = 0;\n        this.proxies.forEach((_, namespace) => {\n            const separatorIndex = namespace.indexOf(exports.NAMESPACE_SEPARATOR);\n            const serviceName = namespace.substring(0, separatorIndex);\n            const name = namespace.substring(separatorIndex + 1);\n            proxyEntries[index++] = [name, serviceName];\n        });\n        if (proxyEntries.length === 0) {\n            return Promise.resolve();\n        }\n        const request = ClientCreateProxiesCodec_1.ClientCreateProxiesCodec.encodeRequest(proxyEntries);\n        request.setPartitionId(-1);\n        const invocation = new InvocationService_1.Invocation(this.client, request);\n        return this.client.getInvocationService().invokeUrgent(invocation).then();\n    }\n    getDistributedObjects() {\n        const promises = new Array(this.proxies.size);\n        let index = 0;\n        this.proxies.forEach((proxy) => {\n            promises[index++] = proxy;\n        });\n        return Promise.all(promises);\n    }\n    destroyProxy(name, serviceName) {\n        this.proxies.delete(serviceName + exports.NAMESPACE_SEPARATOR + name);\n        const clientMessage = ClientDestroyProxyCodec_1.ClientDestroyProxyCodec.encodeRequest(name, serviceName);\n        clientMessage.setPartitionId(-1);\n        return this.client.getInvocationService().invokeOnRandomTarget(clientMessage).then();\n    }\n    destroyProxyLocally(namespace) {\n        const proxy = this.proxies.get(namespace);\n        if (proxy != null) {\n            this.proxies.delete(namespace);\n            return proxy.then((distributedObject) => {\n                return distributedObject.destroyLocally();\n            });\n        }\n        return Promise.resolve();\n    }\n    addDistributedObjectListener(distributedObjectListener) {\n        const handler = (clientMessage) => {\n            const converterFunc = (objectName, serviceName, eventType) => {\n                eventType = eventType.toLowerCase();\n                const distributedObjectEvent = new DistributedObjectListener_1.DistributedObjectEvent(eventType, serviceName, objectName);\n                distributedObjectListener(distributedObjectEvent);\n            };\n            ClientAddDistributedObjectListenerCodec_1.ClientAddDistributedObjectListenerCodec.handle(clientMessage, converterFunc);\n        };\n        const codec = this.createDistributedObjectListener();\n        return this.client.getListenerService().registerListener(codec, handler);\n    }\n    removeDistributedObjectListener(listenerId) {\n        return this.client.getListenerService().deregisterListener(listenerId);\n    }\n    destroy() {\n        this.proxies.clear();\n    }\n    createProxy(name, serviceName) {\n        const request = ClientCreateProxyCodec_1.ClientCreateProxyCodec.encodeRequest(name, serviceName);\n        return this.client.getInvocationService().invokeOnRandomTarget(request);\n    }\n    createDistributedObjectListener() {\n        return {\n            encodeAddRequest(localOnly) {\n                return ClientAddDistributedObjectListenerCodec_1.ClientAddDistributedObjectListenerCodec.encodeRequest(localOnly);\n            },\n            decodeAddResponse(msg) {\n                return ClientAddDistributedObjectListenerCodec_1.ClientAddDistributedObjectListenerCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return ClientRemoveDistributedObjectListenerCodec_1.ClientRemoveDistributedObjectListenerCodec.encodeRequest(listenerId);\n            },\n        };\n    }\n    initializeLocalProxy(name, serviceName, createAtServer) {\n        let localProxy;\n        const config = this.client.getConfig();\n        if (serviceName === ProxyManager.MAP_SERVICE && config.getNearCacheConfig(name)) {\n            localProxy = new NearCachedMapProxy_1.NearCachedMapProxy(this.client, serviceName, name);\n        }\n        else {\n            // This call may throw ClientOfflineError for partition specific proxies with async start\n            localProxy = new this.service[serviceName](this.client, serviceName, name);\n        }\n        if (serviceName === ProxyManager.RELIABLETOPIC_SERVICE) {\n            return this.getOrCreateProxy(RINGBUFFER_PREFIX + name, ProxyManager.RINGBUFFER_SERVICE, createAtServer)\n                .then((ringbuffer) => {\n                localProxy.setRingbuffer(ringbuffer);\n                return localProxy;\n            });\n        }\n        else {\n            return Promise.resolve(localProxy);\n        }\n    }\n}\nexports.ProxyManager = ProxyManager;\nProxyManager.MAP_SERVICE = 'hz:impl:mapService';\nProxyManager.SET_SERVICE = 'hz:impl:setService';\nProxyManager.LOCK_SERVICE = 'hz:impl:lockService';\nProxyManager.QUEUE_SERVICE = 'hz:impl:queueService';\nProxyManager.LIST_SERVICE = 'hz:impl:listService';\nProxyManager.MULTIMAP_SERVICE = 'hz:impl:multiMapService';\nProxyManager.RINGBUFFER_SERVICE = 'hz:impl:ringbufferService';\nProxyManager.REPLICATEDMAP_SERVICE = 'hz:impl:replicatedMapService';\nProxyManager.FLAKEID_SERVICE = 'hz:impl:flakeIdGeneratorService';\nProxyManager.PNCOUNTER_SERVICE = 'hz:impl:PNCounterService';\nProxyManager.RELIABLETOPIC_SERVICE = 'hz:impl:reliableTopicService';\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/ProxyManager.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/QueueProxy.js":
/*!***********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/QueueProxy.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueProxy = void 0;\nconst QueueAddAllCodec_1 = __webpack_require__(/*! ../codec/QueueAddAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueAddAllCodec.js\");\nconst QueueAddListenerCodec_1 = __webpack_require__(/*! ../codec/QueueAddListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueAddListenerCodec.js\");\nconst QueueClearCodec_1 = __webpack_require__(/*! ../codec/QueueClearCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueClearCodec.js\");\nconst QueueCompareAndRemoveAllCodec_1 = __webpack_require__(/*! ../codec/QueueCompareAndRemoveAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueCompareAndRemoveAllCodec.js\");\nconst QueueCompareAndRetainAllCodec_1 = __webpack_require__(/*! ../codec/QueueCompareAndRetainAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueCompareAndRetainAllCodec.js\");\nconst QueueContainsAllCodec_1 = __webpack_require__(/*! ../codec/QueueContainsAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueContainsAllCodec.js\");\nconst QueueContainsCodec_1 = __webpack_require__(/*! ../codec/QueueContainsCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueContainsCodec.js\");\nconst QueueDrainToCodec_1 = __webpack_require__(/*! ../codec/QueueDrainToCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueDrainToCodec.js\");\nconst QueueDrainToMaxSizeCodec_1 = __webpack_require__(/*! ../codec/QueueDrainToMaxSizeCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueDrainToMaxSizeCodec.js\");\nconst QueueIsEmptyCodec_1 = __webpack_require__(/*! ../codec/QueueIsEmptyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueIsEmptyCodec.js\");\nconst QueueIteratorCodec_1 = __webpack_require__(/*! ../codec/QueueIteratorCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueIteratorCodec.js\");\nconst QueueOfferCodec_1 = __webpack_require__(/*! ../codec/QueueOfferCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueOfferCodec.js\");\nconst QueuePeekCodec_1 = __webpack_require__(/*! ../codec/QueuePeekCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueuePeekCodec.js\");\nconst QueuePollCodec_1 = __webpack_require__(/*! ../codec/QueuePollCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueuePollCodec.js\");\nconst QueuePutCodec_1 = __webpack_require__(/*! ../codec/QueuePutCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueuePutCodec.js\");\nconst QueueRemainingCapacityCodec_1 = __webpack_require__(/*! ../codec/QueueRemainingCapacityCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueRemainingCapacityCodec.js\");\nconst QueueRemoveCodec_1 = __webpack_require__(/*! ../codec/QueueRemoveCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueRemoveCodec.js\");\nconst QueueRemoveListenerCodec_1 = __webpack_require__(/*! ../codec/QueueRemoveListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueRemoveListenerCodec.js\");\nconst QueueSizeCodec_1 = __webpack_require__(/*! ../codec/QueueSizeCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueSizeCodec.js\");\nconst QueueTakeCodec_1 = __webpack_require__(/*! ../codec/QueueTakeCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/QueueTakeCodec.js\");\nconst ItemListener_1 = __webpack_require__(/*! ./ItemListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/ItemListener.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst PartitionSpecificProxy_1 = __webpack_require__(/*! ./PartitionSpecificProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/PartitionSpecificProxy.js\");\n/** @internal */\nclass QueueProxy extends PartitionSpecificProxy_1.PartitionSpecificProxy {\n    add(item) {\n        return this.offer(item).then(function (ret) {\n            if (ret) {\n                return true;\n            }\n            else {\n                throw new core_1.IllegalStateError('Queue is full.');\n            }\n        });\n    }\n    addAll(items) {\n        const rawList = [];\n        const toData = this.toData.bind(this);\n        items.forEach(function (item) {\n            rawList.push(toData(item));\n        });\n        return this.encodeInvoke(QueueAddAllCodec_1.QueueAddAllCodec, rawList)\n            .then((clientMessage) => {\n            const response = QueueAddAllCodec_1.QueueAddAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    addItemListener(listener, includeValue) {\n        const handler = (message) => {\n            QueueAddListenerCodec_1.QueueAddListenerCodec.handle(message, (item, uuid, eventType) => {\n                let responseObject;\n                if (item == null) {\n                    responseObject = null;\n                }\n                else {\n                    responseObject = this.toObject(item);\n                }\n                const member = this.client.getClusterService().getMember(uuid);\n                const name = this.name;\n                const itemEvent = new ItemListener_1.ItemEvent(name, eventType, responseObject, member);\n                if (eventType === ItemListener_1.ItemEventType.ADDED && listener.itemAdded) {\n                    listener.itemAdded.apply(null, [itemEvent]);\n                }\n                else if (eventType === ItemListener_1.ItemEventType.REMOVED && listener.itemRemoved) {\n                    listener.itemRemoved.apply(null, [itemEvent]);\n                }\n            });\n        };\n        const codec = this.createEntryListener(this.name, includeValue);\n        return this.client.getListenerService().registerListener(codec, handler);\n    }\n    clear() {\n        return this.encodeInvoke(QueueClearCodec_1.QueueClearCodec).then();\n    }\n    contains(item) {\n        const itemData = this.toData(item);\n        return this.encodeInvoke(QueueContainsCodec_1.QueueContainsCodec, itemData)\n            .then((clientMessage) => {\n            const response = QueueContainsCodec_1.QueueContainsCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    containsAll(items) {\n        const toData = this.toData.bind(this);\n        const rawItems = items.map(toData);\n        return this.encodeInvoke(QueueContainsAllCodec_1.QueueContainsAllCodec, rawItems)\n            .then((clientMessage) => {\n            const response = QueueContainsAllCodec_1.QueueContainsAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    drainTo(arr, maxElements = null) {\n        const toObject = this.toObject.bind(this);\n        let promise;\n        if (maxElements === null) {\n            promise = this.encodeInvoke(QueueDrainToCodec_1.QueueDrainToCodec)\n                .then((clientMessage) => {\n                const response = QueueDrainToCodec_1.QueueDrainToCodec.decodeResponse(clientMessage);\n                return response.response;\n            });\n        }\n        else {\n            promise = this.encodeInvoke(QueueDrainToMaxSizeCodec_1.QueueDrainToMaxSizeCodec, maxElements)\n                .then((clientMessage) => {\n                const response = QueueDrainToMaxSizeCodec_1.QueueDrainToMaxSizeCodec.decodeResponse(clientMessage);\n                return response.response;\n            });\n        }\n        return promise.then(function (rawArr) {\n            rawArr.forEach(function (rawItem) {\n                arr.push(toObject(rawItem));\n            });\n            return rawArr.length;\n        });\n    }\n    isEmpty() {\n        return this.encodeInvoke(QueueIsEmptyCodec_1.QueueIsEmptyCodec)\n            .then((clientMessage) => {\n            const response = QueueIsEmptyCodec_1.QueueIsEmptyCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    offer(item, time = 0) {\n        const itemData = this.toData(item);\n        return this.encodeInvoke(QueueOfferCodec_1.QueueOfferCodec, itemData, time)\n            .then((clientMessage) => {\n            const response = QueueOfferCodec_1.QueueOfferCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    peek() {\n        return this.encodeInvoke(QueuePeekCodec_1.QueuePeekCodec)\n            .then((clientMessage) => {\n            const response = QueuePeekCodec_1.QueuePeekCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    poll(time = 0) {\n        return this.encodeInvoke(QueuePollCodec_1.QueuePollCodec, time)\n            .then((clientMessage) => {\n            const response = QueuePollCodec_1.QueuePollCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    put(item) {\n        const itemData = this.toData(item);\n        return this.encodeInvoke(QueuePutCodec_1.QueuePutCodec, itemData).then();\n    }\n    remainingCapacity() {\n        return this.encodeInvoke(QueueRemainingCapacityCodec_1.QueueRemainingCapacityCodec)\n            .then((clientMessage) => {\n            const response = QueueRemainingCapacityCodec_1.QueueRemainingCapacityCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    remove(item) {\n        const itemData = this.toData(item);\n        return this.encodeInvoke(QueueRemoveCodec_1.QueueRemoveCodec, itemData)\n            .then((clientMessage) => {\n            const response = QueueRemoveCodec_1.QueueRemoveCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    removeAll(items) {\n        const toData = this.toData.bind(this);\n        const rawItems = items.map(toData);\n        return this.encodeInvoke(QueueCompareAndRemoveAllCodec_1.QueueCompareAndRemoveAllCodec, rawItems)\n            .then((clientMessage) => {\n            const response = QueueCompareAndRemoveAllCodec_1.QueueCompareAndRemoveAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    removeItemListener(registrationId) {\n        return this.client.getListenerService().deregisterListener(registrationId);\n    }\n    retainAll(items) {\n        const toData = this.toData.bind(this);\n        const rawItems = items.map(toData);\n        return this.encodeInvoke(QueueCompareAndRetainAllCodec_1.QueueCompareAndRetainAllCodec, rawItems)\n            .then((clientMessage) => {\n            const response = QueueCompareAndRetainAllCodec_1.QueueCompareAndRetainAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    size() {\n        return this.encodeInvoke(QueueSizeCodec_1.QueueSizeCodec)\n            .then((clientMessage) => {\n            const response = QueueSizeCodec_1.QueueSizeCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    take() {\n        return this.encodeInvoke(QueueTakeCodec_1.QueueTakeCodec)\n            .then((clientMessage) => {\n            const response = QueueTakeCodec_1.QueueTakeCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    toArray() {\n        return this.encodeInvoke(QueueIteratorCodec_1.QueueIteratorCodec)\n            .then((clientMessage) => {\n            const response = QueueIteratorCodec_1.QueueIteratorCodec.decodeResponse(clientMessage);\n            return response.response.map(this.toObject.bind(this));\n        });\n    }\n    createEntryListener(name, includeValue) {\n        return {\n            encodeAddRequest(localOnly) {\n                return QueueAddListenerCodec_1.QueueAddListenerCodec.encodeRequest(name, includeValue, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return QueueAddListenerCodec_1.QueueAddListenerCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return QueueRemoveListenerCodec_1.QueueRemoveListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n}\nexports.QueueProxy = QueueProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/QueueProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/ReplicatedMap.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/ReplicatedMap.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/ReplicatedMap.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/ReplicatedMapProxy.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/ReplicatedMapProxy.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReplicatedMapProxy = void 0;\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst ReplicatedMapAddEntryListenerCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapAddEntryListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerCodec.js\");\nconst ReplicatedMapAddEntryListenerToKeyCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapAddEntryListenerToKeyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerToKeyCodec.js\");\n// eslint-disable-next-line max-len\nconst ReplicatedMapAddEntryListenerToKeyWithPredicateCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapAddEntryListenerToKeyWithPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.js\");\nconst ReplicatedMapAddEntryListenerWithPredicateCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapAddEntryListenerWithPredicateCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapAddEntryListenerWithPredicateCodec.js\");\nconst ReplicatedMapClearCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapClearCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapClearCodec.js\");\nconst ReplicatedMapContainsKeyCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapContainsKeyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapContainsKeyCodec.js\");\nconst ReplicatedMapContainsValueCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapContainsValueCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapContainsValueCodec.js\");\nconst ReplicatedMapEntrySetCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapEntrySetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapEntrySetCodec.js\");\nconst ReplicatedMapGetCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapGetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapGetCodec.js\");\nconst ReplicatedMapIsEmptyCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapIsEmptyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapIsEmptyCodec.js\");\nconst ReplicatedMapKeySetCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapKeySetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapKeySetCodec.js\");\nconst ReplicatedMapPutAllCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapPutAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapPutAllCodec.js\");\nconst ReplicatedMapPutCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapPutCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapPutCodec.js\");\nconst ReplicatedMapRemoveCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapRemoveCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapRemoveCodec.js\");\nconst ReplicatedMapRemoveEntryListenerCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapRemoveEntryListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapRemoveEntryListenerCodec.js\");\nconst ReplicatedMapSizeCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapSizeCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapSizeCodec.js\");\nconst ReplicatedMapValuesCodec_1 = __webpack_require__(/*! ../codec/ReplicatedMapValuesCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ReplicatedMapValuesCodec.js\");\nconst EventType_1 = __webpack_require__(/*! ./EventType */ \"../shared/node_modules/hazelcast-client/lib/proxy/EventType.js\");\nconst EntryListener_1 = __webpack_require__(/*! ./EntryListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/EntryListener.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst PartitionSpecificProxy_1 = __webpack_require__(/*! ./PartitionSpecificProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/PartitionSpecificProxy.js\");\nconst MapListener_1 = __webpack_require__(/*! ./MapListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/MapListener.js\");\nconst SerializationUtil_1 = __webpack_require__(/*! ../serialization/SerializationUtil */ \"../shared/node_modules/hazelcast-client/lib/serialization/SerializationUtil.js\");\nclass ReplicatedMapProxy extends PartitionSpecificProxy_1.PartitionSpecificProxy {\n    put(key, value, ttl = 0) {\n        Util_1.assertNotNull(key);\n        Util_1.assertNotNull(value);\n        const valueData = this.toData(value);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(ReplicatedMapPutCodec_1.ReplicatedMapPutCodec, keyData, keyData, valueData, ttl)\n            .then((clientMessage) => {\n            const response = ReplicatedMapPutCodec_1.ReplicatedMapPutCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    clear() {\n        return this.encodeInvokeOnRandomTarget(ReplicatedMapClearCodec_1.ReplicatedMapClearCodec).then();\n    }\n    get(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(ReplicatedMapGetCodec_1.ReplicatedMapGetCodec, keyData, keyData)\n            .then((clientMessage) => {\n            const response = ReplicatedMapGetCodec_1.ReplicatedMapGetCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    containsKey(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(ReplicatedMapContainsKeyCodec_1.ReplicatedMapContainsKeyCodec, keyData, keyData)\n            .then((clientMessage) => {\n            const response = ReplicatedMapContainsKeyCodec_1.ReplicatedMapContainsKeyCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    containsValue(value) {\n        Util_1.assertNotNull(value);\n        const valueData = this.toData(value);\n        return this.encodeInvoke(ReplicatedMapContainsValueCodec_1.ReplicatedMapContainsValueCodec, valueData)\n            .then((clientMessage) => {\n            const response = ReplicatedMapContainsValueCodec_1.ReplicatedMapContainsValueCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    size() {\n        return this.encodeInvoke(ReplicatedMapSizeCodec_1.ReplicatedMapSizeCodec)\n            .then((clientMessage) => {\n            const response = ReplicatedMapSizeCodec_1.ReplicatedMapSizeCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    isEmpty() {\n        return this.encodeInvoke(ReplicatedMapIsEmptyCodec_1.ReplicatedMapIsEmptyCodec)\n            .then((clientMessage) => {\n            const response = ReplicatedMapIsEmptyCodec_1.ReplicatedMapIsEmptyCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    remove(key) {\n        Util_1.assertNotNull(key);\n        const keyData = this.toData(key);\n        return this.encodeInvokeOnKey(ReplicatedMapRemoveCodec_1.ReplicatedMapRemoveCodec, keyData, keyData)\n            .then((clientMessage) => {\n            const response = ReplicatedMapRemoveCodec_1.ReplicatedMapRemoveCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    putAll(pairs) {\n        let pair;\n        let pairId;\n        const entries = [];\n        for (pairId in pairs) {\n            pair = pairs[pairId];\n            const keyData = this.toData(pair[0]);\n            const valueData = this.toData(pair[1]);\n            entries.push([keyData, valueData]);\n        }\n        return this.encodeInvokeOnRandomTarget(ReplicatedMapPutAllCodec_1.ReplicatedMapPutAllCodec, entries).then();\n    }\n    keySet() {\n        const toObject = this.toObject.bind(this);\n        return this.encodeInvoke(ReplicatedMapKeySetCodec_1.ReplicatedMapKeySetCodec)\n            .then((clientMessage) => {\n            const response = ReplicatedMapKeySetCodec_1.ReplicatedMapKeySetCodec.decodeResponse(clientMessage);\n            return response.response.map(toObject);\n        });\n    }\n    values(comparator) {\n        return this.encodeInvoke(ReplicatedMapValuesCodec_1.ReplicatedMapValuesCodec)\n            .then((clientMessage) => {\n            const response = ReplicatedMapValuesCodec_1.ReplicatedMapValuesCodec.decodeResponse(clientMessage);\n            const valuesData = response.response;\n            if (comparator) {\n                const desValues = valuesData.map(this.toObject.bind(this));\n                return new core_1.ReadOnlyLazyList(desValues.sort(comparator), this.client.getSerializationService());\n            }\n            return new core_1.ReadOnlyLazyList(valuesData, this.client.getSerializationService());\n        });\n    }\n    entrySet() {\n        return this.encodeInvoke(ReplicatedMapEntrySetCodec_1.ReplicatedMapEntrySetCodec)\n            .then((clientMessage) => {\n            const response = ReplicatedMapEntrySetCodec_1.ReplicatedMapEntrySetCodec.decodeResponse(clientMessage);\n            return SerializationUtil_1.deserializeEntryList(this.toObject.bind(this), response.response);\n        });\n    }\n    addEntryListenerToKeyWithPredicate(listener, key, predicate) {\n        return this.addEntryListenerInternal(listener, predicate, key);\n    }\n    addEntryListenerWithPredicate(listener, predicate) {\n        return this.addEntryListenerInternal(listener, predicate, undefined);\n    }\n    addEntryListenerToKey(listener, key) {\n        return this.addEntryListenerInternal(listener, undefined, key);\n    }\n    addEntryListener(listener) {\n        return this.addEntryListenerInternal(listener, undefined, undefined);\n    }\n    removeEntryListener(listenerId) {\n        return this.client.getListenerService().deregisterListener(listenerId);\n    }\n    addEntryListenerInternal(listener, predicate, key) {\n        const toObject = this.toObject.bind(this);\n        const entryEventHandler = (key, value, oldValue, mergingValue, event, uuid, numberOfAffectedEntries) => {\n            const member = this.client.getClusterService().getMember(uuid);\n            const name = this.name;\n            key = toObject(key);\n            value = toObject(value);\n            oldValue = toObject(oldValue);\n            mergingValue = toObject(mergingValue);\n            const entryEvent = new EntryListener_1.EntryEvent(name, key, value, oldValue, mergingValue, member);\n            const mapEvent = new MapListener_1.MapEvent(name, numberOfAffectedEntries, member);\n            const entryEventToListenerMap = {\n                [EventType_1.EventType.ADDED]: 'added',\n                [EventType_1.EventType.REMOVED]: 'removed',\n                [EventType_1.EventType.UPDATED]: 'updated',\n                [EventType_1.EventType.EVICTED]: 'evicted',\n            };\n            const mapEventToListenerMap = {\n                [EventType_1.EventType.CLEAR_ALL]: 'mapCleared',\n            };\n            const entryEventMethod = entryEventToListenerMap[event];\n            const mapEventMethod = mapEventToListenerMap[event];\n            if (listener.hasOwnProperty(entryEventMethod)) {\n                listener[entryEventMethod].apply(null, [entryEvent]);\n            }\n            else if (listener.hasOwnProperty(mapEventMethod)) {\n                listener[mapEventMethod].apply(null, [mapEvent]);\n            }\n        };\n        let listenerHandler;\n        let codec;\n        if (key && predicate) {\n            const keyData = this.toData(key);\n            const predicateData = this.toData(predicate);\n            codec = this.createEntryListenerToKeyWithPredicate(this.name, keyData, predicateData);\n            listenerHandler = ReplicatedMapAddEntryListenerToKeyWithPredicateCodec_1.ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.handle;\n        }\n        else if (key && !predicate) {\n            const keyData = this.toData(key);\n            codec = this.createEntryListenerToKey(this.name, keyData);\n            listenerHandler = ReplicatedMapAddEntryListenerToKeyCodec_1.ReplicatedMapAddEntryListenerToKeyCodec.handle;\n        }\n        else if (!key && predicate) {\n            const predicateData = this.toData(predicate);\n            codec = this.createEntryListenerWithPredicate(this.name, predicateData);\n            listenerHandler = ReplicatedMapAddEntryListenerWithPredicateCodec_1.ReplicatedMapAddEntryListenerWithPredicateCodec.handle;\n        }\n        else {\n            codec = this.createEntryListener(this.name);\n            listenerHandler = ReplicatedMapAddEntryListenerCodec_1.ReplicatedMapAddEntryListenerCodec.handle;\n        }\n        return this.client.getListenerService().registerListener(codec, (m) => {\n            listenerHandler(m, entryEventHandler, toObject);\n        });\n    }\n    createEntryListener(name) {\n        return {\n            encodeAddRequest(localOnly) {\n                return ReplicatedMapAddEntryListenerCodec_1.ReplicatedMapAddEntryListenerCodec.encodeRequest(name, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return ReplicatedMapAddEntryListenerCodec_1.ReplicatedMapAddEntryListenerCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return ReplicatedMapRemoveEntryListenerCodec_1.ReplicatedMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n    createEntryListenerToKey(name, keyData) {\n        return {\n            encodeAddRequest(localOnly) {\n                return ReplicatedMapAddEntryListenerToKeyCodec_1.ReplicatedMapAddEntryListenerToKeyCodec.encodeRequest(name, keyData, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return ReplicatedMapAddEntryListenerToKeyCodec_1.ReplicatedMapAddEntryListenerToKeyCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return ReplicatedMapRemoveEntryListenerCodec_1.ReplicatedMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n    createEntryListenerWithPredicate(name, predicateData) {\n        return {\n            encodeAddRequest(localOnly) {\n                return ReplicatedMapAddEntryListenerWithPredicateCodec_1.ReplicatedMapAddEntryListenerWithPredicateCodec.encodeRequest(name, predicateData, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return ReplicatedMapAddEntryListenerWithPredicateCodec_1.ReplicatedMapAddEntryListenerWithPredicateCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return ReplicatedMapRemoveEntryListenerCodec_1.ReplicatedMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n    createEntryListenerToKeyWithPredicate(name, keyData, predicateData) {\n        return {\n            encodeAddRequest(localOnly) {\n                return ReplicatedMapAddEntryListenerToKeyWithPredicateCodec_1.ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.encodeRequest(name, keyData, predicateData, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return ReplicatedMapAddEntryListenerToKeyWithPredicateCodec_1.ReplicatedMapAddEntryListenerToKeyWithPredicateCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return ReplicatedMapRemoveEntryListenerCodec_1.ReplicatedMapRemoveEntryListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n}\nexports.ReplicatedMapProxy = ReplicatedMapProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/ReplicatedMapProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/Ringbuffer.js":
/*!***********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/Ringbuffer.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/Ringbuffer.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/SetProxy.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/SetProxy.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetProxy = void 0;\nconst SetAddAllCodec_1 = __webpack_require__(/*! ../codec/SetAddAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetAddAllCodec.js\");\nconst SetAddCodec_1 = __webpack_require__(/*! ../codec/SetAddCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetAddCodec.js\");\nconst SetAddListenerCodec_1 = __webpack_require__(/*! ../codec/SetAddListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetAddListenerCodec.js\");\nconst SetClearCodec_1 = __webpack_require__(/*! ../codec/SetClearCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetClearCodec.js\");\nconst SetCompareAndRemoveAllCodec_1 = __webpack_require__(/*! ../codec/SetCompareAndRemoveAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetCompareAndRemoveAllCodec.js\");\nconst SetCompareAndRetainAllCodec_1 = __webpack_require__(/*! ../codec/SetCompareAndRetainAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetCompareAndRetainAllCodec.js\");\nconst SetContainsAllCodec_1 = __webpack_require__(/*! ../codec/SetContainsAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetContainsAllCodec.js\");\nconst SetContainsCodec_1 = __webpack_require__(/*! ../codec/SetContainsCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetContainsCodec.js\");\nconst SetGetAllCodec_1 = __webpack_require__(/*! ../codec/SetGetAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetGetAllCodec.js\");\nconst SetIsEmptyCodec_1 = __webpack_require__(/*! ../codec/SetIsEmptyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetIsEmptyCodec.js\");\nconst SetRemoveCodec_1 = __webpack_require__(/*! ../codec/SetRemoveCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetRemoveCodec.js\");\nconst SetRemoveListenerCodec_1 = __webpack_require__(/*! ../codec/SetRemoveListenerCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetRemoveListenerCodec.js\");\nconst SetSizeCodec_1 = __webpack_require__(/*! ../codec/SetSizeCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/SetSizeCodec.js\");\nconst ItemListener_1 = __webpack_require__(/*! ./ItemListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/ItemListener.js\");\nconst PartitionSpecificProxy_1 = __webpack_require__(/*! ./PartitionSpecificProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/PartitionSpecificProxy.js\");\n/** @internal */\nclass SetProxy extends PartitionSpecificProxy_1.PartitionSpecificProxy {\n    add(entry) {\n        return this.encodeInvoke(SetAddCodec_1.SetAddCodec, this.toData(entry))\n            .then((clientMessage) => {\n            const response = SetAddCodec_1.SetAddCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    addAll(items) {\n        return this.encodeInvoke(SetAddAllCodec_1.SetAddAllCodec, this.serializeList(items))\n            .then((clientMessage) => {\n            const response = SetAddAllCodec_1.SetAddAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    toArray() {\n        return this.encodeInvoke(SetGetAllCodec_1.SetGetAllCodec)\n            .then((clientMessage) => {\n            const response = SetGetAllCodec_1.SetGetAllCodec.decodeResponse(clientMessage);\n            return response.response.map(this.toObject.bind(this));\n        });\n    }\n    clear() {\n        return this.encodeInvoke(SetClearCodec_1.SetClearCodec).then();\n    }\n    contains(entry) {\n        return this.encodeInvoke(SetContainsCodec_1.SetContainsCodec, this.toData(entry))\n            .then((clientMessage) => {\n            const response = SetContainsCodec_1.SetContainsCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    containsAll(items) {\n        return this.encodeInvoke(SetContainsAllCodec_1.SetContainsAllCodec, this.serializeList(items))\n            .then((clientMessage) => {\n            const response = SetContainsAllCodec_1.SetContainsAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    isEmpty() {\n        return this.encodeInvoke(SetIsEmptyCodec_1.SetIsEmptyCodec)\n            .then((clientMessage) => {\n            const response = SetIsEmptyCodec_1.SetIsEmptyCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    remove(entry) {\n        return this.encodeInvoke(SetRemoveCodec_1.SetRemoveCodec, this.toData(entry))\n            .then((clientMessage) => {\n            const response = SetRemoveCodec_1.SetRemoveCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    removeAll(items) {\n        return this.encodeInvoke(SetCompareAndRemoveAllCodec_1.SetCompareAndRemoveAllCodec, this.serializeList(items))\n            .then((clientMessage) => {\n            const response = SetCompareAndRemoveAllCodec_1.SetCompareAndRemoveAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    retainAll(items) {\n        return this.encodeInvoke(SetCompareAndRetainAllCodec_1.SetCompareAndRetainAllCodec, this.serializeList(items))\n            .then((clientMessage) => {\n            const response = SetCompareAndRetainAllCodec_1.SetCompareAndRetainAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    size() {\n        return this.encodeInvoke(SetSizeCodec_1.SetSizeCodec)\n            .then((clientMessage) => {\n            const response = SetSizeCodec_1.SetSizeCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    addItemListener(listener, includeValue = true) {\n        const handler = (message) => {\n            SetAddListenerCodec_1.SetAddListenerCodec.handle(message, (item, uuid, eventType) => {\n                const responseObject = this.toObject(item);\n                const member = this.client.getClusterService().getMember(uuid);\n                const name = this.name;\n                const itemEvent = new ItemListener_1.ItemEvent(name, eventType, responseObject, member);\n                if (eventType === ItemListener_1.ItemEventType.ADDED && listener.itemAdded) {\n                    listener.itemAdded.apply(null, [itemEvent]);\n                }\n                else if (eventType === ItemListener_1.ItemEventType.REMOVED && listener.itemRemoved) {\n                    listener.itemRemoved.apply(null, [itemEvent]);\n                }\n            });\n        };\n        const codec = this.createEntryListener(this.name, includeValue);\n        return this.client.getListenerService().registerListener(codec, handler);\n    }\n    removeItemListener(registrationId) {\n        return this.client.getListenerService().deregisterListener(registrationId);\n    }\n    serializeList(input) {\n        return input.map((each) => {\n            return this.toData(each);\n        });\n    }\n    createEntryListener(name, includeValue) {\n        return {\n            encodeAddRequest(localOnly) {\n                return SetAddListenerCodec_1.SetAddListenerCodec.encodeRequest(name, includeValue, localOnly);\n            },\n            decodeAddResponse(msg) {\n                return SetAddListenerCodec_1.SetAddListenerCodec.decodeResponse(msg).response;\n            },\n            encodeRemoveRequest(listenerId) {\n                return SetRemoveListenerCodec_1.SetRemoveListenerCodec.encodeRequest(name, listenerId);\n            },\n        };\n    }\n}\nexports.SetProxy = SetProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/SetProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/TopicOverloadPolicy.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/TopicOverloadPolicy.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TopicOverloadPolicy = void 0;\n/**\n * Overload policy for Reliable Topic.\n */\nvar TopicOverloadPolicy;\n(function (TopicOverloadPolicy) {\n    /**\n     * Using this policy, a message that has not expired can be overwritten.\n     * No matter the retention period set, the overwrite will just overwrite the item.\n     *\n     * This can be a problem for slow consumers because they were promised a certain time window to process messages.\n     * But it will benefit producers and fast consumers since they are able to continue.\n     * This policy sacrifices the slow producer in favor of fast producers/consumers.\n     */\n    TopicOverloadPolicy[\"DISCARD_OLDEST\"] = \"DISCARD_OLDEST\";\n    /**\n     * The message that was to be published, is discarded.\n     */\n    TopicOverloadPolicy[\"DISCARD_NEWEST\"] = \"DISCARD_NEWEST\";\n    /**\n     * The caller will wait till there space in the ringbuffer.\n     */\n    TopicOverloadPolicy[\"BLOCK\"] = \"BLOCK\";\n    /**\n     * The publish call immediately fails.\n     */\n    TopicOverloadPolicy[\"ERROR\"] = \"ERROR\";\n})(TopicOverloadPolicy = exports.TopicOverloadPolicy || (exports.TopicOverloadPolicy = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/TopicOverloadPolicy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/VectorClock.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/VectorClock.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorClock = void 0;\n/** @internal */\nclass VectorClock {\n    constructor() {\n        this.replicaTimestamps = new Map();\n    }\n    isAfter(other) {\n        let atLeastOneBigger = false;\n        other.replicaTimestamps.forEach((otherTimestamp, replicaId) => {\n            const thisTimetamp = this.replicaTimestamps.get(replicaId);\n            if (thisTimetamp == null || otherTimestamp.greaterThan(thisTimetamp)) {\n                return false;\n            }\n            else if (otherTimestamp.lessThan(thisTimetamp)) {\n                atLeastOneBigger = true;\n            }\n        });\n        return atLeastOneBigger || this.replicaTimestamps.size > other.replicaTimestamps.size;\n    }\n    setReplicaTimestamp(replicaId, timestamp) {\n        this.replicaTimestamps.set(replicaId, timestamp);\n    }\n    entrySet() {\n        const entrySet = [];\n        this.replicaTimestamps.forEach((timestamp, replicaId) => {\n            entrySet.push([replicaId, timestamp]);\n        });\n        return entrySet;\n    }\n}\nexports.VectorClock = VectorClock;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/VectorClock.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/AtomicLongProxy.js":
/*!****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/AtomicLongProxy.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AtomicLongProxy = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst BaseCPProxy_1 = __webpack_require__(/*! ./BaseCPProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/BaseCPProxy.js\");\nconst CPProxyManager_1 = __webpack_require__(/*! ./CPProxyManager */ \"../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/CPProxyManager.js\");\nconst CPGroupDestroyCPObjectCodec_1 = __webpack_require__(/*! ../../codec/CPGroupDestroyCPObjectCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/CPGroupDestroyCPObjectCodec.js\");\nconst AtomicLongAddAndGetCodec_1 = __webpack_require__(/*! ../../codec/AtomicLongAddAndGetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/AtomicLongAddAndGetCodec.js\");\nconst AtomicLongCompareAndSetCodec_1 = __webpack_require__(/*! ../../codec/AtomicLongCompareAndSetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/AtomicLongCompareAndSetCodec.js\");\nconst AtomicLongGetCodec_1 = __webpack_require__(/*! ../../codec/AtomicLongGetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetCodec.js\");\nconst AtomicLongGetAndAddCodec_1 = __webpack_require__(/*! ../../codec/AtomicLongGetAndAddCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetAndAddCodec.js\");\nconst AtomicLongGetAndSetCodec_1 = __webpack_require__(/*! ../../codec/AtomicLongGetAndSetCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/AtomicLongGetAndSetCodec.js\");\n/** @internal */\nclass AtomicLongProxy extends BaseCPProxy_1.BaseCPProxy {\n    constructor(client, groupId, proxyName, objectName) {\n        super(client, CPProxyManager_1.CPProxyManager.ATOMIC_LONG_SERVICE, proxyName);\n        this.groupId = groupId;\n        this.objectName = objectName;\n    }\n    destroy() {\n        return this.encodeInvokeOnRandomTarget(CPGroupDestroyCPObjectCodec_1.CPGroupDestroyCPObjectCodec, this.groupId, this.serviceName, this.objectName).then();\n    }\n    addAndGet(delta) {\n        if (!Long.isLong(delta)) {\n            delta = Long.fromNumber(delta);\n        }\n        return this.encodeInvokeOnRandomTarget(AtomicLongAddAndGetCodec_1.AtomicLongAddAndGetCodec, this.groupId, this.objectName, delta)\n            .then((clientMessage) => {\n            const response = AtomicLongAddAndGetCodec_1.AtomicLongAddAndGetCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    compareAndSet(expect, update) {\n        if (!Long.isLong(expect)) {\n            expect = Long.fromNumber(expect);\n        }\n        if (!Long.isLong(update)) {\n            update = Long.fromNumber(update);\n        }\n        return this.encodeInvokeOnRandomTarget(AtomicLongCompareAndSetCodec_1.AtomicLongCompareAndSetCodec, this.groupId, this.objectName, expect, update)\n            .then((clientMessage) => {\n            const response = AtomicLongCompareAndSetCodec_1.AtomicLongCompareAndSetCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    decrementAndGet() {\n        return this.addAndGet(-1);\n    }\n    get() {\n        return this.encodeInvokeOnRandomTarget(AtomicLongGetCodec_1.AtomicLongGetCodec, this.groupId, this.objectName)\n            .then((clientMessage) => {\n            const response = AtomicLongGetCodec_1.AtomicLongGetCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    getAndAdd(delta) {\n        if (!Long.isLong(delta)) {\n            delta = Long.fromNumber(delta);\n        }\n        return this.encodeInvokeOnRandomTarget(AtomicLongGetAndAddCodec_1.AtomicLongGetAndAddCodec, this.groupId, this.objectName, delta)\n            .then((clientMessage) => {\n            const response = AtomicLongGetAndAddCodec_1.AtomicLongGetAndAddCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    getAndSet(newValue) {\n        if (!Long.isLong(newValue)) {\n            newValue = Long.fromNumber(newValue);\n        }\n        return this.encodeInvokeOnRandomTarget(AtomicLongGetAndSetCodec_1.AtomicLongGetAndSetCodec, this.groupId, this.objectName, newValue)\n            .then((clientMessage) => {\n            const response = AtomicLongGetAndSetCodec_1.AtomicLongGetAndSetCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    incrementAndGet() {\n        return this.addAndGet(1);\n    }\n    getAndIncrement() {\n        return this.getAndAdd(1);\n    }\n    set(newValue) {\n        return this.getAndSet(newValue).then();\n    }\n}\nexports.AtomicLongProxy = AtomicLongProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/AtomicLongProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/BaseCPProxy.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/BaseCPProxy.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseCPProxy = void 0;\nconst core_1 = __webpack_require__(/*! ../../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\n/**\n * Common super class for any CP Subsystem proxy.\n * @internal\n */\nclass BaseCPProxy {\n    constructor(client, serviceName, proxyName) {\n        this.client = client;\n        this.proxyName = proxyName;\n        this.serviceName = serviceName;\n    }\n    getPartitionKey() {\n        throw new core_1.UnsupportedOperationError('This operation is not supported by CP Subsystem');\n    }\n    getName() {\n        return this.proxyName;\n    }\n    getServiceName() {\n        return this.serviceName;\n    }\n    /**\n     * Encodes a request from a codec and invokes it on any node.\n     * @param codec\n     * @param codecArguments\n     * @returns response message\n     */\n    encodeInvokeOnRandomTarget(codec, ...codecArguments) {\n        const clientMessage = codec.encodeRequest(...codecArguments);\n        return this.client.getInvocationService().invokeOnRandomTarget(clientMessage);\n    }\n}\nexports.BaseCPProxy = BaseCPProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/BaseCPProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/CPProxyManager.js":
/*!***************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/CPProxyManager.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CPProxyManager = exports.getObjectNameForProxy = exports.withoutDefaultGroupName = void 0;\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst core_1 = __webpack_require__(/*! ../../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst AtomicLongProxy_1 = __webpack_require__(/*! ./AtomicLongProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/AtomicLongProxy.js\");\nconst CPGroupCreateCPGroupCodec_1 = __webpack_require__(/*! ../../codec/CPGroupCreateCPGroupCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/CPGroupCreateCPGroupCodec.js\");\nconst Util_1 = __webpack_require__(/*! ../../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst DEFAULT_GROUP_NAME = 'default';\n/** @internal */\nfunction withoutDefaultGroupName(name) {\n    Util_1.assertString(name);\n    name = name.trim();\n    const i = name.indexOf('@');\n    if (i === -1) {\n        return name;\n    }\n    assert(name.indexOf('@', i + 1) === -1, 'Custom group name must be specified at most once');\n    const groupName = name.slice(i + 1).trim();\n    if (groupName === DEFAULT_GROUP_NAME) {\n        return name.slice(0, i);\n    }\n    return name;\n}\nexports.withoutDefaultGroupName = withoutDefaultGroupName;\n/** @internal */\nfunction getObjectNameForProxy(name) {\n    Util_1.assertString(name);\n    const i = name.indexOf('@');\n    if (i === -1) {\n        return name;\n    }\n    assert(i < (name.length - 1), 'Custom CP group name cannot be empty string');\n    const objectName = name.slice(0, i).trim();\n    assert(objectName.length > 0, 'Object name cannot be empty string');\n    return objectName;\n}\nexports.getObjectNameForProxy = getObjectNameForProxy;\n/** @internal */\nclass CPProxyManager {\n    constructor(client) {\n        this.client = client;\n    }\n    getOrCreateProxy(proxyName, serviceName) {\n        proxyName = withoutDefaultGroupName(proxyName);\n        const objectName = getObjectNameForProxy(proxyName);\n        return this.getGroupId(proxyName).then((groupId) => {\n            if (serviceName === CPProxyManager.ATOMIC_LONG_SERVICE) {\n                return new AtomicLongProxy_1.AtomicLongProxy(this.client, groupId, proxyName, objectName);\n            }\n            throw new core_1.IllegalStateError('Unexpected service name: ' + serviceName);\n        });\n    }\n    getGroupId(proxyName) {\n        const clientMessage = CPGroupCreateCPGroupCodec_1.CPGroupCreateCPGroupCodec.encodeRequest(proxyName);\n        return this.client.getInvocationService().invokeOnRandomTarget(clientMessage)\n            .then((clientMessage) => {\n            const response = CPGroupCreateCPGroupCodec_1.CPGroupCreateCPGroupCodec.decodeResponse(clientMessage);\n            return response.groupId;\n        });\n    }\n}\nexports.CPProxyManager = CPProxyManager;\nCPProxyManager.ATOMIC_LONG_SERVICE = 'hz:raft:atomicLongService';\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/CPProxyManager.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/RaftGroupId.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/RaftGroupId.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RaftGroupId = void 0;\n/** @internal */\nclass RaftGroupId {\n    constructor(name, seed, id) {\n        this.name = name;\n        this.seed = seed;\n        this.id = id;\n    }\n}\nexports.RaftGroupId = RaftGroupId;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/cpsubsystem/RaftGroupId.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/flakeid/AutoBatcher.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/flakeid/AutoBatcher.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AutoBatcher = exports.Batch = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst Util_1 = __webpack_require__(/*! ../../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\n/** @internal */\nclass Batch {\n    constructor(validityMillis, base, increment, batchSize) {\n        this.nextIdLong = base;\n        this.increment = increment;\n        this.firstInvalidId = base.add(this.increment.multiply(batchSize));\n        if (validityMillis > 0) {\n            this.invalidSince = validityMillis + Date.now();\n        }\n        else {\n            this.invalidSince = Number.MAX_SAFE_INTEGER;\n        }\n    }\n    /**\n     * @returns next id from the batch,\n     *          undefined if ids are exhausted or not valid anymore\n     */\n    nextId() {\n        if (this.invalidSince <= Date.now()) {\n            return undefined;\n        }\n        if (this.firstInvalidId.equals(this.nextIdLong)) {\n            return undefined;\n        }\n        const returnLong = this.nextIdLong;\n        this.nextIdLong = this.nextIdLong.add(this.increment);\n        return returnLong;\n    }\n}\nexports.Batch = Batch;\n/** @internal */\nclass AutoBatcher {\n    constructor(supplier) {\n        this.queue = [];\n        this.requestInFlight = false;\n        this.emitter = new events_1.EventEmitter();\n        this.supplier = supplier;\n        this.emitter.on(AutoBatcher.NEW_BATCH_AVAILABLE, this.processIdRequests.bind(this));\n        this.emitter.on('error', this.rejectAll.bind(this));\n    }\n    processIdRequests() {\n        let ind = 0;\n        while (ind < this.queue.length) {\n            let nextId;\n            if (this.batch != null && (nextId = this.batch.nextId()) != null) {\n                this.queue[ind].resolve(nextId);\n                ind++;\n            }\n            else {\n                this.assignNewBatch();\n                break;\n            }\n        }\n        this.queue.splice(0, ind);\n    }\n    nextId() {\n        const deferred = Util_1.DeferredPromise();\n        this.queue.push(deferred);\n        this.processIdRequests();\n        return deferred.promise;\n    }\n    assignNewBatch() {\n        if (this.requestInFlight) {\n            return;\n        }\n        this.requestInFlight = true;\n        this.supplier().then((batch) => {\n            this.requestInFlight = false;\n            this.batch = batch;\n            this.emitter.emit(AutoBatcher.NEW_BATCH_AVAILABLE);\n        }).catch((e) => {\n            this.requestInFlight = false;\n            this.emitter.emit('error', e);\n        });\n    }\n    rejectAll(e) {\n        this.queue.forEach((deferred) => {\n            deferred.reject(e);\n        });\n        this.queue = [];\n    }\n}\nexports.AutoBatcher = AutoBatcher;\nAutoBatcher.NEW_BATCH_AVAILABLE = 'newBatch';\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/flakeid/AutoBatcher.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/flakeid/FlakeIdGeneratorProxy.js":
/*!******************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/flakeid/FlakeIdGeneratorProxy.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlakeIdGeneratorProxy = void 0;\nconst FlakeIdGeneratorNewIdBatchCodec_1 = __webpack_require__(/*! ../../codec/FlakeIdGeneratorNewIdBatchCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/FlakeIdGeneratorNewIdBatchCodec.js\");\nconst BaseProxy_1 = __webpack_require__(/*! ../BaseProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/BaseProxy.js\");\nconst AutoBatcher_1 = __webpack_require__(/*! ./AutoBatcher */ \"../shared/node_modules/hazelcast-client/lib/proxy/flakeid/AutoBatcher.js\");\n/** @internal */\nclass FlakeIdGeneratorProxy extends BaseProxy_1.BaseProxy {\n    constructor(client, serviceName, name) {\n        super(client, serviceName, name);\n        this.config = client.getConfig().getFlakeIdGeneratorConfig(name);\n        this.autoBatcher = new AutoBatcher_1.AutoBatcher(() => {\n            return this.encodeInvokeOnRandomTarget(FlakeIdGeneratorNewIdBatchCodec_1.FlakeIdGeneratorNewIdBatchCodec, this.config.prefetchCount)\n                .then((clientMessage) => {\n                const response = FlakeIdGeneratorNewIdBatchCodec_1.FlakeIdGeneratorNewIdBatchCodec.decodeResponse(clientMessage);\n                return new AutoBatcher_1.Batch(this.config.prefetchValidityMillis, response.base, response.increment, response.batchSize);\n            });\n        });\n    }\n    newId() {\n        return this.autoBatcher.nextId();\n    }\n}\nexports.FlakeIdGeneratorProxy = FlakeIdGeneratorProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/flakeid/FlakeIdGeneratorProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/index.js":
/*!******************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Public API re-exports.\n */\n__exportStar(__webpack_require__(/*! ./EntryListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/EntryListener.js\"), exports);\n__exportStar(__webpack_require__(/*! ./FlakeIdGenerator */ \"../shared/node_modules/hazelcast-client/lib/proxy/FlakeIdGenerator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IList */ \"../shared/node_modules/hazelcast-client/lib/proxy/IList.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IMap */ \"../shared/node_modules/hazelcast-client/lib/proxy/IMap.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IQueue */ \"../shared/node_modules/hazelcast-client/lib/proxy/IQueue.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ISet */ \"../shared/node_modules/hazelcast-client/lib/proxy/ISet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ItemListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/ItemListener.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ITopic */ \"../shared/node_modules/hazelcast-client/lib/proxy/ITopic.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MapListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/MapListener.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MultiMap */ \"../shared/node_modules/hazelcast-client/lib/proxy/MultiMap.js\"), exports);\n__exportStar(__webpack_require__(/*! ./OverflowPolicy */ \"../shared/node_modules/hazelcast-client/lib/proxy/OverflowPolicy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./PNCounter */ \"../shared/node_modules/hazelcast-client/lib/proxy/PNCounter.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ReplicatedMap */ \"../shared/node_modules/hazelcast-client/lib/proxy/ReplicatedMap.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Ringbuffer */ \"../shared/node_modules/hazelcast-client/lib/proxy/Ringbuffer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MessageListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/MessageListener.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TopicOverloadPolicy */ \"../shared/node_modules/hazelcast-client/lib/proxy/TopicOverloadPolicy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IAtomicLong */ \"../shared/node_modules/hazelcast-client/lib/proxy/IAtomicLong.js\"), exports);\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/index.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/ringbuffer/LazyReadResultSet.js":
/*!*****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/ringbuffer/LazyReadResultSet.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LazyReadResultSet = void 0;\n/** @internal */\nclass LazyReadResultSet {\n    constructor(serializationService, readCount, items, itemSeqs, nextSeq) {\n        this.serializationService = serializationService;\n        this.readCount = readCount;\n        this.items = items;\n        this.itemSeqs = itemSeqs;\n        this.nextSeq = nextSeq;\n    }\n    getReadCount() {\n        return this.readCount;\n    }\n    get(index) {\n        const dataOrObject = this.items[index];\n        if (dataOrObject == null) {\n            return undefined;\n        }\n        if (this.serializationService.isData(dataOrObject)) {\n            const obj = this.serializationService.toObject(dataOrObject);\n            this.items[index] = obj;\n            return obj;\n        }\n        else {\n            return dataOrObject;\n        }\n    }\n    getSequence(index) {\n        return this.itemSeqs[index];\n    }\n    size() {\n        return this.items.length;\n    }\n    getNextSequenceToReadFrom() {\n        return this.nextSeq;\n    }\n}\nexports.LazyReadResultSet = LazyReadResultSet;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/ringbuffer/LazyReadResultSet.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/ringbuffer/RingbufferProxy.js":
/*!***************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/ringbuffer/RingbufferProxy.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RingbufferProxy = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst RingbufferAddAllCodec_1 = __webpack_require__(/*! ../../codec/RingbufferAddAllCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/RingbufferAddAllCodec.js\");\nconst RingbufferAddCodec_1 = __webpack_require__(/*! ../../codec/RingbufferAddCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/RingbufferAddCodec.js\");\nconst RingbufferCapacityCodec_1 = __webpack_require__(/*! ../../codec/RingbufferCapacityCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/RingbufferCapacityCodec.js\");\nconst RingbufferHeadSequenceCodec_1 = __webpack_require__(/*! ../../codec/RingbufferHeadSequenceCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/RingbufferHeadSequenceCodec.js\");\nconst RingbufferReadManyCodec_1 = __webpack_require__(/*! ../../codec/RingbufferReadManyCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/RingbufferReadManyCodec.js\");\nconst RingbufferReadOneCodec_1 = __webpack_require__(/*! ../../codec/RingbufferReadOneCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/RingbufferReadOneCodec.js\");\nconst RingbufferRemainingCapacityCodec_1 = __webpack_require__(/*! ../../codec/RingbufferRemainingCapacityCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/RingbufferRemainingCapacityCodec.js\");\nconst RingbufferSizeCodec_1 = __webpack_require__(/*! ../../codec/RingbufferSizeCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/RingbufferSizeCodec.js\");\nconst RingbufferTailSequenceCodec_1 = __webpack_require__(/*! ../../codec/RingbufferTailSequenceCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/RingbufferTailSequenceCodec.js\");\nconst OverflowPolicy_1 = __webpack_require__(/*! ../OverflowPolicy */ \"../shared/node_modules/hazelcast-client/lib/proxy/OverflowPolicy.js\");\nconst PartitionSpecificProxy_1 = __webpack_require__(/*! ../PartitionSpecificProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/PartitionSpecificProxy.js\");\nconst LazyReadResultSet_1 = __webpack_require__(/*! ./LazyReadResultSet */ \"../shared/node_modules/hazelcast-client/lib/proxy/ringbuffer/LazyReadResultSet.js\");\n/** @internal */\nclass RingbufferProxy extends PartitionSpecificProxy_1.PartitionSpecificProxy {\n    capacity() {\n        return this.encodeInvoke(RingbufferCapacityCodec_1.RingbufferCapacityCodec)\n            .then((clientMessage) => {\n            const response = RingbufferCapacityCodec_1.RingbufferCapacityCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    size() {\n        return this.encodeInvoke(RingbufferSizeCodec_1.RingbufferSizeCodec)\n            .then((clientMessage) => {\n            const response = RingbufferSizeCodec_1.RingbufferSizeCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    tailSequence() {\n        return this.encodeInvoke(RingbufferTailSequenceCodec_1.RingbufferTailSequenceCodec)\n            .then((clientMessage) => {\n            const response = RingbufferTailSequenceCodec_1.RingbufferTailSequenceCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    headSequence() {\n        return this.encodeInvoke(RingbufferHeadSequenceCodec_1.RingbufferHeadSequenceCodec)\n            .then((clientMessage) => {\n            const response = RingbufferHeadSequenceCodec_1.RingbufferHeadSequenceCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    remainingCapacity() {\n        return this.encodeInvoke(RingbufferRemainingCapacityCodec_1.RingbufferRemainingCapacityCodec)\n            .then((clientMessage) => {\n            const response = RingbufferRemainingCapacityCodec_1.RingbufferRemainingCapacityCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    add(item, overflowPolicy = OverflowPolicy_1.OverflowPolicy.OVERWRITE) {\n        const policyId = OverflowPolicy_1.overflowPolicyToId(overflowPolicy);\n        return this.encodeInvoke(RingbufferAddCodec_1.RingbufferAddCodec, policyId, this.toData(item))\n            .then((clientMessage) => {\n            const response = RingbufferAddCodec_1.RingbufferAddCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    addAll(items, overflowPolicy = OverflowPolicy_1.OverflowPolicy.OVERWRITE) {\n        const policyId = OverflowPolicy_1.overflowPolicyToId(overflowPolicy);\n        const dataList = items.map(this.toData.bind(this));\n        return this.encodeInvoke(RingbufferAddAllCodec_1.RingbufferAddAllCodec, dataList, policyId)\n            .then((clientMessage) => {\n            const response = RingbufferAddAllCodec_1.RingbufferAddAllCodec.decodeResponse(clientMessage);\n            return response.response;\n        });\n    }\n    readOne(sequence) {\n        if (Long.fromValue(sequence).lessThan(0)) {\n            throw new RangeError('Sequence number should not be less than zero, was: ' + sequence);\n        }\n        return this.encodeInvoke(RingbufferReadOneCodec_1.RingbufferReadOneCodec, sequence)\n            .then((clientMessage) => {\n            const response = RingbufferReadOneCodec_1.RingbufferReadOneCodec.decodeResponse(clientMessage);\n            return this.toObject(response.response);\n        });\n    }\n    readMany(startSequence, minCount, maxCount, filter = null) {\n        if (Long.fromValue(startSequence).lessThan(0)) {\n            throw new RangeError('Sequence number should not be less than zero, was: ' + startSequence);\n        }\n        if (minCount < 0) {\n            throw new RangeError('Min count should not be less than zero, was: ' + startSequence);\n        }\n        if (minCount > maxCount) {\n            throw new RangeError('Min count ' + minCount + ' was larger than max count ' + maxCount);\n        }\n        if (maxCount > RingbufferProxy.MAX_BATCH_SIZE) {\n            throw new RangeError('Max count can not be larger than ' + RingbufferProxy.MAX_BATCH_SIZE);\n        }\n        return this.encodeInvoke(RingbufferReadManyCodec_1.RingbufferReadManyCodec, startSequence, minCount, maxCount, this.toData(filter))\n            .then((clientMessage) => {\n            const response = RingbufferReadManyCodec_1.RingbufferReadManyCodec.decodeResponse(clientMessage);\n            return new LazyReadResultSet_1.LazyReadResultSet(this.client.getSerializationService(), response.readCount, response.items, response.itemSeqs, response.nextSeq);\n        });\n    }\n}\nexports.RingbufferProxy = RingbufferProxy;\nRingbufferProxy.MAX_BATCH_SIZE = 1000;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/ringbuffer/RingbufferProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicListenerRunner.js":
/*!**********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicListenerRunner.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReliableTopicListenerRunner = void 0;\nconst core_1 = __webpack_require__(/*! ../../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst MessageListener_1 = __webpack_require__(/*! ../MessageListener */ \"../shared/node_modules/hazelcast-client/lib/proxy/MessageListener.js\");\n/** @internal */\nclass ReliableTopicListenerRunner {\n    constructor(listenerId, listener, ringbuffer, batchSize, serializationService, logger, proxy) {\n        this.sequenceNumber = 0;\n        this.cancelled = false;\n        this.listenerId = listenerId;\n        this.listener = listener;\n        this.ringbuffer = ringbuffer;\n        this.batchSize = batchSize;\n        this.serializationService = serializationService;\n        this.proxy = proxy;\n        this.logger = logger;\n    }\n    next() {\n        if (this.cancelled) {\n            return;\n        }\n        this.ringbuffer.readMany(this.sequenceNumber, 1, this.batchSize)\n            .then((result) => {\n            if (this.cancelled) {\n                return;\n            }\n            const nextSeq = result.getNextSequenceToReadFrom().toNumber();\n            const lostCount = nextSeq - result.getReadCount() - this.sequenceNumber;\n            // If messages were lost, behave as a loss tolerant listener\n            if (lostCount !== 0) {\n                this.logger.warn('ReliableTopicListenerRunner', 'Listener of topic: '\n                    + this.proxy.getName() + ' lost ' + lostCount + ' messages.');\n            }\n            for (let i = 0; i < result.size(); i++) {\n                const msg = new MessageListener_1.Message();\n                const item = result.get(i);\n                msg.messageObject = this.serializationService.toObject(item.payload);\n                msg.publisher = item.publisherAddress;\n                msg.publishingTime = item.publishTime;\n                process.nextTick(this.listener, msg);\n            }\n            this.sequenceNumber = nextSeq;\n            this.next();\n        })\n            .catch((err) => {\n            if (this.handleInternalError(err)) {\n                this.next();\n            }\n            else {\n                this.proxy.removeMessageListener(this.listenerId);\n            }\n        });\n    }\n    cancel() {\n        this.cancelled = true;\n    }\n    handleInternalError(err) {\n        if (err instanceof core_1.InvocationTimeoutError) {\n            this.logger.trace('ReliableTopicListenerRunner', 'Listener of topic: ' + this.proxy.getName()\n                + ' timed out. Continuing from last known sequence: ' + this.sequenceNumber);\n            return true;\n        }\n        else if (err instanceof core_1.ClientOfflineError) {\n            this.logger.trace('ReliableTopicListenerRunner', 'Listener of topic: ' + this.proxy.getName()\n                + ' got error: ' + err + '. Continuing from last known sequence: ' + this.sequenceNumber);\n            return true;\n        }\n        else if (err instanceof core_1.ClientNotActiveError) {\n            this.logger.trace('ReliableTopicListenerRunner', 'Terminating listener of topic: '\n                + this.proxy.getName() + '. Reason: HazelcastClient is shutting down.');\n            return false;\n        }\n        else {\n            this.logger.warn('ReliableTopicListenerRunner', 'Listener of topic: ' + this.proxy.getName()\n                + ' caught an exception, terminating listener. ' + err);\n        }\n        return false;\n    }\n}\nexports.ReliableTopicListenerRunner = ReliableTopicListenerRunner;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicListenerRunner.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicMessage.js":
/*!***************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicMessage.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reliableTopicMessageFactory = exports.ReliableTopicMessage = exports.RELIABLE_TOPIC_CLASS_ID = exports.RELIABLE_TOPIC_MESSAGE_FACTORY_ID = void 0;\n/** @internal */\nexports.RELIABLE_TOPIC_MESSAGE_FACTORY_ID = -9;\n/** @internal */\nexports.RELIABLE_TOPIC_CLASS_ID = 2;\n/** @internal */\nclass ReliableTopicMessage {\n    constructor() {\n        this.factoryId = exports.RELIABLE_TOPIC_MESSAGE_FACTORY_ID;\n        this.classId = exports.RELIABLE_TOPIC_CLASS_ID;\n    }\n    readData(input) {\n        this.publishTime = input.readLong();\n        this.publisherAddress = input.readObject();\n        this.payload = input.readData();\n    }\n    writeData(output) {\n        output.writeLong(this.publishTime);\n        output.writeObject(this.publisherAddress);\n        output.writeData(this.payload);\n    }\n}\nexports.ReliableTopicMessage = ReliableTopicMessage;\n/** @internal */\nfunction reliableTopicMessageFactory(classId) {\n    if (classId === exports.RELIABLE_TOPIC_CLASS_ID) {\n        return new ReliableTopicMessage();\n    }\n    return null;\n}\nexports.reliableTopicMessageFactory = reliableTopicMessageFactory;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicMessage.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicProxy.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicProxy.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReliableTopicProxy = exports.TOPIC_MAX_BACKOFF = exports.TOPIC_INITIAL_BACKOFF = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst OverflowPolicy_1 = __webpack_require__(/*! ../OverflowPolicy */ \"../shared/node_modules/hazelcast-client/lib/proxy/OverflowPolicy.js\");\nconst core_1 = __webpack_require__(/*! ../../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst UuidUtil_1 = __webpack_require__(/*! ../../util/UuidUtil */ \"../shared/node_modules/hazelcast-client/lib/util/UuidUtil.js\");\nconst Util_1 = __webpack_require__(/*! ../../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst BaseProxy_1 = __webpack_require__(/*! ../BaseProxy */ \"../shared/node_modules/hazelcast-client/lib/proxy/BaseProxy.js\");\nconst ReliableTopicMessage_1 = __webpack_require__(/*! ./ReliableTopicMessage */ \"../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicMessage.js\");\nconst ReliableTopicListenerRunner_1 = __webpack_require__(/*! ./ReliableTopicListenerRunner */ \"../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicListenerRunner.js\");\nconst TopicOverloadPolicy_1 = __webpack_require__(/*! ../TopicOverloadPolicy */ \"../shared/node_modules/hazelcast-client/lib/proxy/TopicOverloadPolicy.js\");\n/** @internal */\nexports.TOPIC_INITIAL_BACKOFF = 100;\n/** @internal */\nexports.TOPIC_MAX_BACKOFF = 2000;\n/** @internal */\nclass ReliableTopicProxy extends BaseProxy_1.BaseProxy {\n    constructor(client, serviceName, name) {\n        super(client, serviceName, name);\n        this.runners = {};\n        this.localAddress = client.getClusterService().getLocalClient().localAddress;\n        const config = client.getConfig().getReliableTopicConfig(name);\n        this.batchSize = config.readBatchSize;\n        this.overloadPolicy = config.overloadPolicy;\n        this.serializationService = client.getSerializationService();\n    }\n    setRingbuffer(ringbuffer) {\n        this.ringbuffer = ringbuffer;\n    }\n    addMessageListener(listener) {\n        const listenerId = UuidUtil_1.UuidUtil.generate().toString();\n        const runner = new ReliableTopicListenerRunner_1.ReliableTopicListenerRunner(listenerId, listener, this.ringbuffer, this.batchSize, this.serializationService, this.client.getLoggingService().getLogger(), this);\n        this.runners[listenerId] = runner;\n        this.ringbuffer.tailSequence().then((sequence) => {\n            runner.sequenceNumber = sequence.toNumber() + 1;\n            runner.next();\n        });\n        return listenerId;\n    }\n    removeMessageListener(listenerId) {\n        const runner = this.runners[listenerId];\n        if (!runner) {\n            return false;\n        }\n        runner.cancel();\n        delete this.runners[listenerId];\n        return true;\n    }\n    publish(message) {\n        const reliableTopicMessage = new ReliableTopicMessage_1.ReliableTopicMessage();\n        reliableTopicMessage.payload = this.serializationService.toData(message);\n        reliableTopicMessage.publishTime = Long.fromNumber(Date.now());\n        reliableTopicMessage.publisherAddress = this.localAddress;\n        switch (this.overloadPolicy) {\n            case TopicOverloadPolicy_1.TopicOverloadPolicy.ERROR:\n                return this.addWithError(reliableTopicMessage);\n            case TopicOverloadPolicy_1.TopicOverloadPolicy.DISCARD_NEWEST:\n                return this.addOrDiscard(reliableTopicMessage);\n            case TopicOverloadPolicy_1.TopicOverloadPolicy.DISCARD_OLDEST:\n                return this.addOrOverwrite(reliableTopicMessage);\n            case TopicOverloadPolicy_1.TopicOverloadPolicy.BLOCK:\n                return this.addWithBackoff(reliableTopicMessage);\n            default:\n                throw new RangeError('Unknown overload policy');\n        }\n    }\n    getRingbuffer() {\n        return this.ringbuffer;\n    }\n    destroy() {\n        for (const k in this.runners) {\n            const runner = this.runners[k];\n            runner.cancel();\n        }\n        return this.ringbuffer.destroy();\n    }\n    addOrDiscard(reliableTopicMessage) {\n        return this.ringbuffer.add(reliableTopicMessage, OverflowPolicy_1.OverflowPolicy.FAIL).then(() => {\n            return null;\n        });\n    }\n    addWithError(reliableTopicMessage) {\n        return this.ringbuffer.add(reliableTopicMessage, OverflowPolicy_1.OverflowPolicy.FAIL).then((seq) => {\n            if (seq.toNumber() === -1) {\n                throw new core_1.TopicOverloadError('Failed to publish message: ' + reliableTopicMessage +\n                    ' on topic: ' + this.getName());\n            }\n            return null;\n        });\n    }\n    addOrOverwrite(reliableTopicMessage) {\n        return this.ringbuffer.add(reliableTopicMessage, OverflowPolicy_1.OverflowPolicy.OVERWRITE).then(() => {\n            return null;\n        });\n    }\n    addWithBackoff(reliableTopicMessage) {\n        const deferred = Util_1.DeferredPromise();\n        this.trySendMessage(reliableTopicMessage, exports.TOPIC_INITIAL_BACKOFF, deferred);\n        return deferred.promise;\n    }\n    trySendMessage(message, delay, deferred) {\n        this.ringbuffer.add(message, OverflowPolicy_1.OverflowPolicy.FAIL).then((seq) => {\n            if (seq.toNumber() === -1) {\n                let newDelay = delay *= 2;\n                if (newDelay > exports.TOPIC_MAX_BACKOFF) {\n                    newDelay = exports.TOPIC_MAX_BACKOFF;\n                }\n                this.trySendMessage(message, newDelay, deferred);\n            }\n            else {\n                deferred.resolve();\n            }\n        }).catch(deferred.reject);\n    }\n}\nexports.ReliableTopicProxy = ReliableTopicProxy;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicProxy.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/ClusterDataFactory.js":
/*!***************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/ClusterDataFactory.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clusterDataFactory = exports.CLUSTER_DATA_ADDRESS_CLASS_ID = exports.CLUSTER_DATA_FACTORY_ID = void 0;\nconst Address_1 = __webpack_require__(/*! ../core/Address */ \"../shared/node_modules/hazelcast-client/lib/core/Address.js\");\n/** @internal */\nexports.CLUSTER_DATA_FACTORY_ID = 0;\n/** @internal */\nexports.CLUSTER_DATA_ADDRESS_CLASS_ID = 1;\n/** @internal */\nfunction clusterDataFactory(classId) {\n    if (classId === exports.CLUSTER_DATA_ADDRESS_CLASS_ID) {\n        return new Address_1.AddressImpl();\n    }\n    return null;\n}\nexports.clusterDataFactory = clusterDataFactory;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/ClusterDataFactory.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/Data.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/Data.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/Data.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/DefaultPredicates.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/DefaultPredicates.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.predicateFactory = exports.PagingPredicateImpl = exports.TruePredicate = exports.FalsePredicate = exports.RegexPredicate = exports.OrPredicate = exports.NotPredicate = exports.NotEqualPredicate = exports.InstanceOfPredicate = exports.InPredicate = exports.ILikePredicate = exports.LikePredicate = exports.GreaterLessPredicate = exports.EqualPredicate = exports.BetweenPredicate = exports.AndPredicate = exports.SqlPredicate = exports.PREDICATE_FACTORY_ID = void 0;\nconst Predicate_1 = __webpack_require__(/*! ../core/Predicate */ \"../shared/node_modules/hazelcast-client/lib/core/Predicate.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\n/** @internal */\nexports.PREDICATE_FACTORY_ID = -20;\n/** @internal */\nclass AbstractPredicate {\n    constructor() {\n        this.factoryId = exports.PREDICATE_FACTORY_ID;\n    }\n}\n/** @internal */\nclass SqlPredicate extends AbstractPredicate {\n    constructor(sql) {\n        super();\n        this.classId = SqlPredicate.CLASS_ID;\n        this.sql = sql;\n    }\n    readData(input) {\n        this.sql = input.readUTF();\n    }\n    writeData(output) {\n        output.writeUTF(this.sql);\n    }\n}\nexports.SqlPredicate = SqlPredicate;\nSqlPredicate.CLASS_ID = 0;\n/** @internal */\nclass AndPredicate extends AbstractPredicate {\n    constructor(...predicates) {\n        super();\n        this.classId = AndPredicate.CLASS_ID;\n        this.predicates = predicates;\n    }\n    readData(input) {\n        const s = input.readInt();\n        this.predicates = [];\n        for (let i = 0; i < s; i++) {\n            this.predicates[i] = input.readObject();\n        }\n    }\n    writeData(output) {\n        output.writeInt(this.predicates.length);\n        this.predicates.forEach(function (predicate) {\n            output.writeObject(predicate);\n        });\n    }\n}\nexports.AndPredicate = AndPredicate;\nAndPredicate.CLASS_ID = 1;\n/** @internal */\nclass BetweenPredicate extends AbstractPredicate {\n    constructor(field, from, to) {\n        super();\n        this.classId = BetweenPredicate.CLASS_ID;\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    readData(input) {\n        this.field = input.readUTF();\n        this.to = input.readObject();\n        this.from = input.readObject();\n    }\n    writeData(output) {\n        output.writeUTF(this.field);\n        output.writeObject(this.to);\n        output.writeObject(this.from);\n    }\n}\nexports.BetweenPredicate = BetweenPredicate;\nBetweenPredicate.CLASS_ID = 2;\n/** @internal */\nclass EqualPredicate extends AbstractPredicate {\n    constructor(field, value) {\n        super();\n        this.classId = EqualPredicate.CLASS_ID;\n        this.field = field;\n        this.value = value;\n    }\n    readData(input) {\n        this.field = input.readUTF();\n        this.value = input.readObject();\n    }\n    writeData(output) {\n        output.writeUTF(this.field);\n        output.writeObject(this.value);\n    }\n}\nexports.EqualPredicate = EqualPredicate;\nEqualPredicate.CLASS_ID = 3;\n/** @internal */\nclass GreaterLessPredicate extends AbstractPredicate {\n    constructor(field, value, equal, less) {\n        super();\n        this.classId = GreaterLessPredicate.CLASS_ID;\n        this.field = field;\n        this.value = value;\n        this.equal = equal;\n        this.less = less;\n    }\n    readData(input) {\n        this.field = input.readUTF();\n        this.value = input.readObject();\n        this.equal = input.readBoolean();\n        this.less = input.readBoolean();\n        return this;\n    }\n    writeData(output) {\n        output.writeUTF(this.field);\n        output.writeObject(this.value);\n        output.writeBoolean(this.equal);\n        output.writeBoolean(this.less);\n    }\n}\nexports.GreaterLessPredicate = GreaterLessPredicate;\nGreaterLessPredicate.CLASS_ID = 4;\n/** @internal */\nclass LikePredicate extends AbstractPredicate {\n    constructor(field, expr) {\n        super();\n        this.classId = LikePredicate.CLASS_ID;\n        this.field = field;\n        this.expr = expr;\n    }\n    readData(input) {\n        this.field = input.readUTF();\n        this.expr = input.readUTF();\n        return this;\n    }\n    writeData(output) {\n        output.writeUTF(this.field);\n        output.writeUTF(this.expr);\n    }\n}\nexports.LikePredicate = LikePredicate;\nLikePredicate.CLASS_ID = 5;\n/** @internal */\nclass ILikePredicate extends LikePredicate {\n    constructor() {\n        super(...arguments);\n        this.classId = ILikePredicate.CLASS_ID;\n    }\n}\nexports.ILikePredicate = ILikePredicate;\nILikePredicate.CLASS_ID = 6;\n/** @internal */\nclass InPredicate extends AbstractPredicate {\n    constructor(field, ...values) {\n        super();\n        this.classId = InPredicate.CLASS_ID;\n        this.field = field;\n        this.values = values;\n    }\n    readData(input) {\n        this.field = input.readUTF();\n        const s = input.readInt();\n        this.values = [];\n        for (let i = 0; i < s; i++) {\n            this.values.push(input.readObject());\n        }\n        return this;\n    }\n    writeData(output) {\n        output.writeUTF(this.field);\n        output.writeInt(this.values.length);\n        this.values.forEach(function (val) {\n            output.writeObject(val);\n        });\n    }\n}\nexports.InPredicate = InPredicate;\nInPredicate.CLASS_ID = 7;\n/** @internal */\nclass InstanceOfPredicate extends AbstractPredicate {\n    constructor(className) {\n        super();\n        this.classId = InstanceOfPredicate.CLASS_ID;\n        this.className = className;\n    }\n    readData(input) {\n        this.className = input.readUTF();\n        return this;\n    }\n    writeData(output) {\n        output.writeUTF(this.className);\n    }\n}\nexports.InstanceOfPredicate = InstanceOfPredicate;\nInstanceOfPredicate.CLASS_ID = 8;\n/** @internal */\nclass NotEqualPredicate extends EqualPredicate {\n    constructor() {\n        super(...arguments);\n        this.classId = NotEqualPredicate.CLASS_ID;\n    }\n}\nexports.NotEqualPredicate = NotEqualPredicate;\nNotEqualPredicate.CLASS_ID = 9;\n/** @internal */\nclass NotPredicate extends AbstractPredicate {\n    constructor(predicate) {\n        super();\n        this.classId = NotPredicate.CLASS_ID;\n        this.predicate = predicate;\n    }\n    readData(input) {\n        this.predicate = input.readObject();\n        return this;\n    }\n    writeData(output) {\n        output.writeObject(this.predicate);\n    }\n}\nexports.NotPredicate = NotPredicate;\nNotPredicate.CLASS_ID = 10;\n/** @internal */\nclass OrPredicate extends AbstractPredicate {\n    constructor(...predicates) {\n        super();\n        this.classId = OrPredicate.CLASS_ID;\n        this.predicates = predicates;\n    }\n    readData(input) {\n        const s = input.readInt();\n        this.predicates = [];\n        for (let i = 0; i < s; i++) {\n            this.predicates.push(input.readObject());\n        }\n        return this;\n    }\n    writeData(output) {\n        output.writeInt(this.predicates.length);\n        this.predicates.forEach(function (predicate) {\n            output.writeObject(predicate);\n        });\n    }\n}\nexports.OrPredicate = OrPredicate;\nOrPredicate.CLASS_ID = 11;\n/** @internal */\nclass RegexPredicate extends AbstractPredicate {\n    constructor(field, regex) {\n        super();\n        this.classId = RegexPredicate.CLASS_ID;\n        this.field = field;\n        this.regex = regex;\n    }\n    readData(input) {\n        this.field = input.readUTF();\n        this.regex = input.readUTF();\n        return this;\n    }\n    writeData(output) {\n        output.writeUTF(this.field);\n        output.writeUTF(this.regex);\n    }\n}\nexports.RegexPredicate = RegexPredicate;\nRegexPredicate.CLASS_ID = 12;\n/** @internal */\nclass FalsePredicate extends AbstractPredicate {\n    constructor() {\n        super(...arguments);\n        this.classId = FalsePredicate.CLASS_ID;\n    }\n    readData(input) {\n        // no-op\n    }\n    writeData(output) {\n        // no-op\n    }\n}\nexports.FalsePredicate = FalsePredicate;\nFalsePredicate.CLASS_ID = 13;\nFalsePredicate.INSTANCE = new FalsePredicate();\n/** @internal */\nclass TruePredicate extends AbstractPredicate {\n    constructor() {\n        super(...arguments);\n        this.classId = TruePredicate.CLASS_ID;\n    }\n    readData(input) {\n        // no-op\n    }\n    writeData(output) {\n        // no-op\n    }\n}\nexports.TruePredicate = TruePredicate;\nTruePredicate.CLASS_ID = 14;\nTruePredicate.INSTANCE = new TruePredicate();\n/** @internal */\nclass PagingPredicateImpl extends AbstractPredicate {\n    constructor(internalPredicate, pageSize, comparator) {\n        super();\n        this.classId = PagingPredicateImpl.CLASS_ID;\n        this.page = 0;\n        this.iterationType = Predicate_1.IterationType.ENTRY;\n        this.anchorList = [];\n        if (pageSize <= 0) {\n            throw new TypeError('Page size should be greater than 0!');\n        }\n        this.pageSize = pageSize;\n        if (internalPredicate instanceof PagingPredicateImpl) {\n            throw new TypeError('Nested paging predicates are not supported!');\n        }\n        this.internalPredicate = internalPredicate;\n        this.comparatorObject = comparator;\n    }\n    readData(input) {\n        this.internalPredicate = input.readObject();\n        this.comparatorObject = input.readObject();\n        this.page = input.readInt();\n        this.pageSize = input.readInt();\n        this.iterationType = Util_1.enumFromString(Predicate_1.IterationType, input.readUTF());\n        this.anchorList = [];\n        const size = input.readInt();\n        for (let i = 0; i < size; i++) {\n            const p = input.readInt();\n            const k = input.readObject();\n            const v = input.readObject();\n            this.anchorList.push([p, [k, v]]);\n        }\n    }\n    writeData(output) {\n        output.writeObject(this.internalPredicate);\n        output.writeObject(this.comparatorObject);\n        output.writeInt(this.page);\n        output.writeInt(this.pageSize);\n        output.writeUTF(this.iterationType);\n        output.writeInt(this.anchorList.length);\n        this.anchorList.forEach(function (anchorEntry) {\n            output.writeInt(anchorEntry[0]);\n            output.writeObject(anchorEntry[1][0]);\n            output.writeObject(anchorEntry[1][1]);\n        });\n    }\n    nextPage() {\n        this.page++;\n        return this;\n    }\n    previousPage() {\n        this.page--;\n        return this;\n    }\n    setPage(page) {\n        this.page = page;\n        return this;\n    }\n    getPage() {\n        return this.page;\n    }\n    getPageSize() {\n        return this.pageSize;\n    }\n    getComparator() {\n        return this.comparatorObject;\n    }\n    getAnchor() {\n        const anchorCount = this.anchorList.length;\n        if (this.page === 0 || anchorCount === 0) {\n            return PagingPredicateImpl.NULL_ANCHOR;\n        }\n        let anchoredEntry;\n        if (this.page < anchorCount) {\n            anchoredEntry = this.anchorList[this.page - 1];\n        }\n        else {\n            anchoredEntry = this.anchorList[anchorCount - 1];\n        }\n        return anchoredEntry;\n    }\n    getPredicate() {\n        return this.internalPredicate;\n    }\n    getAnchorList() {\n        return this.anchorList;\n    }\n    setAnchorList(anchorList) {\n        this.anchorList = anchorList;\n    }\n    getIterationType() {\n        return this.iterationType;\n    }\n    setIterationType(iterationType) {\n        this.iterationType = iterationType;\n    }\n}\nexports.PagingPredicateImpl = PagingPredicateImpl;\nPagingPredicateImpl.NULL_ANCHOR = [-1, null];\nPagingPredicateImpl.CLASS_ID = 15;\nconst allPredicates = [\n    SqlPredicate,\n    AndPredicate,\n    BetweenPredicate,\n    EqualPredicate,\n    GreaterLessPredicate,\n    LikePredicate,\n    ILikePredicate,\n    InPredicate,\n    InstanceOfPredicate,\n    NotEqualPredicate,\n    NotPredicate,\n    OrPredicate,\n    RegexPredicate,\n    FalsePredicate,\n    TruePredicate,\n    PagingPredicateImpl,\n];\nconst idToConstructorMap = {};\nfor (const predicate of allPredicates) {\n    idToConstructorMap[predicate.CLASS_ID] = predicate;\n}\n/** @internal */\nfunction predicateFactory(classId) {\n    if (idToConstructorMap[classId]) {\n        return new idToConstructorMap[classId]();\n    }\n    else {\n        throw new RangeError(`There is no default predicate with id ${classId}.`);\n    }\n}\nexports.predicateFactory = predicateFactory;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/DefaultPredicates.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/DefaultSerializers.js":
/*!***************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/DefaultSerializers.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HazelcastJsonValueSerializer = exports.JsonSerializer = exports.IdentifiedDataSerializableSerializer = exports.ArrayListSerializer = exports.LinkedListSerializer = exports.JavaClassSerializer = exports.FloatArraySerializer = exports.CharArraySerializer = exports.CharSerializer = exports.ByteArraySerializer = exports.ByteSerializer = exports.StringArraySerializer = exports.DoubleArraySerializer = exports.LongArraySerializer = exports.IntegerArraySerializer = exports.ShortArraySerializer = exports.BooleanArraySerializer = exports.DateSerializer = exports.FloatSerializer = exports.LongSerializer = exports.IntegerSerializer = exports.ShortSerializer = exports.NullSerializer = exports.NULL_TYPE_ID = exports.BooleanSerializer = exports.DoubleSerializer = exports.StringSerializer = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\n/** @internal */\nclass StringSerializer {\n    constructor() {\n        this.id = -11;\n    }\n    read(input) {\n        return input.readUTF();\n    }\n    write(output, object) {\n        output.writeUTF(object);\n    }\n}\nexports.StringSerializer = StringSerializer;\n/** @internal */\nclass DoubleSerializer {\n    constructor() {\n        this.id = -10;\n    }\n    read(input) {\n        return input.readDouble();\n    }\n    write(output, object) {\n        output.writeDouble(object);\n    }\n}\nexports.DoubleSerializer = DoubleSerializer;\n/** @internal */\nclass BooleanSerializer {\n    constructor() {\n        this.id = -4;\n    }\n    read(input) {\n        return input.readBoolean();\n    }\n    write(output, object) {\n        output.writeBoolean(object);\n    }\n}\nexports.BooleanSerializer = BooleanSerializer;\n/** @internal */\nexports.NULL_TYPE_ID = 0;\n/** @internal */\nclass NullSerializer {\n    constructor() {\n        this.id = exports.NULL_TYPE_ID;\n    }\n    read(input) {\n        return null;\n    }\n    write(output, object) {\n        // no-op\n    }\n}\nexports.NullSerializer = NullSerializer;\n/** @internal */\nclass ShortSerializer {\n    constructor() {\n        this.id = -6;\n    }\n    read(input) {\n        return input.readShort();\n    }\n    write(output, object) {\n        output.writeShort(object);\n    }\n}\nexports.ShortSerializer = ShortSerializer;\n/** @internal */\nclass IntegerSerializer {\n    constructor() {\n        this.id = -7;\n    }\n    read(input) {\n        return input.readInt();\n    }\n    write(output, object) {\n        output.writeInt(object);\n    }\n}\nexports.IntegerSerializer = IntegerSerializer;\n/** @internal */\nclass LongSerializer {\n    constructor() {\n        this.id = -8;\n    }\n    read(input) {\n        return input.readLong();\n    }\n    write(output, object) {\n        output.writeLong(object);\n    }\n}\nexports.LongSerializer = LongSerializer;\n/** @internal */\nclass FloatSerializer {\n    constructor() {\n        this.id = -9;\n    }\n    read(input) {\n        return input.readFloat();\n    }\n    write(output, object) {\n        output.writeFloat(object);\n    }\n}\nexports.FloatSerializer = FloatSerializer;\n/** @internal */\nclass DateSerializer {\n    constructor() {\n        this.id = -25;\n    }\n    read(input) {\n        return new Date(input.readLong().toNumber());\n    }\n    write(output, object) {\n        output.writeLong(Long.fromNumber(object.getMilliseconds()));\n    }\n}\nexports.DateSerializer = DateSerializer;\n/** @internal */\nclass BooleanArraySerializer {\n    constructor() {\n        this.id = -13;\n    }\n    read(input) {\n        return input.readBooleanArray();\n    }\n    write(output, object) {\n        output.writeBooleanArray(object);\n    }\n}\nexports.BooleanArraySerializer = BooleanArraySerializer;\n/** @internal */\nclass ShortArraySerializer {\n    constructor() {\n        this.id = -15;\n    }\n    read(input) {\n        return input.readShortArray();\n    }\n    write(output, object) {\n        output.writeShortArray(object);\n    }\n}\nexports.ShortArraySerializer = ShortArraySerializer;\n/** @internal */\nclass IntegerArraySerializer {\n    constructor() {\n        this.id = -16;\n    }\n    read(input) {\n        return input.readIntArray();\n    }\n    write(output, object) {\n        output.writeIntArray(object);\n    }\n}\nexports.IntegerArraySerializer = IntegerArraySerializer;\n/** @internal */\nclass LongArraySerializer {\n    constructor() {\n        this.id = -17;\n    }\n    read(input) {\n        return input.readLongArray();\n    }\n    write(output, object) {\n        output.writeLongArray(object);\n    }\n}\nexports.LongArraySerializer = LongArraySerializer;\n/** @internal */\nclass DoubleArraySerializer {\n    constructor() {\n        this.id = -19;\n    }\n    read(input) {\n        return input.readDoubleArray();\n    }\n    write(output, object) {\n        output.writeDoubleArray(object);\n    }\n}\nexports.DoubleArraySerializer = DoubleArraySerializer;\n/** @internal */\nclass StringArraySerializer {\n    constructor() {\n        this.id = -20;\n    }\n    read(input) {\n        return input.readUTFArray();\n    }\n    write(output, object) {\n        output.writeUTFArray(object);\n    }\n}\nexports.StringArraySerializer = StringArraySerializer;\n/** @internal */\nclass ByteSerializer {\n    constructor() {\n        this.id = -3;\n    }\n    read(input) {\n        return input.readByte();\n    }\n    write(output, object) {\n        output.writeByte(object);\n    }\n}\nexports.ByteSerializer = ByteSerializer;\n/** @internal */\nclass ByteArraySerializer {\n    constructor() {\n        this.id = -12;\n    }\n    read(input) {\n        return input.readByteArray();\n    }\n    write(output, object) {\n        output.writeByteArray(object);\n    }\n}\nexports.ByteArraySerializer = ByteArraySerializer;\n/** @internal */\nclass CharSerializer {\n    constructor() {\n        this.id = -5;\n    }\n    read(input) {\n        return input.readChar();\n    }\n    write(output, object) {\n        output.writeChar(object);\n    }\n}\nexports.CharSerializer = CharSerializer;\n/** @internal */\nclass CharArraySerializer {\n    constructor() {\n        this.id = -14;\n    }\n    read(input) {\n        return input.readCharArray();\n    }\n    write(output, object) {\n        output.writeCharArray(object);\n    }\n}\nexports.CharArraySerializer = CharArraySerializer;\n/** @internal */\nclass FloatArraySerializer {\n    constructor() {\n        this.id = -18;\n    }\n    read(input) {\n        return input.readFloatArray();\n    }\n    write(output, object) {\n        output.writeFloatArray(object);\n    }\n}\nexports.FloatArraySerializer = FloatArraySerializer;\n/** @internal */\nclass JavaClassSerializer {\n    constructor() {\n        this.id = -24;\n    }\n    read(input) {\n        return input.readUTF();\n    }\n    write(output, object) {\n        output.writeUTF(object);\n    }\n}\nexports.JavaClassSerializer = JavaClassSerializer;\n/** @internal */\nclass LinkedListSerializer {\n    constructor() {\n        this.id = -30;\n    }\n    read(input) {\n        const size = input.readInt();\n        let result = null;\n        if (size > BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH) {\n            result = [];\n            for (let i = 0; i < size; i++) {\n                result.push(input.readObject());\n            }\n        }\n        return result;\n    }\n    write(output, object) {\n        // no-op\n    }\n}\nexports.LinkedListSerializer = LinkedListSerializer;\n/** @internal */\nclass ArrayListSerializer extends LinkedListSerializer {\n    constructor() {\n        super(...arguments);\n        this.id = -29;\n    }\n}\nexports.ArrayListSerializer = ArrayListSerializer;\n/** @internal */\nclass IdentifiedDataSerializableSerializer {\n    constructor(factories) {\n        this.id = -2;\n        this.factories = factories;\n    }\n    read(input) {\n        const isIdentified = input.readBoolean();\n        if (!isIdentified) {\n            throw new RangeError('Native clients does not support Data Serializable. Please use Identified Data Serializable');\n        }\n        const factoryId = input.readInt();\n        const classId = input.readInt();\n        const factoryFn = this.factories[factoryId];\n        if (!factoryFn) {\n            throw new RangeError('There is no Identified Data Serializer factory with id ' + factoryId + '.');\n        }\n        const object = factoryFn(classId);\n        object.readData(input);\n        return object;\n    }\n    write(output, object) {\n        output.writeBoolean(true);\n        output.writeInt(object.factoryId);\n        output.writeInt(object.classId);\n        object.writeData(output);\n    }\n}\nexports.IdentifiedDataSerializableSerializer = IdentifiedDataSerializableSerializer;\n/** @internal */\nclass JsonSerializer {\n    constructor() {\n        this.id = -130;\n    }\n    read(input) {\n        return JSON.parse(input.readUTF());\n    }\n    write(output, object) {\n        if (object instanceof core_1.HazelcastJsonValue) {\n            output.writeUTF(object.toString());\n        }\n        else {\n            output.writeUTF(JSON.stringify(object));\n        }\n    }\n}\nexports.JsonSerializer = JsonSerializer;\n/** @internal */\nclass HazelcastJsonValueSerializer extends JsonSerializer {\n    read(input) {\n        return new core_1.HazelcastJsonValue(input.readUTF());\n    }\n}\nexports.HazelcastJsonValueSerializer = HazelcastJsonValueSerializer;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/DefaultSerializers.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/HeapData.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/HeapData.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HeapData = exports.HEAP_DATA_OVERHEAD = exports.DATA_OFFSET = exports.TYPE_OFFSET = exports.PARTITION_HASH_OFFSET = void 0;\nconst Murmur_1 = __webpack_require__(/*! ../invocation/Murmur */ \"../shared/node_modules/hazelcast-client/lib/invocation/Murmur.js\");\nconst DefaultSerializers_1 = __webpack_require__(/*! ./DefaultSerializers */ \"../shared/node_modules/hazelcast-client/lib/serialization/DefaultSerializers.js\");\n/** @internal */\nexports.PARTITION_HASH_OFFSET = 0;\n/** @internal */\nexports.TYPE_OFFSET = 4;\n/** @internal */\nexports.DATA_OFFSET = 8;\n/** @internal */\nexports.HEAP_DATA_OVERHEAD = exports.DATA_OFFSET;\n/** @internal */\nclass HeapData {\n    constructor(buffer) {\n        if (buffer != null && buffer.length > 0 && buffer.length < exports.HEAP_DATA_OVERHEAD) {\n            throw new RangeError('Data should be either empty or should contain more than '\n                + exports.HEAP_DATA_OVERHEAD + ' bytes! -> ' + buffer);\n        }\n        this.payload = buffer;\n    }\n    /**\n     * Returns serialized representation in a buffer\n     */\n    toBuffer() {\n        return this.payload;\n    }\n    /**\n     * Returns serialization type\n     */\n    getType() {\n        if (this.totalSize() === 0) {\n            return DefaultSerializers_1.NULL_TYPE_ID;\n        }\n        return this.payload.readIntBE(exports.TYPE_OFFSET, 4);\n    }\n    /**\n     * Returns the total size of data in bytes\n     */\n    totalSize() {\n        if (this.payload === null) {\n            return 0;\n        }\n        else {\n            return this.payload.length;\n        }\n    }\n    /**\n     * Returns size of internal binary data in bytes\n     */\n    dataSize() {\n        return Math.max(this.totalSize() - exports.HEAP_DATA_OVERHEAD, 0);\n    }\n    /**\n     * Returns approximate heap cost of this Data object in bytes\n     */\n    getHeapCost() {\n        return 0;\n    }\n    /**\n     * Returns partition hash of serialized object\n     */\n    getPartitionHash() {\n        if (this.hasPartitionHash()) {\n            return this.payload.readIntBE(exports.PARTITION_HASH_OFFSET, 4);\n        }\n        else {\n            return this.hashCode();\n        }\n    }\n    hashCode() {\n        return Murmur_1.murmur(this.payload.slice(exports.DATA_OFFSET));\n    }\n    equals(other) {\n        return this.payload.compare(other.toBuffer(), exports.DATA_OFFSET, other.toBuffer().length, exports.DATA_OFFSET) === 0;\n    }\n    /**\n     * Returns true if data has partition hash\n     */\n    hasPartitionHash() {\n        return this.payload !== null\n            && this.payload.length >= exports.HEAP_DATA_OVERHEAD\n            && this.payload.readIntBE(exports.PARTITION_HASH_OFFSET, 4) !== 0;\n    }\n    /**\n     * Returns true if the object is a portable object\n     */\n    isPortable() {\n        return false;\n    }\n}\nexports.HeapData = HeapData;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/HeapData.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/ObjectData.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/ObjectData.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObjectDataInput = exports.PositionalObjectDataOutput = exports.ObjectDataOutput = void 0;\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst HeapData_1 = __webpack_require__(/*! ./HeapData */ \"../shared/node_modules/hazelcast-client/lib/serialization/HeapData.js\");\nconst OUTPUT_BUFFER_INITIAL_SIZE = HeapData_1.HEAP_DATA_OVERHEAD + BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES;\nconst MASK_1BYTE = (1 << 8) - 1;\n/** @internal */\nclass ObjectDataOutput {\n    constructor(service, isBigEndian) {\n        this.buffer = Buffer.allocUnsafe(OUTPUT_BUFFER_INITIAL_SIZE);\n        this.service = service;\n        this.bigEndian = isBigEndian;\n        this.pos = 0;\n    }\n    clear() {\n        this.buffer = Buffer.allocUnsafe(this.buffer.length);\n        this.pos = 0;\n    }\n    isBigEndian() {\n        return this.bigEndian;\n    }\n    position(newPosition) {\n        const oldPos = this.pos;\n        if (Number.isInteger(newPosition)) {\n            this.pos = newPosition;\n        }\n        return oldPos;\n    }\n    toBuffer() {\n        return this.buffer.slice(0, this.pos);\n    }\n    write(byte) {\n        if (Buffer.isBuffer(byte)) {\n            this.ensureAvailable(byte.length);\n            byte.copy(this.buffer, this.pos);\n            this.pos += byte.length;\n        }\n        else {\n            this.ensureAvailable(BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES);\n            BitsUtil_1.BitsUtil.writeUInt8(this.buffer, this.pos, byte & MASK_1BYTE);\n            this.pos += BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES;\n        }\n    }\n    writeBoolean(val) {\n        this.write(val ? 1 : 0);\n    }\n    writeBooleanArray(val) {\n        this.writeArray(this.writeBoolean, val);\n    }\n    writeByte(byte) {\n        this.write(byte);\n    }\n    writeByteArray(bytes) {\n        const len = (bytes != null) ? bytes.length : BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH;\n        this.writeInt(len);\n        if (len > 0) {\n            this.ensureAvailable(len);\n            bytes.copy(this.buffer, this.pos);\n            this.pos += len;\n        }\n    }\n    writeChar(char) {\n        this.ensureAvailable(BitsUtil_1.BitsUtil.CHAR_SIZE_IN_BYTES);\n        BitsUtil_1.BitsUtil.writeUInt16(this.buffer, this.pos, char.charCodeAt(0), this.isBigEndian());\n        this.pos += BitsUtil_1.BitsUtil.CHAR_SIZE_IN_BYTES;\n    }\n    writeCharArray(chars) {\n        this.writeArray(this.writeChar, chars);\n    }\n    writeChars(chars) {\n        const len = (chars != null) ? chars.length : BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH;\n        this.writeInt(len);\n        for (let i = 0; i < len; i++) {\n            this.writeChar(chars.charAt(i));\n        }\n    }\n    writeData(data) {\n        const buf = (data != null) ? data.toBuffer() : null;\n        const len = (buf != null) ? buf.length : BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH;\n        this.writeInt(len);\n        for (let i = 0; i < len; i++) {\n            this.write(buf[i]);\n        }\n    }\n    writeDouble(double) {\n        this.ensureAvailable(BitsUtil_1.BitsUtil.DOUBLE_SIZE_IN_BYTES);\n        BitsUtil_1.BitsUtil.writeDouble(this.buffer, this.pos, double, this.isBigEndian());\n        this.pos += BitsUtil_1.BitsUtil.DOUBLE_SIZE_IN_BYTES;\n    }\n    writeDoubleArray(doubles) {\n        this.writeArray(this.writeDouble, doubles);\n    }\n    writeFloat(float) {\n        this.ensureAvailable(BitsUtil_1.BitsUtil.FLOAT_SIZE_IN_BYTES);\n        BitsUtil_1.BitsUtil.writeFloat(this.buffer, this.pos, float, this.isBigEndian());\n        this.pos += BitsUtil_1.BitsUtil.FLOAT_SIZE_IN_BYTES;\n    }\n    writeFloatArray(floats) {\n        this.writeArray(this.writeFloat, floats);\n    }\n    writeInt(int) {\n        this.ensureAvailable(BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n        BitsUtil_1.BitsUtil.writeInt32(this.buffer, this.pos, int, this.isBigEndian());\n        this.pos += BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n    }\n    writeIntBE(int) {\n        this.ensureAvailable(BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n        BitsUtil_1.BitsUtil.writeInt32(this.buffer, this.pos, int, true);\n        this.pos += BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n    }\n    writeIntArray(ints) {\n        this.writeArray(this.writeInt, ints);\n    }\n    writeLong(long) {\n        this.ensureAvailable(BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES);\n        if (this.isBigEndian()) {\n            BitsUtil_1.BitsUtil.writeInt32(this.buffer, this.pos, long.high, true);\n            this.pos += BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n            BitsUtil_1.BitsUtil.writeInt32(this.buffer, this.pos, long.low, true);\n            this.pos += BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n        }\n        else {\n            BitsUtil_1.BitsUtil.writeInt32(this.buffer, this.pos, long.low, false);\n            this.pos += BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n            BitsUtil_1.BitsUtil.writeInt32(this.buffer, this.pos, long.high, false);\n            this.pos += BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n        }\n    }\n    writeLongArray(longs) {\n        this.writeArray(this.writeLong, longs);\n    }\n    writeObject(object) {\n        this.service.writeObject(this, object);\n    }\n    writeShort(short) {\n        this.ensureAvailable(BitsUtil_1.BitsUtil.SHORT_SIZE_IN_BYTES);\n        BitsUtil_1.BitsUtil.writeInt16(this.buffer, this.pos, short, this.isBigEndian());\n        this.pos += BitsUtil_1.BitsUtil.SHORT_SIZE_IN_BYTES;\n    }\n    writeShortArray(shorts) {\n        this.writeArray(this.writeShort, shorts);\n    }\n    writeUTF(val) {\n        const len = (val != null) ? Buffer.byteLength(val, 'utf8') : BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH;\n        this.writeInt(len);\n        if (len === BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH) {\n            return;\n        }\n        this.ensureAvailable(len);\n        this.buffer.write(val, this.pos, this.pos + len, 'utf8');\n        this.pos += len;\n    }\n    writeUTFArray(val) {\n        this.writeArray(this.writeUTF, val);\n    }\n    writeZeroBytes(count) {\n        for (let i = 0; i < count; i++) {\n            this.write(0);\n        }\n    }\n    available() {\n        return this.buffer == null ? 0 : this.buffer.length - this.pos;\n    }\n    ensureAvailable(size) {\n        if (this.available() < size) {\n            const newBuffer = Buffer.allocUnsafe(this.pos + size);\n            this.buffer.copy(newBuffer, 0, 0, this.pos);\n            this.buffer = newBuffer;\n        }\n    }\n    writeArray(func, arr) {\n        const len = (arr != null) ? arr.length : BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH;\n        this.writeInt(len);\n        if (len > 0) {\n            const boundFunc = func.bind(this);\n            arr.forEach(boundFunc);\n        }\n    }\n}\nexports.ObjectDataOutput = ObjectDataOutput;\n/** @internal */\nclass PositionalObjectDataOutput extends ObjectDataOutput {\n    pwrite(position, byte) {\n        if (Buffer.isBuffer(byte)) {\n            byte.copy(this.buffer, position);\n        }\n        else {\n            this.buffer[position] = byte;\n        }\n    }\n    pwriteBoolean(position, val) {\n        this.pwrite(position, val ? 1 : 0);\n    }\n    pwriteByte(position, byte) {\n        this.pwrite(position, byte);\n    }\n    pwriteChar(position, char) {\n        BitsUtil_1.BitsUtil.writeUInt16(this.buffer, position, char.charCodeAt(0), this.isBigEndian());\n    }\n    pwriteDouble(position, double) {\n        BitsUtil_1.BitsUtil.writeDouble(this.buffer, position, double, this.isBigEndian());\n    }\n    pwriteFloat(position, float) {\n        BitsUtil_1.BitsUtil.writeFloat(this.buffer, position, float, this.isBigEndian());\n    }\n    pwriteInt(position, int) {\n        BitsUtil_1.BitsUtil.writeInt32(this.buffer, position, int, this.isBigEndian());\n    }\n    pwriteIntBE(position, int) {\n        BitsUtil_1.BitsUtil.writeInt32(this.buffer, position, int, true);\n    }\n    pwriteLong(position, long) {\n        if (this.isBigEndian()) {\n            BitsUtil_1.BitsUtil.writeInt32(this.buffer, position, long.high, true);\n            BitsUtil_1.BitsUtil.writeInt32(this.buffer, position + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, long.low, true);\n        }\n        else {\n            BitsUtil_1.BitsUtil.writeInt32(this.buffer, position, long.low, false);\n            BitsUtil_1.BitsUtil.writeInt32(this.buffer, position + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, long.high, false);\n        }\n    }\n    pwriteShort(position, short) {\n        BitsUtil_1.BitsUtil.writeInt16(this.buffer, position, short, this.isBigEndian());\n    }\n}\nexports.PositionalObjectDataOutput = PositionalObjectDataOutput;\n/** @internal */\nclass ObjectDataInput {\n    constructor(buffer, offset, serializationService, isBigEndian) {\n        this.buffer = buffer;\n        this.offset = offset;\n        this.service = serializationService;\n        this.bigEndian = isBigEndian;\n        this.pos = this.offset;\n    }\n    isBigEndian() {\n        return this.bigEndian;\n    }\n    position(newPosition) {\n        const oldPos = this.pos;\n        if (Number.isInteger(newPosition)) {\n            this.pos = newPosition;\n        }\n        return oldPos;\n    }\n    read(pos) {\n        this.assertAvailable(BitsUtil_1.BitsUtil.BYTE_SIZE_IN_BYTES, pos);\n        if (pos === undefined) {\n            return BitsUtil_1.BitsUtil.readUInt8(this.buffer, this.pos++);\n        }\n        else {\n            return BitsUtil_1.BitsUtil.readUInt8(this.buffer, pos);\n        }\n    }\n    readBoolean(pos) {\n        return this.read(pos) === 1;\n    }\n    readBooleanArray(pos) {\n        return this.readArray(this.readBoolean, pos);\n    }\n    readByte(pos) {\n        return this.read(pos);\n    }\n    readByteArray(pos) {\n        const backupPos = this.pos;\n        if (pos !== undefined) {\n            this.pos = pos;\n        }\n        const len = this.readInt();\n        if (len === BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH) {\n            if (pos !== undefined) {\n                this.pos = backupPos;\n            }\n            return null;\n        }\n        const buf = this.buffer.slice(this.pos, this.pos + len);\n        if (pos !== undefined) {\n            this.pos = backupPos;\n        }\n        else {\n            this.pos += len;\n        }\n        return buf;\n    }\n    readChar(pos) {\n        this.assertAvailable(BitsUtil_1.BitsUtil.CHAR_SIZE_IN_BYTES);\n        let readBytes;\n        if (pos === undefined) {\n            readBytes = BitsUtil_1.BitsUtil.readUInt16(this.buffer, this.pos, this.isBigEndian());\n            this.pos += BitsUtil_1.BitsUtil.CHAR_SIZE_IN_BYTES;\n        }\n        else {\n            readBytes = BitsUtil_1.BitsUtil.readUInt16(this.buffer, pos, this.isBigEndian());\n        }\n        return String.fromCharCode(readBytes);\n    }\n    readCharArray(pos) {\n        return this.readArray(this.readChar, pos);\n    }\n    readData() {\n        const bytes = this.readByteArray();\n        const data = bytes === null ? null : new HeapData_1.HeapData(Buffer.from(bytes));\n        return data;\n    }\n    readDouble(pos) {\n        this.assertAvailable(BitsUtil_1.BitsUtil.DOUBLE_SIZE_IN_BYTES, pos);\n        let ret;\n        if (pos === undefined) {\n            ret = BitsUtil_1.BitsUtil.readDouble(this.buffer, this.pos, this.isBigEndian());\n            this.pos += BitsUtil_1.BitsUtil.DOUBLE_SIZE_IN_BYTES;\n        }\n        else {\n            ret = BitsUtil_1.BitsUtil.readDouble(this.buffer, pos, this.isBigEndian());\n        }\n        return ret;\n    }\n    readDoubleArray(pos) {\n        return this.readArray(this.readDouble, pos);\n    }\n    readFloat(pos) {\n        this.assertAvailable(BitsUtil_1.BitsUtil.FLOAT_SIZE_IN_BYTES, pos);\n        let ret;\n        if (pos === undefined) {\n            ret = BitsUtil_1.BitsUtil.readFloat(this.buffer, this.pos, this.isBigEndian());\n            this.pos += BitsUtil_1.BitsUtil.FLOAT_SIZE_IN_BYTES;\n        }\n        else {\n            ret = BitsUtil_1.BitsUtil.readFloat(this.buffer, pos, this.isBigEndian());\n        }\n        return ret;\n    }\n    readFloatArray(pos) {\n        return this.readArray(this.readFloat, pos);\n    }\n    readInt(pos) {\n        this.assertAvailable(BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, pos);\n        let ret;\n        if (pos === undefined) {\n            ret = BitsUtil_1.BitsUtil.readInt32(this.buffer, this.pos, this.isBigEndian());\n            this.pos += BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n        }\n        else {\n            ret = BitsUtil_1.BitsUtil.readInt32(this.buffer, pos, this.isBigEndian());\n        }\n        return ret;\n    }\n    readIntArray(pos) {\n        return this.readArray(this.readInt, pos);\n    }\n    readLong(pos) {\n        this.assertAvailable(BitsUtil_1.BitsUtil.LONG_SIZE_IN_BYTES, pos);\n        let first;\n        let second;\n        if (pos === undefined) {\n            first = BitsUtil_1.BitsUtil.readInt32(this.buffer, this.pos, this.isBigEndian());\n            this.pos += BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n            second = BitsUtil_1.BitsUtil.readInt32(this.buffer, this.pos, this.isBigEndian());\n            this.pos += BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n        }\n        else {\n            first = BitsUtil_1.BitsUtil.readInt32(this.buffer, pos, this.isBigEndian());\n            second = BitsUtil_1.BitsUtil.readInt32(this.buffer, pos + BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, this.isBigEndian());\n        }\n        if (this.isBigEndian()) {\n            return new Long(second, first);\n        }\n        else {\n            return new Long(first, second);\n        }\n    }\n    readLongArray(pos) {\n        return this.readArray(this.readLong, pos);\n    }\n    readObject() {\n        return this.service.readObject(this);\n    }\n    readShort(pos) {\n        this.assertAvailable(BitsUtil_1.BitsUtil.SHORT_SIZE_IN_BYTES, pos);\n        let ret;\n        if (pos === undefined) {\n            ret = BitsUtil_1.BitsUtil.readInt16(this.buffer, this.pos, this.isBigEndian());\n            this.pos += BitsUtil_1.BitsUtil.SHORT_SIZE_IN_BYTES;\n        }\n        else {\n            ret = BitsUtil_1.BitsUtil.readInt16(this.buffer, pos, this.isBigEndian());\n        }\n        return ret;\n    }\n    readShortArray(pos) {\n        return this.readArray(this.readShort, pos);\n    }\n    readUnsignedByte(pos) {\n        return this.read(pos);\n    }\n    readUnsignedShort(pos) {\n        return this.readChar(pos).charCodeAt(0);\n    }\n    readUTF(pos) {\n        const len = this.readInt(pos);\n        const readPos = this.addOrUndefined(pos, 4) || this.pos;\n        if (len === BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH) {\n            return null;\n        }\n        const result = this.buffer.toString('utf8', readPos, readPos + len);\n        if (pos === undefined) {\n            this.pos += len;\n        }\n        return result;\n    }\n    readUTFArray(pos) {\n        return this.readArray(this.readUTF, pos);\n    }\n    reset() {\n        this.pos = 0;\n    }\n    skipBytes(count) {\n        this.pos += count;\n    }\n    available() {\n        return this.buffer.length - this.pos;\n    }\n    // used in binary compatibility tests\n    readRaw(numOfBytes) {\n        this.assertAvailable(numOfBytes, this.pos);\n        const raw = this.buffer.slice(this.pos, this.pos + numOfBytes);\n        this.pos += numOfBytes;\n        return raw;\n    }\n    readArray(func, pos) {\n        const backupPos = this.pos;\n        if (pos !== undefined) {\n            this.pos = pos;\n        }\n        const len = this.readInt();\n        if (len === BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH) {\n            if (pos !== undefined) {\n                this.pos = backupPos;\n            }\n            return null;\n        }\n        const arr = [];\n        for (let i = 0; i < len; i++) {\n            arr.push(func.call(this));\n        }\n        if (pos !== undefined) {\n            this.pos = backupPos;\n        }\n        return arr;\n    }\n    assertAvailable(numOfBytes, pos = this.pos) {\n        assert(pos >= 0);\n        assert(pos + numOfBytes <= this.buffer.length);\n    }\n    addOrUndefined(base, adder) {\n        if (base === undefined) {\n            return undefined;\n        }\n        else {\n            return base + adder;\n        }\n    }\n}\nexports.ObjectDataInput = ObjectDataInput;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/ObjectData.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/Portable.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/Portable.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FieldType = void 0;\n/**\n * Portable field type.\n */\nvar FieldType;\n(function (FieldType) {\n    FieldType[FieldType[\"PORTABLE\"] = 0] = \"PORTABLE\";\n    FieldType[FieldType[\"BYTE\"] = 1] = \"BYTE\";\n    FieldType[FieldType[\"BOOLEAN\"] = 2] = \"BOOLEAN\";\n    FieldType[FieldType[\"CHAR\"] = 3] = \"CHAR\";\n    FieldType[FieldType[\"SHORT\"] = 4] = \"SHORT\";\n    FieldType[FieldType[\"INT\"] = 5] = \"INT\";\n    FieldType[FieldType[\"LONG\"] = 6] = \"LONG\";\n    FieldType[FieldType[\"FLOAT\"] = 7] = \"FLOAT\";\n    FieldType[FieldType[\"DOUBLE\"] = 8] = \"DOUBLE\";\n    FieldType[FieldType[\"UTF\"] = 9] = \"UTF\";\n    FieldType[FieldType[\"PORTABLE_ARRAY\"] = 10] = \"PORTABLE_ARRAY\";\n    FieldType[FieldType[\"BYTE_ARRAY\"] = 11] = \"BYTE_ARRAY\";\n    FieldType[FieldType[\"BOOLEAN_ARRAY\"] = 12] = \"BOOLEAN_ARRAY\";\n    FieldType[FieldType[\"CHAR_ARRAY\"] = 13] = \"CHAR_ARRAY\";\n    FieldType[FieldType[\"SHORT_ARRAY\"] = 14] = \"SHORT_ARRAY\";\n    FieldType[FieldType[\"INT_ARRAY\"] = 15] = \"INT_ARRAY\";\n    FieldType[FieldType[\"LONG_ARRAY\"] = 16] = \"LONG_ARRAY\";\n    FieldType[FieldType[\"FLOAT_ARRAY\"] = 17] = \"FLOAT_ARRAY\";\n    FieldType[FieldType[\"DOUBLE_ARRAY\"] = 18] = \"DOUBLE_ARRAY\";\n    FieldType[FieldType[\"UTF_ARRAY\"] = 19] = \"UTF_ARRAY\";\n})(FieldType = exports.FieldType || (exports.FieldType = {}));\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/Portable.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/Serializable.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/Serializable.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/Serializable.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/SerializationService.js":
/*!*****************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/SerializationService.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SerializationServiceV1 = void 0;\nconst AggregatorFactory_1 = __webpack_require__(/*! ../aggregation/AggregatorFactory */ \"../shared/node_modules/hazelcast-client/lib/aggregation/AggregatorFactory.js\");\nconst ClusterDataFactory_1 = __webpack_require__(/*! ./ClusterDataFactory */ \"../shared/node_modules/hazelcast-client/lib/serialization/ClusterDataFactory.js\");\nconst ReliableTopicMessage_1 = __webpack_require__(/*! ../proxy/topic/ReliableTopicMessage */ \"../shared/node_modules/hazelcast-client/lib/proxy/topic/ReliableTopicMessage.js\");\nconst Util = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst DefaultSerializers_1 = __webpack_require__(/*! ./DefaultSerializers */ \"../shared/node_modules/hazelcast-client/lib/serialization/DefaultSerializers.js\");\nconst HeapData_1 = __webpack_require__(/*! ./HeapData */ \"../shared/node_modules/hazelcast-client/lib/serialization/HeapData.js\");\nconst ObjectData_1 = __webpack_require__(/*! ./ObjectData */ \"../shared/node_modules/hazelcast-client/lib/serialization/ObjectData.js\");\nconst PortableSerializer_1 = __webpack_require__(/*! ./portable/PortableSerializer */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/PortableSerializer.js\");\nconst DefaultPredicates_1 = __webpack_require__(/*! ./DefaultPredicates */ \"../shared/node_modules/hazelcast-client/lib/serialization/DefaultPredicates.js\");\nconst JsonStringDeserializationPolicy_1 = __webpack_require__(/*! ../config/JsonStringDeserializationPolicy */ \"../shared/node_modules/hazelcast-client/lib/config/JsonStringDeserializationPolicy.js\");\nconst RestValue_1 = __webpack_require__(/*! ../core/RestValue */ \"../shared/node_modules/hazelcast-client/lib/core/RestValue.js\");\nconst defaultPartitionStrategy = (obj) => {\n    if (obj == null || !obj['getPartitionHash']) {\n        return 0;\n    }\n    else {\n        return obj.getPartitionHash();\n    }\n};\n/** @internal */\nclass SerializationServiceV1 {\n    constructor(serializationConfig) {\n        this.serializationConfig = serializationConfig;\n        this.registry = {};\n        this.serializerNameToId = {};\n        this.registerDefaultSerializers();\n        this.registerCustomSerializers();\n        this.registerGlobalSerializer();\n    }\n    isData(object) {\n        if (object instanceof HeapData_1.HeapData) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    toData(object, partitioningStrategy = defaultPartitionStrategy) {\n        if (this.isData(object)) {\n            return object;\n        }\n        const dataOutput = new ObjectData_1.PositionalObjectDataOutput(this, this.serializationConfig.isBigEndian);\n        const serializer = this.findSerializerFor(object);\n        // Check if object is partition aware\n        if (object != null && object.partitionKey != null) {\n            const partitionKey = object.partitionKey;\n            const serializedPartitionKey = this.toData(partitionKey);\n            dataOutput.writeIntBE(this.calculatePartitionHash(serializedPartitionKey, partitioningStrategy));\n        }\n        else {\n            dataOutput.writeIntBE(this.calculatePartitionHash(object, partitioningStrategy));\n        }\n        dataOutput.writeIntBE(serializer.id);\n        serializer.write(dataOutput, object);\n        return new HeapData_1.HeapData(dataOutput.toBuffer());\n    }\n    toObject(data) {\n        if (data == null) {\n            return data;\n        }\n        if (!data.getType) {\n            return data;\n        }\n        const serializer = this.findSerializerById(data.getType());\n        const dataInput = new ObjectData_1.ObjectDataInput(data.toBuffer(), HeapData_1.DATA_OFFSET, this, this.serializationConfig.isBigEndian);\n        return serializer.read(dataInput);\n    }\n    writeObject(out, object) {\n        const serializer = this.findSerializerFor(object);\n        out.writeInt(serializer.id);\n        serializer.write(out, object);\n    }\n    readObject(inp) {\n        const serializerId = inp.readInt();\n        const serializer = this.findSerializerById(serializerId);\n        return serializer.read(inp);\n    }\n    registerSerializer(name, serializer) {\n        if (this.serializerNameToId[name]) {\n            throw new RangeError('Given serializer name is already in the registry.');\n        }\n        if (this.registry[serializer.id]) {\n            throw new RangeError('Given serializer id is already in the registry.');\n        }\n        this.serializerNameToId[name] = serializer.id;\n        this.registry[serializer.id] = serializer;\n    }\n    /**\n     * Serialization precedence\n     *  1. NULL\n     *  2. DataSerializable\n     *  3. Portable\n     *  4. Default Types\n     *      * Byte, Boolean, Character, Short, Integer, Long, Float, Double, String\n     *      * Array of [Byte, Boolean, Character, Short, Integer, Long, Float, Double, String]\n     *      * Java types [Date, BigInteger, BigDecimal, Class, Enum]\n     *  5. Custom serializers\n     *  6. Global Serializer\n     *  7. Fallback (JSON)\n     * @param obj\n     * @returns\n     */\n    findSerializerFor(obj) {\n        if (obj === undefined) {\n            throw new RangeError('undefined cannot be serialized.');\n        }\n        let serializer = null;\n        if (obj === null) {\n            serializer = this.findSerializerByName('null', false);\n        }\n        if (serializer === null) {\n            serializer = this.lookupDefaultSerializer(obj);\n        }\n        if (serializer === null) {\n            serializer = this.lookupCustomSerializer(obj);\n        }\n        if (serializer === null) {\n            serializer = this.lookupGlobalSerializer();\n        }\n        if (serializer === null) {\n            serializer = this.findSerializerByName('!json', false);\n        }\n        if (serializer === null) {\n            throw new RangeError('There is no suitable serializer for ' + obj + '.');\n        }\n        return serializer;\n    }\n    lookupDefaultSerializer(obj) {\n        let serializer = null;\n        if (this.isIdentifiedDataSerializable(obj)) {\n            return this.findSerializerByName('identified', false);\n        }\n        if (this.isPortableSerializable(obj)) {\n            return this.findSerializerByName('!portable', false);\n        }\n        const objectType = Util.getType(obj);\n        if (objectType === 'array') {\n            if (obj.length === 0) {\n                serializer = this.findSerializerByName('number', true);\n            }\n            else {\n                serializer = this.findSerializerByName(Util.getType(obj[0]), true);\n            }\n        }\n        else {\n            serializer = this.findSerializerByName(objectType, false);\n        }\n        return serializer;\n    }\n    lookupCustomSerializer(obj) {\n        if (this.isCustomSerializable(obj)) {\n            return this.findSerializerById(obj.hzCustomId);\n        }\n        return null;\n    }\n    lookupGlobalSerializer() {\n        return this.findSerializerByName('!global', false);\n    }\n    isIdentifiedDataSerializable(obj) {\n        return (obj.readData && obj.writeData\n            && typeof obj.factoryId === 'number' && typeof obj.classId === 'number');\n    }\n    isPortableSerializable(obj) {\n        return (obj.readPortable && obj.writePortable\n            && typeof obj.factoryId === 'number' && typeof obj.classId === 'number');\n    }\n    registerDefaultSerializers() {\n        this.registerSerializer('string', new DefaultSerializers_1.StringSerializer());\n        this.registerSerializer('double', new DefaultSerializers_1.DoubleSerializer());\n        this.registerSerializer('byte', new DefaultSerializers_1.ByteSerializer());\n        this.registerSerializer('boolean', new DefaultSerializers_1.BooleanSerializer());\n        this.registerSerializer('null', new DefaultSerializers_1.NullSerializer());\n        this.registerSerializer('short', new DefaultSerializers_1.ShortSerializer());\n        this.registerSerializer('integer', new DefaultSerializers_1.IntegerSerializer());\n        this.registerSerializer('long', new DefaultSerializers_1.LongSerializer());\n        this.registerSerializer('float', new DefaultSerializers_1.FloatSerializer());\n        this.registerSerializer('char', new DefaultSerializers_1.CharSerializer());\n        this.registerSerializer('date', new DefaultSerializers_1.DateSerializer());\n        this.registerSerializer('byteArray', new DefaultSerializers_1.ByteArraySerializer());\n        this.registerSerializer('charArray', new DefaultSerializers_1.CharArraySerializer());\n        this.registerSerializer('booleanArray', new DefaultSerializers_1.BooleanArraySerializer());\n        this.registerSerializer('shortArray', new DefaultSerializers_1.ShortArraySerializer());\n        this.registerSerializer('integerArray', new DefaultSerializers_1.IntegerArraySerializer());\n        this.registerSerializer('longArray', new DefaultSerializers_1.LongArraySerializer());\n        this.registerSerializer('doubleArray', new DefaultSerializers_1.DoubleArraySerializer());\n        this.registerSerializer('stringArray', new DefaultSerializers_1.StringArraySerializer());\n        this.registerSerializer('javaClass', new DefaultSerializers_1.JavaClassSerializer());\n        this.registerSerializer('floatArray', new DefaultSerializers_1.FloatArraySerializer());\n        this.registerIdentifiedFactories();\n        this.registerSerializer('!portable', new PortableSerializer_1.PortableSerializer(this.serializationConfig));\n        if (this.serializationConfig.jsonStringDeserializationPolicy === JsonStringDeserializationPolicy_1.JsonStringDeserializationPolicy.EAGER) {\n            this.registerSerializer('!json', new DefaultSerializers_1.JsonSerializer());\n        }\n        else {\n            this.registerSerializer('!json', new DefaultSerializers_1.HazelcastJsonValueSerializer());\n        }\n    }\n    registerIdentifiedFactories() {\n        const factories = {};\n        for (const id in this.serializationConfig.dataSerializableFactories) {\n            factories[id] = this.serializationConfig.dataSerializableFactories[id];\n        }\n        factories[DefaultPredicates_1.PREDICATE_FACTORY_ID] = DefaultPredicates_1.predicateFactory;\n        factories[ReliableTopicMessage_1.RELIABLE_TOPIC_MESSAGE_FACTORY_ID] = ReliableTopicMessage_1.reliableTopicMessageFactory;\n        factories[ClusterDataFactory_1.CLUSTER_DATA_FACTORY_ID] = ClusterDataFactory_1.clusterDataFactory;\n        factories[AggregatorFactory_1.AGGREGATOR_FACTORY_ID] = AggregatorFactory_1.aggregatorFactory;\n        factories[RestValue_1.REST_VALUE_FACTORY_ID] = RestValue_1.restValueFactory;\n        this.registerSerializer('identified', new DefaultSerializers_1.IdentifiedDataSerializableSerializer(factories));\n    }\n    registerCustomSerializers() {\n        const customSerializers = this.serializationConfig.customSerializers;\n        for (const key in customSerializers) {\n            const candidate = customSerializers[key];\n            this.assertValidCustomSerializer(candidate);\n            this.registerSerializer('!custom' + candidate.id, candidate);\n        }\n    }\n    registerGlobalSerializer() {\n        const candidate = this.serializationConfig.globalSerializer;\n        if (candidate == null) {\n            return;\n        }\n        this.assertValidCustomSerializer(candidate);\n        this.registerSerializer('!global', candidate);\n    }\n    assertValidCustomSerializer(candidate) {\n        const idProp = 'id';\n        const fRead = 'read';\n        const fWrite = 'write';\n        if (typeof candidate[idProp] !== 'number') {\n            throw new TypeError('Custom serializer should have ' + idProp + ' property.');\n        }\n        if (typeof candidate[fRead] !== 'function' || typeof candidate[fWrite] !== 'function') {\n            throw new TypeError('Custom serializer should have ' + fRead + ' and ' + fWrite + ' methods.');\n        }\n        const typeId = candidate[idProp];\n        if (!Number.isInteger(typeId) || typeId < 1) {\n            throw new TypeError('Custom serializer should have its typeId greater than or equal to 1.');\n        }\n    }\n    isCustomSerializable(object) {\n        const prop = 'hzCustomId';\n        return (typeof object[prop] === 'number' && object[prop] >= 1);\n    }\n    findSerializerByName(name, isArray) {\n        let convertedName;\n        if (name === 'number') {\n            convertedName = this.serializationConfig.defaultNumberType;\n        }\n        else if (name === 'buffer') {\n            convertedName = 'byteArray';\n        }\n        else {\n            convertedName = name;\n        }\n        const serializerName = convertedName + (isArray ? 'Array' : '');\n        const serializerId = this.serializerNameToId[serializerName];\n        if (serializerId == null) {\n            return null;\n        }\n        return this.findSerializerById(serializerId);\n    }\n    findSerializerById(id) {\n        const serializer = this.registry[id];\n        return serializer;\n    }\n    calculatePartitionHash(object, strategy) {\n        return strategy(object);\n    }\n}\nexports.SerializationServiceV1 = SerializationServiceV1;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/SerializationService.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/SerializationUtil.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/SerializationUtil.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeList = exports.deserializeEntryList = void 0;\n/** @internal */\nfunction deserializeEntryList(toObject, entrySet) {\n    const deserializedSet = [];\n    entrySet.forEach(function (entry) {\n        deserializedSet.push([toObject(entry[0]), toObject(entry[1])]);\n    });\n    return deserializedSet;\n}\nexports.deserializeEntryList = deserializeEntryList;\n/** @internal */\nfunction serializeList(toData, input) {\n    return input.map((each) => {\n        return toData(each);\n    });\n}\nexports.serializeList = serializeList;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/SerializationUtil.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/index.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Public API re-exports.\n */\n__exportStar(__webpack_require__(/*! ./Data */ \"../shared/node_modules/hazelcast-client/lib/serialization/Data.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Portable */ \"../shared/node_modules/hazelcast-client/lib/serialization/Portable.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Serializable */ \"../shared/node_modules/hazelcast-client/lib/serialization/Serializable.js\"), exports);\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/index.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinition.js":
/*!*********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinition.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FieldDefinition = exports.ClassDefinition = void 0;\nconst assert_1 = __webpack_require__(/*! assert */ \"assert\");\n/** @internal */\nclass ClassDefinition {\n    constructor(factoryId, classId, version) {\n        this.fields = {};\n        this.factoryId = factoryId;\n        this.classId = classId;\n        this.version = version;\n    }\n    addFieldDefinition(definition) {\n        this.fields[definition.getName()] = definition;\n    }\n    getFieldCount() {\n        return Object.keys(this.fields).length;\n    }\n    getFactoryId() {\n        return this.factoryId;\n    }\n    getClassId() {\n        return this.classId;\n    }\n    getVersion() {\n        return this.version;\n    }\n    getFieldType(name) {\n        const field = this.fields[name];\n        if (field != null) {\n            return field.getType();\n        }\n        else {\n            throw new RangeError(`Field ${field} does not exist.`);\n        }\n    }\n    hasField(name) {\n        return this.fields[name] != null;\n    }\n    getField(name) {\n        const field = this.fields[name];\n        return field || null;\n    }\n    getFieldById(index) {\n        if (!Number.isInteger(index) || index < 0 || index >= this.getFieldCount()) {\n            throw new RangeError(`Index: ${index}, fields count: ${this.getFieldCount()}.`);\n        }\n        for (const fieldName in this.fields) {\n            if (this.fields[fieldName].getIndex() === index) {\n                return this.fields[fieldName];\n            }\n        }\n        throw new RangeError(`There is no field with index ${index}`);\n    }\n    equals(o) {\n        if (!(o instanceof ClassDefinition)) {\n            return false;\n        }\n        if (o.factoryId !== this.factoryId || o.classId !== this.classId || o.version !== this.version) {\n            return false;\n        }\n        try {\n            assert_1.deepEqual(o.fields, this.fields);\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    }\n}\nexports.ClassDefinition = ClassDefinition;\n/** @internal */\nclass FieldDefinition {\n    constructor(index, fieldName, type, version, factoryId = 0, classId = 0) {\n        this.index = index;\n        this.fieldName = fieldName;\n        this.type = type;\n        this.factoryId = factoryId;\n        this.classId = classId;\n        this.version = version;\n    }\n    getType() {\n        return this.type;\n    }\n    getName() {\n        return this.fieldName;\n    }\n    getIndex() {\n        return this.index;\n    }\n    getClassId() {\n        return this.classId;\n    }\n    getFactoryId() {\n        return this.factoryId;\n    }\n    getVersion() {\n        return this.version;\n    }\n}\nexports.FieldDefinition = FieldDefinition;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinition.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionBuilder.js":
/*!****************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionBuilder.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClassDefinitionBuilder = void 0;\nconst ClassDefinition_1 = __webpack_require__(/*! ./ClassDefinition */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinition.js\");\nconst Portable_1 = __webpack_require__(/*! ../Portable */ \"../shared/node_modules/hazelcast-client/lib/serialization/Portable.js\");\nconst core_1 = __webpack_require__(/*! ../../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\n/** @internal */\nclass ClassDefinitionBuilder {\n    constructor(factoryId, classId, version = 0) {\n        this.fieldDefinitions = [];\n        this.index = 0;\n        this.factoryId = factoryId;\n        this.classId = classId;\n        this.version = version;\n    }\n    getFactoryId() {\n        return this.factoryId;\n    }\n    getClassId() {\n        return this.classId;\n    }\n    getVersion() {\n        return this.version;\n    }\n    addByteField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.BYTE, this.version));\n    }\n    addBooleanField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.BOOLEAN, this.version));\n    }\n    addCharField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.CHAR, this.version));\n    }\n    addShortField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.SHORT, this.version));\n    }\n    addIntField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.INT, this.version));\n    }\n    addLongField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.LONG, this.version));\n    }\n    addFloatField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.FLOAT, this.version));\n    }\n    addDoubleField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.DOUBLE, this.version));\n    }\n    addUTFField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.UTF, this.version));\n    }\n    addPortableField(fieldName, def) {\n        if (def.getClassId() === 0) {\n            throw new RangeError('Portable class ID cannot be zero!');\n        }\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.PORTABLE, def.getVersion(), def.getFactoryId(), def.getClassId()));\n    }\n    addByteArrayField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.BYTE_ARRAY, this.version));\n    }\n    addBooleanArrayField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.BOOLEAN_ARRAY, this.version));\n    }\n    addCharArrayField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.CHAR_ARRAY, this.version));\n    }\n    addShortArrayField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.SHORT_ARRAY, this.version));\n    }\n    addIntArrayField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.INT_ARRAY, this.version));\n    }\n    addLongArrayField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.LONG_ARRAY, this.version));\n    }\n    addFloatArrayField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.FLOAT_ARRAY, this.version));\n    }\n    addDoubleArrayField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.DOUBLE_ARRAY, this.version));\n    }\n    addUTFArrayField(fieldName) {\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.UTF_ARRAY, this.version));\n    }\n    addPortableArrayField(fieldName, def) {\n        if (def.getClassId() === 0) {\n            throw new RangeError('Portable class ID cannot be zero!');\n        }\n        return this.addField(new ClassDefinition_1.FieldDefinition(this.index, fieldName, Portable_1.FieldType.PORTABLE_ARRAY, def.getVersion(), def.getFactoryId(), def.getClassId()));\n    }\n    addField(fieldDefinition) {\n        if (this.done) {\n            throw new core_1.HazelcastSerializationError(`ClassDefinition is already built for ${this.classId}`);\n        }\n        if (this.index !== fieldDefinition.getIndex()) {\n            throw new RangeError('Invalid field index');\n        }\n        this.fieldDefinitions.push(fieldDefinition);\n        this.index++;\n        return this;\n    }\n    build() {\n        this.done = true;\n        const cd = new ClassDefinition_1.ClassDefinition(this.factoryId, this.classId, this.version);\n        for (const fd of this.fieldDefinitions) {\n            cd.addFieldDefinition(fd);\n        }\n        return cd;\n    }\n}\nexports.ClassDefinitionBuilder = ClassDefinitionBuilder;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionBuilder.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionContext.js":
/*!****************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionContext.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClassDefinitionContext = void 0;\nconst core_1 = __webpack_require__(/*! ../../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\n/** @internal */\nclass ClassDefinitionContext {\n    constructor(factoryId) {\n        this.factoryId = factoryId;\n        this.classDefs = {};\n    }\n    static encodeVersionedClassId(classId, version) {\n        return classId + 'v' + version;\n    }\n    lookup(classId, version) {\n        const encoded = ClassDefinitionContext.encodeVersionedClassId(classId, version);\n        return this.classDefs[encoded];\n    }\n    register(classDefinition) {\n        if (classDefinition === null) {\n            return null;\n        }\n        if (classDefinition.getFactoryId() !== this.factoryId) {\n            throw new core_1.HazelcastSerializationError(`This factory's number is ${this.factoryId}.\n            Intended factory id is ${classDefinition.getFactoryId()}`);\n        }\n        const cdKey = ClassDefinitionContext.encodeVersionedClassId(classDefinition.getClassId(), classDefinition.getVersion());\n        const current = this.classDefs[cdKey];\n        if (current == null) {\n            this.classDefs[cdKey] = classDefinition;\n            return classDefinition;\n        }\n        if (!current.equals(classDefinition)) {\n            throw new core_1.HazelcastSerializationError('Incompatible class definition with same class id: '\n                + classDefinition.getClassId());\n        }\n        return classDefinition;\n    }\n}\nexports.ClassDefinitionContext = ClassDefinitionContext;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionContext.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionWriter.js":
/*!***************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionWriter.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClassDefinitionWriter = void 0;\nconst ClassDefinitionBuilder_1 = __webpack_require__(/*! ./ClassDefinitionBuilder */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionBuilder.js\");\nconst core_1 = __webpack_require__(/*! ../../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\n/** @internal */\nclass ClassDefinitionWriter {\n    constructor(context, builder) {\n        this.context = context;\n        this.builder = builder;\n    }\n    writeInt(fieldName, value) {\n        this.builder.addIntField(fieldName);\n    }\n    writeLong(fieldName, long) {\n        this.builder.addLongField(fieldName);\n    }\n    writeUTF(fieldName, str) {\n        this.builder.addUTFField(fieldName);\n    }\n    writeBoolean(fieldName, value) {\n        this.builder.addBooleanField(fieldName);\n    }\n    writeByte(fieldName, value) {\n        this.builder.addByteField(fieldName);\n    }\n    writeChar(fieldName, char) {\n        this.builder.addCharField(fieldName);\n    }\n    writeDouble(fieldName, double) {\n        this.builder.addDoubleField(fieldName);\n    }\n    writeFloat(fieldName, float) {\n        this.builder.addFloatField(fieldName);\n    }\n    writeShort(fieldName, value) {\n        this.builder.addShortField(fieldName);\n    }\n    writePortable(fieldName, portable) {\n        if (portable == null) {\n            throw new core_1.HazelcastSerializationError('Cannot write null portable without explicitly '\n                + 'registering class definition!');\n        }\n        const version = this.context.getClassVersion(portable);\n        const nestedClassDef = this.createNestedClassDef(portable, new ClassDefinitionBuilder_1.ClassDefinitionBuilder(portable.factoryId, portable.classId, version));\n        this.builder.addPortableField(fieldName, nestedClassDef);\n    }\n    writeNullPortable(fieldName, factoryId, classId) {\n        const nestedClassDef = this.context.lookupClassDefinition(factoryId, classId, this.context.getVersion());\n        if (nestedClassDef == null) {\n            throw new core_1.HazelcastSerializationError('Cannot write null portable without explicitly '\n                + 'registering class definition!');\n        }\n        this.builder.addPortableField(fieldName, nestedClassDef);\n    }\n    writeByteArray(fieldName, bytes) {\n        this.builder.addByteArrayField(fieldName);\n    }\n    writeBooleanArray(fieldName, booleans) {\n        this.builder.addBooleanArrayField(fieldName);\n    }\n    writeCharArray(fieldName, chars) {\n        this.builder.addCharArrayField(fieldName);\n    }\n    writeIntArray(fieldName, ints) {\n        this.builder.addIntArrayField(fieldName);\n    }\n    writeLongArray(fieldName, longs) {\n        this.builder.addLongArrayField(fieldName);\n    }\n    writeDoubleArray(fieldName, doubles) {\n        this.builder.addDoubleArrayField(fieldName);\n    }\n    writeFloatArray(fieldName, floats) {\n        this.builder.addFloatArrayField(fieldName);\n    }\n    writeShortArray(fieldName, shorts) {\n        this.builder.addShortArrayField(fieldName);\n    }\n    writeUTFArray(fieldName, val) {\n        this.builder.addUTFArrayField(fieldName);\n    }\n    writePortableArray(fieldName, portables) {\n        if (portables == null || portables.length === 0) {\n            throw new core_1.HazelcastSerializationError('Cannot write null portable array without explicitly '\n                + 'registering class definition!');\n        }\n        const portable = portables[0];\n        const classId = portable.classId;\n        for (let i = 1; i < portables.length; i++) {\n            if (portables[i].classId !== classId) {\n                throw new RangeError('Detected different class-ids in portable array!');\n            }\n        }\n        const version = this.context.getClassVersion(portable);\n        const nestedClassDef = this.createNestedClassDef(portable, new ClassDefinitionBuilder_1.ClassDefinitionBuilder(portable.factoryId, portable.classId, version));\n        this.builder.addPortableArrayField(fieldName, nestedClassDef);\n    }\n    registerAndGet() {\n        const cd = this.builder.build();\n        return this.context.registerClassDefinition(cd);\n    }\n    createNestedClassDef(portable, nestedBuilder) {\n        const writer = new ClassDefinitionWriter(this.context, nestedBuilder);\n        portable.writePortable(writer);\n        return this.context.registerClassDefinition(nestedBuilder.build());\n    }\n}\nexports.ClassDefinitionWriter = ClassDefinitionWriter;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionWriter.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/portable/DefaultPortableReader.js":
/*!***************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/portable/DefaultPortableReader.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultPortableReader = void 0;\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst core_1 = __webpack_require__(/*! ../../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\nconst Portable_1 = __webpack_require__(/*! ../Portable */ \"../shared/node_modules/hazelcast-client/lib/serialization/Portable.js\");\n/** @internal */\nclass DefaultPortableReader {\n    constructor(serializer, input, classDefinition) {\n        this.raw = false;\n        this.serializer = serializer;\n        this.input = input;\n        this.classDefinition = classDefinition;\n        this.initFinalPositionAndOffset();\n    }\n    getVersion() {\n        return this.classDefinition.getVersion();\n    }\n    hasField(fieldName) {\n        return this.classDefinition.hasField(fieldName);\n    }\n    getFieldNames() {\n        throw new ReferenceError('Not implemented!');\n    }\n    getFieldType(fieldName) {\n        return this.classDefinition.getFieldType(fieldName);\n    }\n    readInt(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.INT);\n        return this.input.readInt(pos);\n    }\n    readLong(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.LONG);\n        return this.input.readLong(pos);\n    }\n    readUTF(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.UTF);\n        return this.input.readUTF(pos);\n    }\n    readBoolean(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.BOOLEAN);\n        return this.input.readBoolean(pos);\n    }\n    readByte(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.BYTE);\n        return this.input.readByte(pos);\n    }\n    readChar(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.CHAR);\n        return this.input.readChar(pos);\n    }\n    readDouble(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.DOUBLE);\n        return this.input.readDouble(pos);\n    }\n    readFloat(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.FLOAT);\n        return this.input.readFloat(pos);\n    }\n    readShort(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.SHORT);\n        return this.input.readShort(pos);\n    }\n    readPortable(fieldName) {\n        const backupPos = this.input.position();\n        try {\n            const pos = this.positionByField(fieldName, Portable_1.FieldType.PORTABLE);\n            this.input.position(pos);\n            const isNull = this.input.readBoolean();\n            const factoryId = this.input.readInt();\n            const classId = this.input.readInt();\n            if (isNull) {\n                return null;\n            }\n            else {\n                return this.serializer.readObject(this.input, factoryId, classId);\n            }\n        }\n        finally {\n            this.input.position(backupPos);\n        }\n    }\n    readByteArray(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.BYTE_ARRAY);\n        return this.input.readByteArray(pos);\n    }\n    readBooleanArray(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.BOOLEAN_ARRAY);\n        return this.input.readBooleanArray(pos);\n    }\n    readCharArray(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.CHAR_ARRAY);\n        return this.input.readCharArray(pos);\n    }\n    readIntArray(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.INT_ARRAY);\n        return this.input.readIntArray(pos);\n    }\n    readLongArray(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.LONG_ARRAY);\n        return this.input.readLongArray(pos);\n    }\n    readDoubleArray(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.DOUBLE_ARRAY);\n        return this.input.readDoubleArray(pos);\n    }\n    readFloatArray(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.FLOAT_ARRAY);\n        return this.input.readFloatArray(pos);\n    }\n    readShortArray(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.SHORT_ARRAY);\n        return this.input.readShortArray(pos);\n    }\n    readUTFArray(fieldName) {\n        const pos = this.positionByField(fieldName, Portable_1.FieldType.UTF_ARRAY);\n        return this.input.readUTFArray(pos);\n    }\n    readPortableArray(fieldName) {\n        const backupPos = this.input.position();\n        try {\n            const pos = this.positionByField(fieldName, Portable_1.FieldType.PORTABLE_ARRAY);\n            this.input.position(pos);\n            const len = this.input.readInt();\n            const factoryId = this.input.readInt();\n            const classId = this.input.readInt();\n            if (len === BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH) {\n                return null;\n            }\n            else {\n                const portables = [];\n                if (len > 0) {\n                    const offset = this.input.position();\n                    for (let i = 0; i < len; i++) {\n                        const start = this.input.readInt(offset + i * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n                        this.input.position(start);\n                        portables[i] = this.serializer.readObject(this.input, factoryId, classId);\n                    }\n                }\n                return portables;\n            }\n        }\n        finally {\n            this.input.position(backupPos);\n        }\n    }\n    getRawDataInput() {\n        let pos;\n        if (!this.raw) {\n            pos = this.input.readInt(this.offset + this.classDefinition.getFieldCount() * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n            this.input.position(pos);\n            this.raw = true;\n        }\n        return this.input;\n    }\n    end() {\n        this.input.position(this.finalPos);\n    }\n    positionByFieldDefinition(field) {\n        if (this.raw) {\n            throw new core_1.IllegalStateError('Cannot read portable fields after getRawDataInput called!');\n        }\n        const pos = this.input.readInt(this.offset + field.getIndex() * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n        const len = this.input.readShort(pos);\n        return pos + BitsUtil_1.BitsUtil.SHORT_SIZE_IN_BYTES + len + 1;\n    }\n    positionByField(fieldName, fieldType) {\n        const definition = this.classDefinition.getField(fieldName);\n        return this.positionByFieldDefinition(definition);\n    }\n    initFinalPositionAndOffset() {\n        this.finalPos = this.input.readInt();\n        const fieldCount = this.input.readInt();\n        const expectedFieldCount = this.classDefinition.getFieldCount();\n        if (fieldCount !== expectedFieldCount) {\n            // eslint-disable-next-line max-len\n            throw new core_1.IllegalStateError(`Field count[${fieldCount}] in stream does not match with class definition[${expectedFieldCount}]`);\n        }\n        this.offset = this.input.position();\n    }\n}\nexports.DefaultPortableReader = DefaultPortableReader;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/portable/DefaultPortableReader.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/portable/DefaultPortableWriter.js":
/*!***************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/portable/DefaultPortableWriter.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultPortableWriter = void 0;\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst Portable_1 = __webpack_require__(/*! ../Portable */ \"../shared/node_modules/hazelcast-client/lib/serialization/Portable.js\");\n/** @internal */\nclass DefaultPortableWriter {\n    constructor(serializer, output, classDefinition) {\n        this.serializer = serializer;\n        this.output = output;\n        this.classDefinition = classDefinition;\n        this.begin = this.output.position();\n        this.output.writeZeroBytes(4);\n        this.output.writeInt(this.classDefinition.getFieldCount());\n        this.offset = this.output.position();\n        const fieldIndexesLength = (this.classDefinition.getFieldCount() + 1) * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES;\n        this.output.writeZeroBytes(fieldIndexesLength);\n    }\n    writeInt(fieldName, value) {\n        this.setPosition(fieldName, Portable_1.FieldType.INT);\n        this.output.writeInt(value);\n    }\n    writeLong(fieldName, long) {\n        this.setPosition(fieldName, Portable_1.FieldType.LONG);\n        this.output.writeLong(long);\n    }\n    writeUTF(fieldName, str) {\n        this.setPosition(fieldName, Portable_1.FieldType.UTF);\n        this.output.writeUTF(str);\n    }\n    writeBoolean(fieldName, value) {\n        this.setPosition(fieldName, Portable_1.FieldType.BOOLEAN);\n        this.output.writeBoolean(value);\n    }\n    writeByte(fieldName, value) {\n        this.setPosition(fieldName, Portable_1.FieldType.BYTE);\n        this.output.writeByte(value);\n    }\n    writeChar(fieldName, char) {\n        this.setPosition(fieldName, Portable_1.FieldType.CHAR);\n        this.output.writeChar(char);\n    }\n    writeDouble(fieldName, double) {\n        this.setPosition(fieldName, Portable_1.FieldType.DOUBLE);\n        this.output.writeDouble(double);\n    }\n    writeFloat(fieldName, float) {\n        this.setPosition(fieldName, Portable_1.FieldType.FLOAT);\n        this.output.writeFloat(float);\n    }\n    writeShort(fieldName, value) {\n        this.setPosition(fieldName, Portable_1.FieldType.SHORT);\n        this.output.writeShort(value);\n    }\n    writePortable(fieldName, portable) {\n        const fieldDefinition = this.setPosition(fieldName, Portable_1.FieldType.PORTABLE);\n        const isNullPortable = (portable == null);\n        this.output.writeBoolean(isNullPortable);\n        this.output.writeInt(fieldDefinition.getFactoryId());\n        this.output.writeInt(fieldDefinition.getClassId());\n        if (!isNullPortable) {\n            this.serializer.writeObject(this.output, portable);\n        }\n    }\n    writeNullPortable(fieldName, factoryId, classId) {\n        this.setPosition(fieldName, Portable_1.FieldType.PORTABLE);\n        this.output.writeBoolean(true);\n        this.output.writeInt(factoryId);\n        this.output.writeInt(classId);\n    }\n    writeByteArray(fieldName, bytes) {\n        this.setPosition(fieldName, Portable_1.FieldType.BYTE_ARRAY);\n        this.output.writeByteArray(bytes);\n    }\n    writeBooleanArray(fieldName, booleans) {\n        this.setPosition(fieldName, Portable_1.FieldType.BOOLEAN_ARRAY);\n        this.output.writeBooleanArray(booleans);\n    }\n    writeCharArray(fieldName, chars) {\n        this.setPosition(fieldName, Portable_1.FieldType.CHAR_ARRAY);\n        this.output.writeCharArray(chars);\n    }\n    writeIntArray(fieldName, ints) {\n        this.setPosition(fieldName, Portable_1.FieldType.INT_ARRAY);\n        this.output.writeIntArray(ints);\n    }\n    writeLongArray(fieldName, longs) {\n        this.setPosition(fieldName, Portable_1.FieldType.LONG_ARRAY);\n        this.output.writeLongArray(longs);\n    }\n    writeDoubleArray(fieldName, doubles) {\n        this.setPosition(fieldName, Portable_1.FieldType.DOUBLE_ARRAY);\n        this.output.writeDoubleArray(doubles);\n    }\n    writeFloatArray(fieldName, floats) {\n        this.setPosition(fieldName, Portable_1.FieldType.FLOAT_ARRAY);\n        this.output.writeFloatArray(floats);\n    }\n    writeShortArray(fieldName, shorts) {\n        this.setPosition(fieldName, Portable_1.FieldType.SHORT_ARRAY);\n        this.output.writeShortArray(shorts);\n    }\n    writeUTFArray(fieldName, val) {\n        this.setPosition(fieldName, Portable_1.FieldType.UTF_ARRAY);\n        this.output.writeUTFArray(val);\n    }\n    writePortableArray(fieldName, portables) {\n        let innerOffset;\n        let sample;\n        let i;\n        const fieldDefinition = this.setPosition(fieldName, Portable_1.FieldType.PORTABLE_ARRAY);\n        const len = (portables == null) ? BitsUtil_1.BitsUtil.NULL_ARRAY_LENGTH : portables.length;\n        this.output.writeInt(len);\n        this.output.writeInt(fieldDefinition.getFactoryId());\n        this.output.writeInt(fieldDefinition.getClassId());\n        if (len > 0) {\n            innerOffset = this.output.position();\n            this.output.writeZeroBytes(len * 4);\n            for (i = 0; i < len; i++) {\n                sample = portables[i];\n                const posVal = this.output.position();\n                this.output.pwriteInt(innerOffset + i * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, posVal);\n                this.serializer.writeObject(this.output, sample);\n            }\n        }\n    }\n    end() {\n        const position = this.output.position();\n        this.output.pwriteInt(this.begin, position);\n    }\n    setPosition(fieldName, fieldType) {\n        const field = this.classDefinition.getField(fieldName);\n        const pos = this.output.position();\n        const index = field.getIndex();\n        this.output.pwriteInt(this.offset + index * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, pos);\n        this.output.writeShort(fieldName.length);\n        this.output.write(Buffer.from(fieldName));\n        this.output.writeByte(fieldType);\n        return field;\n    }\n}\nexports.DefaultPortableWriter = DefaultPortableWriter;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/portable/DefaultPortableWriter.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/portable/MorphingPortableReader.js":
/*!****************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/portable/MorphingPortableReader.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MorphingPortableReader = void 0;\nconst DefaultPortableReader_1 = __webpack_require__(/*! ./DefaultPortableReader */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/DefaultPortableReader.js\");\nconst Portable_1 = __webpack_require__(/*! ../Portable */ \"../shared/node_modules/hazelcast-client/lib/serialization/Portable.js\");\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\n/** @internal */\nclass MorphingPortableReader extends DefaultPortableReader_1.DefaultPortableReader {\n    constructor(portableSerializer, input, classDefinition) {\n        super(portableSerializer, input, classDefinition);\n    }\n    readInt(fieldName) {\n        const fieldDef = this.classDefinition.getField(fieldName);\n        if (fieldDef == null) {\n            return undefined;\n        }\n        switch (fieldDef.getType()) {\n            case Portable_1.FieldType.INT:\n                return super.readInt(fieldName);\n            case Portable_1.FieldType.BYTE:\n                return super.readByte(fieldName);\n            case Portable_1.FieldType.CHAR:\n                return super.readChar(fieldName).charCodeAt(0);\n            case Portable_1.FieldType.SHORT:\n                return super.readShort(fieldName);\n            default:\n                throw this.createIncompatibleClassChangeError(fieldDef, Portable_1.FieldType.INT);\n        }\n    }\n    readLong(fieldName) {\n        const fieldDef = this.classDefinition.getField(fieldName);\n        if (fieldDef == null) {\n            return undefined;\n        }\n        switch (fieldDef.getType()) {\n            case Portable_1.FieldType.LONG:\n                return super.readLong(fieldName);\n            case Portable_1.FieldType.INT:\n                return Long.fromNumber(super.readInt(fieldName));\n            case Portable_1.FieldType.BYTE:\n                return Long.fromNumber(super.readByte(fieldName));\n            case Portable_1.FieldType.CHAR:\n                return Long.fromNumber(super.readChar(fieldName).charCodeAt(0));\n            case Portable_1.FieldType.SHORT:\n                return Long.fromNumber(super.readShort(fieldName));\n            default:\n                throw this.createIncompatibleClassChangeError(fieldDef, Portable_1.FieldType.LONG);\n        }\n    }\n    readDouble(fieldName) {\n        const fieldDef = this.classDefinition.getField(fieldName);\n        if (fieldDef == null) {\n            return undefined;\n        }\n        switch (fieldDef.getType()) {\n            case Portable_1.FieldType.DOUBLE:\n                return super.readDouble(fieldName);\n            case Portable_1.FieldType.LONG:\n                return super.readLong(fieldName).toNumber();\n            case Portable_1.FieldType.FLOAT:\n                return super.readFloat(fieldName);\n            case Portable_1.FieldType.INT:\n                return super.readInt(fieldName);\n            case Portable_1.FieldType.BYTE:\n                return super.readByte(fieldName);\n            case Portable_1.FieldType.CHAR:\n                return super.readChar(fieldName).charCodeAt(0);\n            case Portable_1.FieldType.SHORT:\n                return super.readShort(fieldName);\n            default:\n                throw this.createIncompatibleClassChangeError(fieldDef, Portable_1.FieldType.DOUBLE);\n        }\n    }\n    readFloat(fieldName) {\n        const fieldDef = this.classDefinition.getField(fieldName);\n        if (fieldDef == null) {\n            return undefined;\n        }\n        switch (fieldDef.getType()) {\n            case Portable_1.FieldType.FLOAT:\n                return super.readFloat(fieldName);\n            case Portable_1.FieldType.INT:\n                return super.readInt(fieldName);\n            case Portable_1.FieldType.BYTE:\n                return super.readByte(fieldName);\n            case Portable_1.FieldType.CHAR:\n                return super.readChar(fieldName).charCodeAt(0);\n            case Portable_1.FieldType.SHORT:\n                return super.readShort(fieldName);\n            default:\n                throw this.createIncompatibleClassChangeError(fieldDef, Portable_1.FieldType.FLOAT);\n        }\n    }\n    readShort(fieldName) {\n        const fieldDef = this.classDefinition.getField(fieldName);\n        if (fieldDef == null) {\n            return undefined;\n        }\n        switch (fieldDef.getType()) {\n            case Portable_1.FieldType.BYTE:\n                return super.readByte(fieldName);\n            case Portable_1.FieldType.SHORT:\n                return super.readShort(fieldName);\n            default:\n                throw this.createIncompatibleClassChangeError(fieldDef, Portable_1.FieldType.SHORT);\n        }\n    }\n    readPortableArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.PORTABLE_ARRAY, super.readPortableArray);\n    }\n    readUTFArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.UTF_ARRAY, super.readUTFArray);\n    }\n    readShortArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.SHORT_ARRAY, super.readShortArray);\n    }\n    readFloatArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.FLOAT_ARRAY, super.readFloatArray);\n    }\n    readDoubleArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.DOUBLE_ARRAY, super.readDoubleArray);\n    }\n    readLongArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.LONG_ARRAY, super.readLongArray);\n    }\n    readIntArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.INT_ARRAY, super.readIntArray);\n    }\n    readCharArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.CHAR_ARRAY, super.readCharArray);\n    }\n    readBooleanArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.BOOLEAN_ARRAY, super.readBooleanArray);\n    }\n    readByteArray(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.BYTE_ARRAY, super.readByteArray);\n    }\n    readChar(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.CHAR, super.readChar);\n    }\n    readByte(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.BYTE, super.readByte);\n    }\n    readBoolean(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.BOOLEAN, super.readBoolean);\n    }\n    readUTF(fieldName) {\n        return this.validateCompatibleAndRead(fieldName, Portable_1.FieldType.UTF, super.readUTF);\n    }\n    validateCompatibleAndRead(fieldName, expectedType, readFn) {\n        const fd = this.classDefinition.getField(fieldName);\n        if (fd === null) {\n            return undefined;\n        }\n        if (fd.getType() !== expectedType) {\n            throw this.createIncompatibleClassChangeError(fd, expectedType);\n        }\n        return readFn.call(this, fieldName);\n    }\n    createIncompatibleClassChangeError(fd, expectedType) {\n        return new TypeError(`Incompatible to read ${expectedType} from ${fd.getType()} while reading field : ${fd.getName()}`);\n    }\n}\nexports.MorphingPortableReader = MorphingPortableReader;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/portable/MorphingPortableReader.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/portable/PortableContext.js":
/*!*********************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/portable/PortableContext.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PortableContext = void 0;\nconst ClassDefinitionContext_1 = __webpack_require__(/*! ./ClassDefinitionContext */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionContext.js\");\nconst ClassDefinition_1 = __webpack_require__(/*! ./ClassDefinition */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinition.js\");\nconst ClassDefinitionWriter_1 = __webpack_require__(/*! ./ClassDefinitionWriter */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionWriter.js\");\nconst BitsUtil_1 = __webpack_require__(/*! ../../util/BitsUtil */ \"../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js\");\nconst Portable_1 = __webpack_require__(/*! ../Portable */ \"../shared/node_modules/hazelcast-client/lib/serialization/Portable.js\");\nconst ClassDefinitionBuilder_1 = __webpack_require__(/*! ./ClassDefinitionBuilder */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/ClassDefinitionBuilder.js\");\n/** @internal */\nclass PortableContext {\n    constructor(portableVersion) {\n        this.version = portableVersion;\n        this.classDefContext = {};\n    }\n    getVersion() {\n        return this.version;\n    }\n    readClassDefinitionFromInput(input, factoryId, classId, version) {\n        let register = true;\n        const builder = new ClassDefinitionBuilder_1.ClassDefinitionBuilder(factoryId, classId, version);\n        input.readInt();\n        const fieldCount = input.readInt();\n        const offset = input.position();\n        for (let i = 0; i < fieldCount; i++) {\n            const pos = input.readInt(offset + i * BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES);\n            input.position(pos);\n            const len = input.readShort();\n            let chars = '';\n            for (let j = 0; j < len; j++) {\n                chars += String.fromCharCode(input.readUnsignedByte());\n            }\n            const type = input.readByte();\n            const name = chars;\n            let fieldFactoryId = 0;\n            let fieldClassId = 0;\n            let fieldVersion = this.version;\n            if (type === Portable_1.FieldType.PORTABLE) {\n                // is null\n                if (input.readBoolean()) {\n                    register = false;\n                }\n                fieldFactoryId = input.readInt();\n                fieldClassId = input.readInt();\n                // TODO: what if there's a null inner Portable field\n                if (register) {\n                    fieldVersion = input.readInt();\n                    this.readClassDefinitionFromInput(input, fieldFactoryId, fieldClassId, fieldVersion);\n                }\n            }\n            else if (type === Portable_1.FieldType.PORTABLE_ARRAY) {\n                const k = input.readInt();\n                fieldFactoryId = input.readInt();\n                fieldClassId = input.readInt();\n                // TODO: what if there's a null inner Portable field\n                if (k > 0) {\n                    const p = input.readInt();\n                    input.position(p);\n                    fieldVersion = input.readInt();\n                    this.readClassDefinitionFromInput(input, fieldFactoryId, fieldClassId, fieldVersion);\n                }\n                else {\n                    register = false;\n                }\n            }\n            builder.addField(new ClassDefinition_1.FieldDefinition(i, name, type, fieldVersion, fieldFactoryId, fieldClassId));\n        }\n        let classDefinition = builder.build();\n        if (register) {\n            classDefinition = this.registerClassDefinition(classDefinition);\n        }\n        return classDefinition;\n    }\n    lookupOrRegisterClassDefinition(portable) {\n        const portableVersion = this.getClassVersion(portable);\n        let cd = this.lookupClassDefinition(portable.factoryId, portable.classId, portableVersion);\n        if (cd == null) {\n            const writer = new ClassDefinitionWriter_1.ClassDefinitionWriter(this, new ClassDefinitionBuilder_1.ClassDefinitionBuilder(portable.factoryId, portable.classId, portableVersion));\n            portable.writePortable(writer);\n            cd = writer.registerAndGet();\n        }\n        return cd;\n    }\n    lookupClassDefinition(factoryId, classId, version) {\n        const factory = this.classDefContext[factoryId];\n        if (factory == null) {\n            return null;\n        }\n        else {\n            return factory.lookup(classId, version);\n        }\n    }\n    registerClassDefinition(classDefinition) {\n        const factoryId = classDefinition.getFactoryId();\n        if (!this.classDefContext[factoryId]) {\n            this.classDefContext[factoryId] = new ClassDefinitionContext_1.ClassDefinitionContext(factoryId);\n        }\n        return this.classDefContext[factoryId].register(classDefinition);\n    }\n    getClassVersion(portable) {\n        if (typeof portable.version === 'number') {\n            if (portable.version < 0) {\n                throw new RangeError('Version cannot be negative!');\n            }\n            return portable.version;\n        }\n        else {\n            return this.version;\n        }\n    }\n}\nexports.PortableContext = PortableContext;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/portable/PortableContext.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/serialization/portable/PortableSerializer.js":
/*!************************************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/serialization/portable/PortableSerializer.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PortableSerializer = void 0;\nconst PortableContext_1 = __webpack_require__(/*! ./PortableContext */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/PortableContext.js\");\nconst DefaultPortableReader_1 = __webpack_require__(/*! ./DefaultPortableReader */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/DefaultPortableReader.js\");\nconst MorphingPortableReader_1 = __webpack_require__(/*! ./MorphingPortableReader */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/MorphingPortableReader.js\");\nconst DefaultPortableWriter_1 = __webpack_require__(/*! ./DefaultPortableWriter */ \"../shared/node_modules/hazelcast-client/lib/serialization/portable/DefaultPortableWriter.js\");\nconst core_1 = __webpack_require__(/*! ../../core */ \"../shared/node_modules/hazelcast-client/lib/core/index.js\");\n/** @internal */\nclass PortableSerializer {\n    constructor(serializationConfig) {\n        this.id = -1;\n        this.portableContext = new PortableContext_1.PortableContext(serializationConfig.portableVersion);\n        this.factories = serializationConfig.portableFactories;\n    }\n    read(input) {\n        const factoryId = input.readInt();\n        const classId = input.readInt();\n        return this.readObject(input, factoryId, classId);\n    }\n    readObject(input, factoryId, classId) {\n        const version = input.readInt();\n        const portable = this.createNewPortableInstance(factoryId, classId);\n        let classDefinition = this.portableContext.lookupClassDefinition(factoryId, classId, version);\n        if (classDefinition == null) {\n            const backupPos = input.position();\n            try {\n                classDefinition = this.portableContext.readClassDefinitionFromInput(input, factoryId, classId, version);\n            }\n            finally {\n                input.position(backupPos);\n            }\n        }\n        let reader;\n        if (classDefinition.getVersion() === this.portableContext.getClassVersion(portable)) {\n            reader = new DefaultPortableReader_1.DefaultPortableReader(this, input, classDefinition);\n        }\n        else {\n            reader = new MorphingPortableReader_1.MorphingPortableReader(this, input, classDefinition);\n        }\n        portable.readPortable(reader);\n        reader.end();\n        return portable;\n    }\n    write(output, object) {\n        output.writeInt(object.factoryId);\n        output.writeInt(object.classId);\n        this.writeObject(output, object);\n    }\n    writeObject(output, object) {\n        const cd = this.portableContext.lookupOrRegisterClassDefinition(object);\n        output.writeInt(cd.getVersion());\n        const writer = new DefaultPortableWriter_1.DefaultPortableWriter(this, output, cd);\n        object.writePortable(writer);\n        writer.end();\n    }\n    createNewPortableInstance(factoryId, classId) {\n        const factoryFn = this.factories[factoryId];\n        if (factoryFn == null) {\n            throw new core_1.HazelcastSerializationError(`There is no suitable portable factory for ${factoryId}.`);\n        }\n        const portable = factoryFn(classId);\n        if (portable == null) {\n            throw new core_1.HazelcastSerializationError(`Could not create Portable for class-id: ${classId}`);\n        }\n        return portable;\n    }\n}\nexports.PortableSerializer = PortableSerializer;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/serialization/portable/PortableSerializer.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/statistics/Statistics.js":
/*!****************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/statistics/Statistics.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Statistics = void 0;\nconst ClientStatisticsCodec_1 = __webpack_require__(/*! ../codec/ClientStatisticsCodec */ \"../shared/node_modules/hazelcast-client/lib/codec/ClientStatisticsCodec.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst BuildInfo_1 = __webpack_require__(/*! ../BuildInfo */ \"../shared/node_modules/hazelcast-client/lib/BuildInfo.js\");\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\n/**\n * This class is the main entry point for collecting and sending the client\n * statistics to the cluster. If the client statistics feature is enabled,\n * it will be scheduled for periodic statistics collection and sent.\n * @internal\n */\nclass Statistics {\n    constructor(clientInstance) {\n        this.allGauges = {};\n        this.properties = clientInstance.getConfig().properties;\n        this.enabled = this.properties[Statistics.ENABLED];\n        this.client = clientInstance;\n        this.logger = this.client.getLoggingService().getLogger();\n    }\n    /**\n     * Registers all client statistics and schedules periodic collection of stats.\n     */\n    start() {\n        if (!this.enabled) {\n            return;\n        }\n        this.registerMetrics();\n        let periodSeconds = this.properties[Statistics.PERIOD_SECONDS];\n        if (periodSeconds <= 0) {\n            const defaultValue = Statistics.PERIOD_SECONDS_DEFAULT_VALUE;\n            this.logger.warn('Statistics', 'Provided client statistics ' + Statistics.PERIOD_SECONDS\n                + ' can not be less than or equal to 0. You provided ' + periodSeconds\n                + ' seconds as the configuration. Client will use the default value of ' + defaultValue + ' instead.');\n            periodSeconds = defaultValue;\n        }\n        this.task = this.schedulePeriodicStatisticsSendTask(periodSeconds);\n        this.logger.info('Statistics', 'Client statistics is enabled with period ' + periodSeconds + ' seconds.');\n    }\n    stop() {\n        if (this.task != null) {\n            Util_1.cancelRepetitionTask(this.task);\n        }\n    }\n    /**\n     * @param periodSeconds the interval at which the statistics collection and send is being run\n     */\n    schedulePeriodicStatisticsSendTask(periodSeconds) {\n        return Util_1.scheduleWithRepetition(() => {\n            const collectionTimestamp = Long.fromNumber(Date.now());\n            const connection = this.client.getConnectionManager().getRandomConnection();\n            if (connection == null) {\n                this.logger.trace('Statistics', 'Can not send client statistics to the server. No connection found.');\n                return;\n            }\n            const stats = [];\n            this.fillMetrics(stats, connection);\n            this.addNearCacheStats(stats);\n            this.sendStats(collectionTimestamp, stats.join(''), connection);\n        }, 0, periodSeconds * 1000);\n    }\n    sendStats(collectionTimestamp, newStats, connection) {\n        const request = ClientStatisticsCodec_1.ClientStatisticsCodec.encodeRequest(collectionTimestamp, newStats, Buffer.allocUnsafe(0));\n        this.client.getInvocationService()\n            .invokeOnConnection(connection, request)\n            .catch((err) => {\n            this.logger.trace('Statistics', 'Could not send stats ', err);\n        });\n    }\n    registerMetrics() {\n        this.registerGauge('os.committedVirtualMemorySize', () => Statistics.EMPTY_STAT_VALUE);\n        this.registerGauge('os.freePhysicalMemorySize', () => os.freemem());\n        this.registerGauge('os.freeSwapSpaceSize', () => Statistics.EMPTY_STAT_VALUE);\n        this.registerGauge('os.maxFileDescriptorCount', () => Statistics.EMPTY_STAT_VALUE);\n        this.registerGauge('os.openFileDescriptorCount', () => Statistics.EMPTY_STAT_VALUE);\n        this.registerGauge('os.processCpuTime', () => {\n            // process.cpuUsage returns micoseconds. We convert to nanoseconds\n            return process.cpuUsage().user * 1000;\n        });\n        this.registerGauge('os.systemLoadAverage', () => os.loadavg()[0]);\n        this.registerGauge('os.totalPhysicalMemorySize', () => os.totalmem());\n        this.registerGauge('os.totalSwapSpaceSize', () => Statistics.EMPTY_STAT_VALUE);\n        this.registerGauge('runtime.availableProcessors', () => os.cpus().length);\n        this.registerGauge('runtime.freeMemory', () => Statistics.EMPTY_STAT_VALUE);\n        this.registerGauge('runtime.maxMemory', () => Statistics.EMPTY_STAT_VALUE);\n        this.registerGauge('runtime.totalMemory', () => process.memoryUsage().heapTotal);\n        this.registerGauge('runtime.uptime', () => process.uptime() * 1000);\n        this.registerGauge('runtime.usedMemory', () => process.memoryUsage().heapUsed);\n        this.registerGauge('executionService.userExecutorQueueSize', () => Statistics.EMPTY_STAT_VALUE);\n    }\n    registerGauge(gaugeName, gaugeFunc) {\n        try {\n            // try a gauge function read, we will register it if it succeeds.\n            gaugeFunc();\n            this.allGauges[gaugeName] = gaugeFunc;\n        }\n        catch (e) {\n            this.logger.warn('Statistics', 'Could not collect data for gauge ' + gaugeName\n                + ' , it won\\'t be registered', e);\n            this.allGauges[gaugeName] = () => Statistics.EMPTY_STAT_VALUE;\n        }\n    }\n    addStat(stats, name, value, keyPrefix) {\n        if (stats.length !== 0) {\n            stats.push(Statistics.STAT_SEPARATOR);\n        }\n        if (keyPrefix != null) {\n            stats.push(keyPrefix);\n        }\n        stats.push(name);\n        stats.push(Statistics.KEY_VALUE_SEPARATOR);\n        stats.push(value);\n    }\n    addEmptyStat(stats, name, keyPrefix) {\n        this.addStat(stats, name, Statistics.EMPTY_STAT_VALUE, keyPrefix);\n    }\n    fillMetrics(stats, connection) {\n        this.addStat(stats, 'lastStatisticsCollectionTime', Date.now());\n        this.addStat(stats, 'enterprise', 'false');\n        this.addStat(stats, 'clientType', this.client.getClusterService().getLocalClient().type);\n        this.addStat(stats, 'clientVersion', BuildInfo_1.BuildInfo.getClientVersion());\n        this.addStat(stats, 'clusterConnectionTimestamp', connection.getStartTime());\n        this.addStat(stats, 'clientAddress', connection.getLocalAddress().toString());\n        this.addStat(stats, 'clientName', this.client.getName());\n        for (const gaugeName in this.allGauges) {\n            const gaugeValueFunc = this.allGauges[gaugeName];\n            try {\n                const value = gaugeValueFunc();\n                this.addStat(stats, gaugeName, value);\n            }\n            catch (e) {\n                this.logger.trace('Could not collect data for gauge ' + gaugeName, e);\n            }\n        }\n    }\n    getNameWithPrefix(name) {\n        const escapedName = [Statistics.NEAR_CACHE_CATEGORY_PREFIX];\n        const prefixLen = Statistics.NEAR_CACHE_CATEGORY_PREFIX.length;\n        escapedName.push(name);\n        if (escapedName[prefixLen] === '/') {\n            escapedName.splice(prefixLen, 1);\n        }\n        this.escapeSpecialCharacters(escapedName, prefixLen);\n        return escapedName;\n    }\n    escapeSpecialCharacters(buffer, start) {\n        for (let i = start; i < buffer.length; i++) {\n            const c = buffer[i];\n            if (c === '=' || c === '.' || c === ',' || c === Statistics.ESCAPE_CHAR) {\n                buffer.splice(i, 0, Statistics.ESCAPE_CHAR);\n                i++;\n            }\n        }\n    }\n    addNearCacheStats(stats) {\n        for (const nearCache of this.client.getNearCacheManager().listAllNearCaches()) {\n            const nearCacheNameWithPrefix = this.getNameWithPrefix(nearCache.getName());\n            nearCacheNameWithPrefix.push('.');\n            const nearCacheStats = nearCache.getStatistics();\n            const prefix = nearCacheNameWithPrefix.join('');\n            this.addStat(stats, 'creationTime', nearCacheStats.creationTime, prefix);\n            this.addStat(stats, 'evictions', nearCacheStats.evictedCount, prefix);\n            this.addStat(stats, 'hits', nearCacheStats.hitCount, prefix);\n            this.addEmptyStat(stats, 'lastPersistenceDuration', prefix);\n            this.addEmptyStat(stats, 'lastPersistenceKeyCount', prefix);\n            this.addEmptyStat(stats, 'lastPersistenceTime', prefix);\n            this.addEmptyStat(stats, 'lastPersistenceWrittenBytes', prefix);\n            this.addStat(stats, 'misses', nearCacheStats.missCount, prefix);\n            this.addStat(stats, 'ownedEntryCount', nearCacheStats.entryCount, prefix);\n            this.addStat(stats, 'expirations', nearCacheStats.expiredCount, prefix);\n            this.addEmptyStat(stats, 'ownedEntryMemoryCost', prefix);\n            this.addEmptyStat(stats, 'lastPersistenceFailure', prefix);\n        }\n    }\n}\nexports.Statistics = Statistics;\nStatistics.PERIOD_SECONDS_DEFAULT_VALUE = 3;\nStatistics.ENABLED = 'hazelcast.client.statistics.enabled';\nStatistics.PERIOD_SECONDS = 'hazelcast.client.statistics.period.seconds';\nStatistics.NEAR_CACHE_CATEGORY_PREFIX = 'nc.';\nStatistics.STAT_SEPARATOR = ',';\nStatistics.KEY_VALUE_SEPARATOR = '=';\nStatistics.ESCAPE_CHAR = '\\\\';\nStatistics.EMPTY_STAT_VALUE = '';\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/statistics/Statistics.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js":
/*!********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BitsUtil = void 0;\n/** @internal */\nclass BitsUtil {\n    static writeUInt32(buffer, pos, val, isBigEndian) {\n        if (isBigEndian) {\n            buffer.writeUInt32BE(val, pos);\n        }\n        else {\n            buffer.writeUInt32LE(val, pos);\n        }\n    }\n    static writeUInt16(buffer, pos, val, isBigEndian) {\n        if (isBigEndian) {\n            buffer.writeUInt16BE(val, pos);\n        }\n        else {\n            buffer.writeUInt16LE(val, pos);\n        }\n    }\n    static writeUInt8(buffer, pos, val) {\n        buffer.writeUInt8(val, pos);\n    }\n    static writeInt32(buffer, pos, val, isBigEndian) {\n        if (isBigEndian) {\n            buffer.writeInt32BE(val, pos);\n        }\n        else {\n            buffer.writeInt32LE(val, pos);\n        }\n    }\n    static writeInt16(buffer, pos, val, isBigEndian) {\n        if (isBigEndian) {\n            buffer.writeInt16BE(val, pos);\n        }\n        else {\n            buffer.writeInt16LE(val, pos);\n        }\n    }\n    static writeInt8(buffer, pos, val) {\n        buffer.writeInt8(val, pos);\n    }\n    static writeFloat(buffer, pos, val, isBigEndian) {\n        if (isBigEndian) {\n            buffer.writeFloatBE(val, pos);\n        }\n        else {\n            buffer.writeFloatLE(val, pos);\n        }\n    }\n    static writeDouble(buffer, pos, val, isBigEndian) {\n        if (isBigEndian) {\n            buffer.writeDoubleBE(val, pos);\n        }\n        else {\n            buffer.writeDoubleLE(val, pos);\n        }\n    }\n    static readDouble(buffer, pos, isBigEndian) {\n        if (isBigEndian) {\n            return buffer.readDoubleBE(pos);\n        }\n        else {\n            return buffer.readDoubleLE(pos);\n        }\n    }\n    static readFloat(buffer, pos, isBigEndian) {\n        if (isBigEndian) {\n            return buffer.readFloatBE(pos);\n        }\n        else {\n            return buffer.readFloatLE(pos);\n        }\n    }\n    static readInt8(buffer, pos) {\n        return buffer.readInt8(pos);\n    }\n    static readInt16(buffer, pos, isBigEndian) {\n        if (isBigEndian) {\n            return buffer.readInt16BE(pos);\n        }\n        else {\n            return buffer.readInt16LE(pos);\n        }\n    }\n    static readInt32(buffer, pos, isBigEndian) {\n        if (isBigEndian) {\n            return buffer.readInt32BE(pos);\n        }\n        else {\n            return buffer.readInt32LE(pos);\n        }\n    }\n    static readUInt8(buffer, pos) {\n        return buffer.readUInt8(pos);\n    }\n    static readUInt16(buffer, pos, isBigEndian) {\n        if (isBigEndian) {\n            return buffer.readUInt16BE(pos);\n        }\n        else {\n            return buffer.readUInt16LE(pos);\n        }\n    }\n    static readUInt32(buffer, pos, isBigEndian) {\n        if (isBigEndian) {\n            return buffer.readUInt32BE(pos);\n        }\n        else {\n            return buffer.readUInt32LE(pos);\n        }\n    }\n}\nexports.BitsUtil = BitsUtil;\nBitsUtil.BYTE_SIZE_IN_BYTES = 1;\nBitsUtil.BOOLEAN_SIZE_IN_BYTES = 1;\nBitsUtil.SHORT_SIZE_IN_BYTES = 2;\nBitsUtil.CHAR_SIZE_IN_BYTES = 2;\nBitsUtil.INT_SIZE_IN_BYTES = 4;\nBitsUtil.FLOAT_SIZE_IN_BYTES = 4;\nBitsUtil.LONG_SIZE_IN_BYTES = 8;\nBitsUtil.DOUBLE_SIZE_IN_BYTES = 8;\nBitsUtil.UUID_SIZE_IN_BYTES = BitsUtil.BOOLEAN_SIZE_IN_BYTES + 2 * BitsUtil.LONG_SIZE_IN_BYTES;\nBitsUtil.NULL_ARRAY_LENGTH = -1;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/util/BitsUtil.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/util/IndexUtil.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/util/IndexUtil.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IndexUtil = void 0;\nconst IndexConfig_1 = __webpack_require__(/*! ../config/IndexConfig */ \"../shared/node_modules/hazelcast-client/lib/config/IndexConfig.js\");\nconst IndexType_1 = __webpack_require__(/*! ../config/IndexType */ \"../shared/node_modules/hazelcast-client/lib/config/IndexType.js\");\nconst BitmapIndexOptions_1 = __webpack_require__(/*! ../config/BitmapIndexOptions */ \"../shared/node_modules/hazelcast-client/lib/config/BitmapIndexOptions.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\n/**\n * Maximum number of attributes allowed in the index.\n */\nconst MAX_ATTRIBUTES = 255;\n/**\n * Pattern to stripe away \"this.\" prefix.\n */\nconst THIS_PATTERN = new RegExp('^this\\\\.');\n/** @internal */\nclass IndexUtil {\n    /**\n     * Validates provided index config and normalizes it's name and attribute names.\n     *\n     * @param mapName Name of the map\n     * @param config User-provided index config.\n     * @return Normalized index config.\n     * @throws TypeError If index configuration is invalid.\n     */\n    static validateAndNormalize(mapName, config) {\n        // Validate attributes\n        const originalAttributeNames = config.attributes;\n        if (originalAttributeNames.length === 0) {\n            throw new TypeError('Index must have at least one attribute: ' + config);\n        }\n        if (originalAttributeNames.length > MAX_ATTRIBUTES) {\n            throw new TypeError('Index cannot have more than ' + MAX_ATTRIBUTES + ' attributes: ' + config);\n        }\n        let type = IndexConfig_1.InternalIndexConfig.DEFAULT_TYPE;\n        if (config.type) {\n            type = Util_1.tryGetEnum(IndexType_1.IndexType, config.type);\n        }\n        if (type === IndexType_1.IndexType.BITMAP && originalAttributeNames.length > 1) {\n            throw new TypeError('Composite bitmap indexes are not supported: ' + config);\n        }\n        const normalizedAttributeNames = new Array(originalAttributeNames.length);\n        for (let i = 0; i < originalAttributeNames.length; i++) {\n            let originalAttributeName = originalAttributeNames[i];\n            this.validateAttribute(config.name, originalAttributeName);\n            originalAttributeName = originalAttributeName.trim();\n            const normalizedAttributeName = this.canonicalizeAttribute(originalAttributeName);\n            const existingIdx = normalizedAttributeNames.indexOf(normalizedAttributeName);\n            if (existingIdx !== -1) {\n                const duplicateOriginalAttributeName = originalAttributeNames[existingIdx];\n                if (duplicateOriginalAttributeName === originalAttributeName) {\n                    throw new TypeError('Duplicate attribute name [attributeName= '\n                        + originalAttributeName + ', indexConfig=' + config + ']');\n                }\n                else {\n                    throw new TypeError('Duplicate attribute names [attributeName1='\n                        + duplicateOriginalAttributeName + ', attributeName2='\n                        + originalAttributeName + ', indexConfig=' + config + ']');\n                }\n            }\n            normalizedAttributeNames[i] = normalizedAttributeName;\n        }\n        // Construct final index\n        let name = config.name;\n        if (name != null && name.trim().length === 0) {\n            name = null;\n        }\n        const normalizedConfig = this.buildNormalizedConfig(mapName, type, name, normalizedAttributeNames);\n        if (type === IndexType_1.IndexType.BITMAP) {\n            let uniqueKey = config.bitmapIndexOptions.uniqueKey;\n            this.validateAttribute(config.name, uniqueKey);\n            uniqueKey = this.canonicalizeAttribute(uniqueKey);\n            normalizedConfig.bitmapIndexOptions.uniqueKey = uniqueKey;\n            normalizedConfig.bitmapIndexOptions.uniqueKeyTransformation =\n                Util_1.tryGetEnum(BitmapIndexOptions_1.UniqueKeyTransformation, config.bitmapIndexOptions.uniqueKeyTransformation);\n        }\n        return normalizedConfig;\n    }\n    /**\n     * Validate attribute name.\n     *\n     * @param config Index config.\n     * @param attributeName Attribute name.\n     */\n    static validateAttribute(indexName, attributeName) {\n        if (attributeName == null) {\n            throw new TypeError('Attribute name cannot be null: ' + indexName);\n        }\n        const attributeName0 = attributeName.trim();\n        if (attributeName0.length === 0) {\n            throw new TypeError('Attribute name cannot be empty: ' + indexName);\n        }\n        if (attributeName0.endsWith('.')) {\n            throw new TypeError('Attribute name cannot end with dot [config= ' + indexName\n                + ', attribute=' + attributeName + ']');\n        }\n    }\n    /**\n     * Produces canonical attribute representation by stripping an unnecessary\n     * \"this.\" qualifier from the passed attribute, if any.\n     *\n     * @param attribute the attribute to canonicalize.\n     * @return the canonical attribute representation.\n     */\n    static canonicalizeAttribute(attribute) {\n        return attribute.replace(THIS_PATTERN, '');\n    }\n    static buildNormalizedConfig(mapName, indexType, indexName, normalizedAttributeNames) {\n        const newConfig = new IndexConfig_1.InternalIndexConfig();\n        newConfig.bitmapIndexOptions = new BitmapIndexOptions_1.InternalBitmapIndexOptions();\n        newConfig.type = indexType;\n        let name = indexName == null ? mapName + '_' + this.indexTypeToName(indexType) : null;\n        for (const normalizedAttributeName of normalizedAttributeNames) {\n            this.validateAttribute(indexName, normalizedAttributeName);\n            newConfig.attributes.push(normalizedAttributeName);\n            if (name != null) {\n                name += '_' + normalizedAttributeName;\n            }\n        }\n        if (name != null) {\n            indexName = name;\n        }\n        newConfig.name = indexName;\n        return newConfig;\n    }\n    static indexTypeToName(indexType) {\n        switch (indexType) {\n            case IndexType_1.IndexType.SORTED:\n                return 'sorted';\n            case IndexType_1.IndexType.HASH:\n                return 'hash';\n            case IndexType_1.IndexType.BITMAP:\n                return 'bitmap';\n            default:\n                throw new TypeError('Unsupported index type: ' + indexType);\n        }\n    }\n}\nexports.IndexUtil = IndexUtil;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/util/IndexUtil.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/util/RandomLB.js":
/*!********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/util/RandomLB.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RandomLB = void 0;\nconst LoadBalancer_1 = __webpack_require__(/*! ../core/LoadBalancer */ \"../shared/node_modules/hazelcast-client/lib/core/LoadBalancer.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\n/**\n * A {@link LoadBalancer} that selects a random member to route to.\n * @internal\n */\nclass RandomLB extends LoadBalancer_1.AbstractLoadBalancer {\n    next() {\n        const members = this.getMembers();\n        if (members == null || members.length === 0) {\n            return null;\n        }\n        const index = Util_1.randomInt(members.length);\n        return members[index];\n    }\n}\nexports.RandomLB = RandomLB;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/util/RandomLB.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/util/RoundRobinLB.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/util/RoundRobinLB.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RoundRobinLB = void 0;\nconst LoadBalancer_1 = __webpack_require__(/*! ../core/LoadBalancer */ \"../shared/node_modules/hazelcast-client/lib/core/LoadBalancer.js\");\nconst Util_1 = __webpack_require__(/*! ../util/Util */ \"../shared/node_modules/hazelcast-client/lib/util/Util.js\");\nconst INITIAL_SEED_CAP = 1 << 16;\n/**\n * A {@link LoadBalancer} implementation that relies on using round robin\n * to a next member to send a request to.\n * @internal\n */\nclass RoundRobinLB extends LoadBalancer_1.AbstractLoadBalancer {\n    constructor() {\n        super();\n        this.index = Util_1.randomInt(INITIAL_SEED_CAP);\n    }\n    next() {\n        const members = this.getMembers();\n        if (members == null || members.length === 0) {\n            return null;\n        }\n        const length = members.length;\n        const idx = (this.index++) % length;\n        return members[idx];\n    }\n}\nexports.RoundRobinLB = RoundRobinLB;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/util/RoundRobinLB.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/util/Util.js":
/*!****************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/util/Util.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DeferredPromise = exports.cancelRepetitionTask = exports.scheduleWithRepetition = exports.Task = exports.randomInt = exports.AddressHelper = exports.resolvePath = exports.tryGetEnum = exports.getBooleanOrUndefined = exports.getStringOrUndefined = exports.tryGetString = exports.tryGetArray = exports.tryGetNumber = exports.tryGetBoolean = exports.copyObjectShallow = exports.enumFromString = exports.getType = exports.assertNotNegative = exports.shuffleArray = exports.assertString = exports.assertArray = exports.assertNotNull = void 0;\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst Promise = __webpack_require__(/*! bluebird */ \"../shared/node_modules/bluebird/js/release/bluebird.js\");\nconst Path = __webpack_require__(/*! path */ \"path\");\nconst Address_1 = __webpack_require__(/*! ../core/Address */ \"../shared/node_modules/hazelcast-client/lib/core/Address.js\");\n/** @internal */\nfunction assertNotNull(v) {\n    assert.notEqual(v, null, 'Non null value expected.');\n}\nexports.assertNotNull = assertNotNull;\n/** @internal */\nfunction assertArray(x) {\n    assert(Array.isArray(x), 'Should be array.');\n}\nexports.assertArray = assertArray;\n/** @internal */\nfunction assertString(v) {\n    assert(typeof v === 'string', 'String value expected.');\n}\nexports.assertString = assertString;\n/** @internal */\nfunction shuffleArray(array) {\n    let randomIndex;\n    let temp;\n    for (let i = array.length; i > 1; i--) {\n        randomIndex = Math.floor(Math.random() * i);\n        temp = array[i - 1];\n        array[i - 1] = array[randomIndex];\n        array[randomIndex] = temp;\n    }\n}\nexports.shuffleArray = shuffleArray;\n/** @internal */\nfunction assertNotNegative(v, message = 'The value cannot be negative.') {\n    assert(v >= 0, message);\n}\nexports.assertNotNegative = assertNotNegative;\n/** @internal */\nfunction getType(obj) {\n    assertNotNull(obj);\n    if (Long.isLong(obj)) {\n        return 'long';\n    }\n    if (Buffer.isBuffer(obj)) {\n        return 'buffer';\n    }\n    else {\n        const t = typeof obj;\n        if (t !== 'object') {\n            return t;\n        }\n        else {\n            return ({}).toString.call(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n        }\n    }\n}\nexports.getType = getType;\n/** @internal */\nfunction enumFromString(enumType, value) {\n    return enumType[value];\n}\nexports.enumFromString = enumFromString;\n/** @internal */\nfunction copyObjectShallow(obj) {\n    if (obj === undefined || obj === null) {\n        return obj;\n    }\n    if (typeof obj === 'object') {\n        const newObj = {};\n        for (const prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                newObj[prop] = obj[prop];\n            }\n        }\n        return newObj;\n    }\n    assert(false, 'Object should be undefined or type of object.');\n}\nexports.copyObjectShallow = copyObjectShallow;\n/** @internal */\nfunction tryGetBoolean(val) {\n    if (typeof val === 'boolean') {\n        return val;\n    }\n    else {\n        throw new RangeError(val + ' is not a boolean.');\n    }\n}\nexports.tryGetBoolean = tryGetBoolean;\n/** @internal */\nfunction tryGetNumber(val) {\n    if (typeof val === 'number') {\n        return val;\n    }\n    else {\n        throw new RangeError(val + ' is not a number.');\n    }\n}\nexports.tryGetNumber = tryGetNumber;\n/** @internal */\nfunction tryGetArray(val) {\n    if (Array.isArray(val)) {\n        return val;\n    }\n    else {\n        throw new RangeError(val + ' is not an array.');\n    }\n}\nexports.tryGetArray = tryGetArray;\n/** @internal */\nfunction tryGetString(val) {\n    if (typeof val === 'string') {\n        return val;\n    }\n    else {\n        throw new RangeError(val + ' is not a string.');\n    }\n}\nexports.tryGetString = tryGetString;\n/** @internal */\nfunction getStringOrUndefined(val) {\n    try {\n        return tryGetString(val);\n    }\n    catch (e) {\n        return undefined;\n    }\n}\nexports.getStringOrUndefined = getStringOrUndefined;\n/** @internal */\nfunction getBooleanOrUndefined(val) {\n    try {\n        return tryGetBoolean(val);\n    }\n    catch (e) {\n        return undefined;\n    }\n}\nexports.getBooleanOrUndefined = getBooleanOrUndefined;\n/** @internal */\nfunction tryGetEnum(enumClass, str) {\n    const result = enumClass[str.toUpperCase()];\n    if (result == null) {\n        throw new TypeError(str + ' is not a member of the enum ' + enumClass);\n    }\n    return result;\n}\nexports.tryGetEnum = tryGetEnum;\n/** @internal */\nfunction resolvePath(path) {\n    const basePath = process.cwd();\n    return Path.resolve(basePath, path);\n}\nexports.resolvePath = resolvePath;\n/** @internal */\nclass AddressHelper {\n    static getSocketAddresses(address) {\n        const addressHolder = this.createAddressFromString(address, -1);\n        let possiblePort = addressHolder.port;\n        let maxPortTryCount = 1;\n        if (possiblePort === -1) {\n            maxPortTryCount = AddressHelper.MAX_PORT_TRIES;\n            possiblePort = AddressHelper.INITIAL_FIRST_PORT;\n        }\n        const addresses = [];\n        for (let i = 0; i < maxPortTryCount; i++) {\n            addresses.push(new Address_1.AddressImpl(addressHolder.host, possiblePort + i));\n        }\n        return addresses;\n    }\n    static createAddressFromString(address, defaultPort) {\n        const indexBracketStart = address.indexOf('[');\n        const indexBracketEnd = address.indexOf(']', indexBracketStart);\n        const indexColon = address.indexOf(':');\n        const lastIndexColon = address.lastIndexOf(':');\n        let host;\n        let port = defaultPort;\n        if (indexColon > -1 && lastIndexColon > indexColon) {\n            // IPv6\n            if (indexBracketStart === 0 && indexBracketEnd > indexBracketStart) {\n                host = address.substring(indexBracketStart + 1, indexBracketEnd);\n                if (lastIndexColon === indexBracketEnd + 1) {\n                    port = Number.parseInt(address.substring(lastIndexColon + 1));\n                }\n            }\n            else {\n                host = address;\n            }\n        }\n        else if (indexColon > 0 && indexColon === lastIndexColon) {\n            host = address.substring(0, indexColon);\n            port = Number.parseInt(address.substring(indexColon + 1));\n        }\n        else {\n            host = address;\n        }\n        return new Address_1.AddressImpl(host, port);\n    }\n}\nexports.AddressHelper = AddressHelper;\nAddressHelper.MAX_PORT_TRIES = 3;\nAddressHelper.INITIAL_FIRST_PORT = 5701;\n/**\n * Returns a random integer between 0(inclusive) and `upperBound`(exclusive)\n * Upper bound should be an integer.\n * @param upperBound\n * @returns A random integer between [0-upperBound)\n * @internal\n */\nfunction randomInt(upperBound) {\n    return Math.floor(Math.random() * upperBound);\n}\nexports.randomInt = randomInt;\n/** @internal */\nclass Task {\n}\nexports.Task = Task;\n/** @internal */\nfunction scheduleWithRepetition(callback, initialDelay, periodMillis) {\n    const task = new Task();\n    task.timeoutId = setTimeout(function () {\n        callback();\n        task.intervalId = setInterval(callback, periodMillis);\n    }, initialDelay);\n    return task;\n}\nexports.scheduleWithRepetition = scheduleWithRepetition;\n/** @internal */\nfunction cancelRepetitionTask(task) {\n    if (task.intervalId != null) {\n        clearInterval(task.intervalId);\n    }\n    else if (task.timeoutId != null) {\n        clearTimeout(task.timeoutId);\n    }\n}\nexports.cancelRepetitionTask = cancelRepetitionTask;\n/** @internal */\nfunction DeferredPromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise(function () {\n        resolve = arguments[0];\n        reject = arguments[1];\n    });\n    return {\n        resolve,\n        reject,\n        promise,\n    };\n}\nexports.DeferredPromise = DeferredPromise;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/util/Util.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/lib/util/UuidUtil.js":
/*!********************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/lib/util/UuidUtil.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** @ignore */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UuidUtil = void 0;\nconst Long = __webpack_require__(/*! long */ \"../shared/node_modules/long/src/long.js\");\nconst UUID_1 = __webpack_require__(/*! ../core/UUID */ \"../shared/node_modules/hazelcast-client/lib/core/UUID.js\");\nconst INT_BOUND = 0xFFFFFFFF;\nfunction randomUInt() {\n    return Math.floor(Math.random() * INT_BOUND);\n}\n/** @internal */\nclass UuidUtil {\n    static generate(isUnsigned = true) {\n        const mostS = new Long(randomUInt(), randomUInt(), isUnsigned);\n        const leastS = new Long(randomUInt(), randomUInt(), isUnsigned);\n        return new UUID_1.UUID(mostS, leastS);\n    }\n}\nexports.UuidUtil = UuidUtil;\n\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/lib/util/UuidUtil.js?");

/***/ }),

/***/ "../shared/node_modules/hazelcast-client/package.json":
/*!************************************************************!*\
  !*** ../shared/node_modules/hazelcast-client/package.json ***!
  \************************************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, engines, homepage, keywords, license, main, name, repository, scripts, types, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_from\\\":\\\"hazelcast-client@4.0.0-alpha.1\\\",\\\"_id\\\":\\\"hazelcast-client@4.0.0-alpha.1\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-9n52P957we1H/ugVI71N/hU91BSh+d+3D2ADXx41BfM0Fv1ww/kfyhuquS0V82Wup0+O+uNx/uVtj26g11D/4w==\\\",\\\"_location\\\":\\\"/hazelcast-client\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"version\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"hazelcast-client@4.0.0-alpha.1\\\",\\\"name\\\":\\\"hazelcast-client\\\",\\\"escapedName\\\":\\\"hazelcast-client\\\",\\\"rawSpec\\\":\\\"4.0.0-alpha.1\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"4.0.0-alpha.1\\\"},\\\"_requiredBy\\\":[\\\"#USER\\\",\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/hazelcast-client/-/hazelcast-client-4.0.0-alpha.1.tgz\\\",\\\"_shasum\\\":\\\"789048deddd80d5d38a8781dd676c1c389dcd3a4\\\",\\\"_spec\\\":\\\"hazelcast-client@4.0.0-alpha.1\\\",\\\"_where\\\":\\\"/Users/chi/Programming/Web/streaming-service/packages/shared\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/hazelcast/hazelcast-nodejs-client/issues\\\"},\\\"bundleDependencies\\\":false,\\\"dependencies\\\":{\\\"@types/bluebird\\\":\\\"3.5.32\\\",\\\"@types/long\\\":\\\"4.0.1\\\",\\\"bluebird\\\":\\\"3.7.2\\\",\\\"long\\\":\\\"4.0.0\\\"},\\\"deprecated\\\":false,\\\"description\\\":\\\"Hazelcast - open source In-Memory Data Grid - client for Node.js\\\",\\\"devDependencies\\\":{\\\"@types/node\\\":\\\"^10.17.28\\\",\\\"@typescript-eslint/eslint-plugin\\\":\\\"^3.10.0\\\",\\\"@typescript-eslint/parser\\\":\\\"^3.10.0\\\",\\\"chai\\\":\\\"^4.2.0\\\",\\\"chai-as-promised\\\":\\\"^7.1.1\\\",\\\"eslint\\\":\\\"^7.7.0\\\",\\\"jsonschema\\\":\\\"^1.2.6\\\",\\\"mocha\\\":\\\"^8.1.1\\\",\\\"mocha-junit-reporter\\\":\\\"^2.0.0\\\",\\\"mousse\\\":\\\"^0.3.1\\\",\\\"nyc\\\":\\\"^15.1.0\\\",\\\"rimraf\\\":\\\"^3.0.2\\\",\\\"sinon\\\":\\\"^9.0.3\\\",\\\"thrift\\\":\\\"^0.12.0\\\",\\\"typedoc\\\":\\\"^0.18.0\\\",\\\"typescript\\\":\\\"^3.9.7\\\",\\\"winston\\\":\\\"^3.3.3\\\"},\\\"engines\\\":{\\\"node\\\":\\\">=10\\\"},\\\"homepage\\\":\\\"https://github.com/hazelcast/hazelcast-nodejs-client#readme\\\",\\\"keywords\\\":[\\\"hazelcast\\\",\\\"nodejs\\\",\\\"node\\\",\\\"client\\\",\\\"data\\\",\\\"grid\\\"],\\\"license\\\":\\\"Apache-2.0\\\",\\\"main\\\":\\\"lib/index.js\\\",\\\"name\\\":\\\"hazelcast-client\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/hazelcast/hazelcast-nodejs-client.git\\\"},\\\"scripts\\\":{\\\"clean\\\":\\\"rimraf lib *.jar *.log\\\",\\\"compile\\\":\\\"tsc\\\",\\\"coverage\\\":\\\"rimraf coverage && nyc node_modules/mocha/bin/_mocha -- --recursive --reporter-options mochaFile=report.xml --reporter mocha-junit-reporter\\\",\\\"generate-docs\\\":\\\"typedoc --options typedoc.json\\\",\\\"lint\\\":\\\"eslint --ext .ts .\\\",\\\"precoverage\\\":\\\"node download-remote-controller.js\\\",\\\"pregenerate-docs\\\":\\\"rimraf docs\\\",\\\"pretest\\\":\\\"node download-remote-controller.js\\\",\\\"test\\\":\\\"mocha --recursive\\\",\\\"validate-user-code\\\":\\\"tsc --build test/user_code/tsconfig.json\\\"},\\\"types\\\":\\\"lib/index.d.ts\\\",\\\"version\\\":\\\"4.0.0-alpha.1\\\"}\");\n\n//# sourceURL=webpack:///../shared/node_modules/hazelcast-client/package.json?");

/***/ }),

/***/ "../shared/node_modules/inflight/inflight.js":
/*!***************************************************!*\
  !*** ../shared/node_modules/inflight/inflight.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"../shared/node_modules/wrappy/wrappy.js\")\nvar reqs = Object.create(null)\nvar once = __webpack_require__(/*! once */ \"../shared/node_modules/once/once.js\")\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/inflight/inflight.js?");

/***/ }),

/***/ "../shared/node_modules/inherits/inherits.js":
/*!***************************************************!*\
  !*** ../shared/node_modules/inherits/inherits.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("try {\n  var util = __webpack_require__(/*! util */ \"util\");\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = __webpack_require__(/*! ./inherits_browser.js */ \"../shared/node_modules/inherits/inherits_browser.js\");\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/inherits/inherits.js?");

/***/ }),

/***/ "../shared/node_modules/inherits/inherits_browser.js":
/*!***********************************************************!*\
  !*** ../shared/node_modules/inherits/inherits_browser.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "../shared/node_modules/long/src/long.js":
/*!***********************************************!*\
  !*** ../shared/node_modules/long/src/long.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n\n\n//# sourceURL=webpack:///../shared/node_modules/long/src/long.js?");

/***/ }),

/***/ "../shared/node_modules/minimatch/minimatch.js":
/*!*****************************************************!*\
  !*** ../shared/node_modules/minimatch/minimatch.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = __webpack_require__(/*! path */ \"path\")\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(/*! brace-expansion */ \"../shared/node_modules/brace-expansion/index.js\")\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/minimatch/minimatch.js?");

/***/ }),

/***/ "../shared/node_modules/mkdirp/index.js":
/*!**********************************************!*\
  !*** ../shared/node_modules/mkdirp/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                if (path.dirname(p) === p) return cb(er);\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n\n//# sourceURL=webpack:///../shared/node_modules/mkdirp/index.js?");

/***/ }),

/***/ "../shared/node_modules/mv/index.js":
/*!******************************************!*\
  !*** ../shared/node_modules/mv/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\");\nvar ncp = __webpack_require__(/*! ncp */ \"../shared/node_modules/ncp/lib/ncp.js\").ncp;\nvar path = __webpack_require__(/*! path */ \"path\");\nvar rimraf = __webpack_require__(/*! rimraf */ \"../shared/node_modules/rimraf/rimraf.js\");\nvar mkdirp = __webpack_require__(/*! mkdirp */ \"../shared/node_modules/mkdirp/index.js\");\n\nmodule.exports = mv;\n\nfunction mv(source, dest, options, cb){\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  var shouldMkdirp = !!options.mkdirp;\n  var clobber = options.clobber !== false;\n  var limit = options.limit || 16;\n\n  if (shouldMkdirp) {\n    mkdirs();\n  } else {\n    doRename();\n  }\n\n  function mkdirs() {\n    mkdirp(path.dirname(dest), function(err) {\n      if (err) return cb(err);\n      doRename();\n    });\n  }\n\n  function doRename() {\n    if (clobber) {\n      fs.rename(source, dest, function(err) {\n        if (!err) return cb();\n        if (err.code !== 'EXDEV') return cb(err);\n        moveFileAcrossDevice(source, dest, clobber, limit, cb);\n      });\n    } else {\n      fs.link(source, dest, function(err) {\n        if (err) {\n          if (err.code === 'EXDEV') {\n            moveFileAcrossDevice(source, dest, clobber, limit, cb);\n            return;\n          }\n          if (err.code === 'EISDIR' || err.code === 'EPERM') {\n            moveDirAcrossDevice(source, dest, clobber, limit, cb);\n            return;\n          }\n          cb(err);\n          return;\n        }\n        fs.unlink(source, cb);\n      });\n    }\n  }\n}\n\nfunction moveFileAcrossDevice(source, dest, clobber, limit, cb) {\n  var outFlags = clobber ? 'w' : 'wx';\n  var ins = fs.createReadStream(source);\n  var outs = fs.createWriteStream(dest, {flags: outFlags});\n  ins.on('error', function(err){\n    ins.destroy();\n    outs.destroy();\n    outs.removeListener('close', onClose);\n    if (err.code === 'EISDIR' || err.code === 'EPERM') {\n      moveDirAcrossDevice(source, dest, clobber, limit, cb);\n    } else {\n      cb(err);\n    }\n  });\n  outs.on('error', function(err){\n    ins.destroy();\n    outs.destroy();\n    outs.removeListener('close', onClose);\n    cb(err);\n  });\n  outs.once('close', onClose);\n  ins.pipe(outs);\n  function onClose(){\n    fs.unlink(source, cb);\n  }\n}\n\nfunction moveDirAcrossDevice(source, dest, clobber, limit, cb) {\n  var options = {\n    stopOnErr: true,\n    clobber: false,\n    limit: limit,\n  };\n  if (clobber) {\n    rimraf(dest, { disableGlob: true }, function(err) {\n      if (err) return cb(err);\n      startNcp();\n    });\n  } else {\n    startNcp();\n  }\n  function startNcp() {\n    ncp(source, dest, options, function(errList) {\n      if (errList) return cb(errList[0]);\n      rimraf(source, { disableGlob: true }, cb);\n    });\n  }\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/mv/index.js?");

/***/ }),

/***/ "../shared/node_modules/ncp/lib/ncp.js":
/*!*********************************************!*\
  !*** ../shared/node_modules/ncp/lib/ncp.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\"),\n    path = __webpack_require__(/*! path */ \"path\");\n\nmodule.exports = ncp;\nncp.ncp = ncp;\n\nfunction ncp (source, dest, options, callback) {\n  var cback = callback;\n\n  if (!callback) {\n    cback = options;\n    options = {};\n  }\n\n  var basePath = process.cwd(),\n      currentPath = path.resolve(basePath, source),\n      targetPath = path.resolve(basePath, dest),\n      filter = options.filter,\n      rename = options.rename,\n      transform = options.transform,\n      clobber = options.clobber !== false,\n      modified = options.modified,\n      dereference = options.dereference,\n      errs = null,\n      started = 0,\n      finished = 0,\n      running = 0,\n      limit = options.limit || ncp.limit || 16;\n\n  limit = (limit < 1) ? 1 : (limit > 512) ? 512 : limit;\n\n  startCopy(currentPath);\n  \n  function startCopy(source) {\n    started++;\n    if (filter) {\n      if (filter instanceof RegExp) {\n        if (!filter.test(source)) {\n          return cb(true);\n        }\n      }\n      else if (typeof filter === 'function') {\n        if (!filter(source)) {\n          return cb(true);\n        }\n      }\n    }\n    return getStats(source);\n  }\n\n  function getStats(source) {\n    var stat = dereference ? fs.stat : fs.lstat;\n    if (running >= limit) {\n      return setImmediate(function () {\n        getStats(source);\n      });\n    }\n    running++;\n    stat(source, function (err, stats) {\n      var item = {};\n      if (err) {\n        return onError(err);\n      }\n\n      // We need to get the mode from the stats object and preserve it.\n      item.name = source;\n      item.mode = stats.mode;\n      item.mtime = stats.mtime; //modified time\n      item.atime = stats.atime; //access time\n\n      if (stats.isDirectory()) {\n        return onDir(item);\n      }\n      else if (stats.isFile()) {\n        return onFile(item);\n      }\n      else if (stats.isSymbolicLink()) {\n        // Symlinks don't really need to know about the mode.\n        return onLink(source);\n      }\n    });\n  }\n\n  function onFile(file) {\n    var target = file.name.replace(currentPath, targetPath);\n    if(rename) {\n      target =  rename(target);\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return copyFile(file, target);\n      }\n      if(clobber) {\n        rmFile(target, function () {\n          copyFile(file, target);\n        });\n      }\n      if (modified) {\n        var stat = dereference ? fs.stat : fs.lstat;\n        stat(target, function(err, stats) {\n            //if souce modified time greater to target modified time copy file\n            if (file.mtime.getTime()>stats.mtime.getTime())\n                copyFile(file, target);\n            else return cb();\n        });\n      }\n      else {\n        return cb();\n      }\n    });\n  }\n\n  function copyFile(file, target) {\n    var readStream = fs.createReadStream(file.name),\n        writeStream = fs.createWriteStream(target, { mode: file.mode });\n    \n    readStream.on('error', onError);\n    writeStream.on('error', onError);\n    \n    if(transform) {\n      transform(readStream, writeStream, file);\n    } else {\n      writeStream.on('open', function() {\n        readStream.pipe(writeStream);\n      });\n    }\n    writeStream.once('finish', function() {\n        if (modified) {\n            //target file modified date sync.\n            fs.utimesSync(target, file.atime, file.mtime);\n            cb();\n        }\n        else cb();\n    });\n  }\n\n  function rmFile(file, done) {\n    fs.unlink(file, function (err) {\n      if (err) {\n        return onError(err);\n      }\n      return done();\n    });\n  }\n\n  function onDir(dir) {\n    var target = dir.name.replace(currentPath, targetPath);\n    isWritable(target, function (writable) {\n      if (writable) {\n        return mkDir(dir, target);\n      }\n      copyDir(dir.name);\n    });\n  }\n\n  function mkDir(dir, target) {\n    fs.mkdir(target, dir.mode, function (err) {\n      if (err) {\n        return onError(err);\n      }\n      copyDir(dir.name);\n    });\n  }\n\n  function copyDir(dir) {\n    fs.readdir(dir, function (err, items) {\n      if (err) {\n        return onError(err);\n      }\n      items.forEach(function (item) {\n        startCopy(path.join(dir, item));\n      });\n      return cb();\n    });\n  }\n\n  function onLink(link) {\n    var target = link.replace(currentPath, targetPath);\n    fs.readlink(link, function (err, resolvedPath) {\n      if (err) {\n        return onError(err);\n      }\n      checkLink(resolvedPath, target);\n    });\n  }\n\n  function checkLink(resolvedPath, target) {\n    if (dereference) {\n      resolvedPath = path.resolve(basePath, resolvedPath);\n    }\n    isWritable(target, function (writable) {\n      if (writable) {\n        return makeLink(resolvedPath, target);\n      }\n      fs.readlink(target, function (err, targetDest) {\n        if (err) {\n          return onError(err);\n        }\n        if (dereference) {\n          targetDest = path.resolve(basePath, targetDest);\n        }\n        if (targetDest === resolvedPath) {\n          return cb();\n        }\n        return rmFile(target, function () {\n          makeLink(resolvedPath, target);\n        });\n      });\n    });\n  }\n\n  function makeLink(linkPath, target) {\n    fs.symlink(linkPath, target, function (err) {\n      if (err) {\n        return onError(err);\n      }\n      return cb();\n    });\n  }\n\n  function isWritable(path, done) {\n    fs.lstat(path, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') return done(true);\n        return done(false);\n      }\n      return done(false);\n    });\n  }\n\n  function onError(err) {\n    if (options.stopOnError) {\n      return cback(err);\n    }\n    else if (!errs && options.errs) {\n      errs = fs.createWriteStream(options.errs);\n    }\n    else if (!errs) {\n      errs = [];\n    }\n    if (typeof errs.write === 'undefined') {\n      errs.push(err);\n    }\n    else { \n      errs.write(err.stack + '\\n\\n');\n    }\n    return cb();\n  }\n\n  function cb(skipped) {\n    if (!skipped) running--;\n    finished++;\n    if ((started === finished) && (running === 0)) {\n      if (cback !== undefined ) {\n        return errs ? cback(errs) : cback(null);\n      }\n    }\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///../shared/node_modules/ncp/lib/ncp.js?");

/***/ }),

/***/ "../shared/node_modules/once/once.js":
/*!*******************************************!*\
  !*** ../shared/node_modules/once/once.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var wrappy = __webpack_require__(/*! wrappy */ \"../shared/node_modules/wrappy/wrappy.js\")\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/once/once.js?");

/***/ }),

/***/ "../shared/node_modules/path-is-absolute/index.js":
/*!********************************************************!*\
  !*** ../shared/node_modules/path-is-absolute/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n\n//# sourceURL=webpack:///../shared/node_modules/path-is-absolute/index.js?");

/***/ }),

/***/ "../shared/node_modules/rimraf/rimraf.js":
/*!***********************************************!*\
  !*** ../shared/node_modules/rimraf/rimraf.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = rimraf\nrimraf.sync = rimrafSync\n\nvar assert = __webpack_require__(/*! assert */ \"assert\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar glob = __webpack_require__(/*! glob */ \"../shared/node_modules/glob/glob.js\")\n\nvar globOpts = {\n  nosort: true,\n  nocomment: true,\n  nonegate: true,\n  silent: true\n}\n\n// for EMFILE handling\nvar timeout = 0\n\nvar isWindows = (process.platform === \"win32\")\n\nfunction defaults (options) {\n  var methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(function(m) {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  options.disableGlob = options.disableGlob || false\n}\n\nfunction rimraf (p, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n\n  defaults(options)\n\n  var busyTries = 0\n  var errState = null\n  var n = 0\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  fs.lstat(p, function (er, stat) {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, globOpts, afterGlob)\n  })\n\n  function next (er) {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  function afterGlob (er, results) {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(function (p) {\n      rimraf_(p, options, function CB (er) {\n        if (er) {\n          if (isWindows && (er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            var time = busyTries * 100\n            // try again, with the same exact callback as this one.\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, time)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      })\n    })\n  }\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, function (er, st) {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, function (er) {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er)\n    assert(er instanceof Error)\n\n  options.chmod(p, 666, function (er2) {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, function(er3, stats) {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  assert(p)\n  assert(options)\n  if (er)\n    assert(er instanceof Error)\n\n  try {\n    options.chmodSync(p, 666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  try {\n    var stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, function (er) {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nfunction rmkids(p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, function (er, files) {\n    if (er)\n      return cb(er)\n    var n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    var errState\n    files.forEach(function (f) {\n      rimraf(path.join(p, f), options, function (er) {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  var results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      fs.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, globOpts)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (var i = 0; i < results.length; i++) {\n    var p = results[i]\n\n    try {\n      var st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(function (f) {\n    rimrafSync(path.join(p, f), options)\n  })\n  options.rmdirSync(p, options)\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/rimraf/rimraf.js?");

/***/ }),

/***/ "../shared/node_modules/safe-json-stringify/index.js":
/*!***********************************************************!*\
  !*** ../shared/node_modules/safe-json-stringify/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var hasProp = Object.prototype.hasOwnProperty;\n\nfunction throwsMessage(err) {\n\treturn '[Throws: ' + (err ? err.message : '?') + ']';\n}\n\nfunction safeGetValueFromPropertyOnObject(obj, property) {\n\tif (hasProp.call(obj, property)) {\n\t\ttry {\n\t\t\treturn obj[property];\n\t\t}\n\t\tcatch (err) {\n\t\t\treturn throwsMessage(err);\n\t\t}\n\t}\n\n\treturn obj[property];\n}\n\nfunction ensureProperties(obj) {\n\tvar seen = [ ]; // store references to objects we have seen before\n\n\tfunction visit(obj) {\n\t\tif (obj === null || typeof obj !== 'object') {\n\t\t\treturn obj;\n\t\t}\n\n\t\tif (seen.indexOf(obj) !== -1) {\n\t\t\treturn '[Circular]';\n\t\t}\n\t\tseen.push(obj);\n\n\t\tif (typeof obj.toJSON === 'function') {\n\t\t\ttry {\n\t\t\t\tvar fResult = visit(obj.toJSON());\n\t\t\t\tseen.pop();\n\t\t\t\treturn fResult;\n\t\t\t} catch(err) {\n\t\t\t\treturn throwsMessage(err);\n\t\t\t}\n\t\t}\n\n\t\tif (Array.isArray(obj)) {\n\t\t\tvar aResult = obj.map(visit);\n\t\t\tseen.pop();\n\t\t\treturn aResult;\n\t\t}\n\n\t\tvar result = Object.keys(obj).reduce(function(result, prop) {\n\t\t\t// prevent faulty defined getter properties\n\t\t\tresult[prop] = visit(safeGetValueFromPropertyOnObject(obj, prop));\n\t\t\treturn result;\n\t\t}, {});\n\t\tseen.pop();\n\t\treturn result;\n\t};\n\n\treturn visit(obj);\n}\n\nmodule.exports = function(data, replacer, space) {\n\treturn JSON.stringify(ensureProperties(data), replacer, space);\n}\n\nmodule.exports.ensureProperties = ensureProperties;\n\n\n//# sourceURL=webpack:///../shared/node_modules/safe-json-stringify/index.js?");

/***/ }),

/***/ "../shared/node_modules/wrappy/wrappy.js":
/*!***********************************************!*\
  !*** ../shared/node_modules/wrappy/wrappy.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n\n//# sourceURL=webpack:///../shared/node_modules/wrappy/wrappy.js?");

/***/ }),

/***/ "../shared/src/cache/cacheClientConfig.ts":
/*!************************************************!*\
  !*** ../shared/src/cache/cacheClientConfig.ts ***!
  \************************************************/
/*! exports provided: getClientConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getClientConfig\", function() { return getClientConfig; });\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums */ \"../shared/src/enums.ts\");\n/* harmony import */ var _factory_portableFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./factory/portableFactory */ \"../shared/src/cache/factory/portableFactory.ts\");\n\n\nconst getClientConfig = env => {\n  const cfg = {\n    network: {\n      connectionTimeout: 5000\n    },\n    serialization: {\n      portableFactories: _factory_portableFactory__WEBPACK_IMPORTED_MODULE_1__[\"PORTABLE_FACTORIES\"]\n    }\n  };\n\n  switch (env) {\n    case _enums__WEBPACK_IMPORTED_MODULE_0__[\"Env\"].Prod:\n    case _enums__WEBPACK_IMPORTED_MODULE_0__[\"Env\"].QA:\n      {\n        cfg.network.clusterMembers = ['localhost:5701'];\n        cfg.clusterName = 'jet';\n      }\n      break;\n\n    case _enums__WEBPACK_IMPORTED_MODULE_0__[\"Env\"].Dev:\n      {\n        cfg.network.smartRouting = false;\n        cfg.network.clusterMembers = ['localhost:5701'];\n        cfg.clusterName = 'jet';\n      }\n      break;\n  }\n\n  return cfg;\n};\n\n//# sourceURL=webpack:///../shared/src/cache/cacheClientConfig.ts?");

/***/ }),

/***/ "../shared/src/cache/cacheConstants.ts":
/*!*********************************************!*\
  !*** ../shared/src/cache/cacheConstants.ts ***!
  \*********************************************/
/*! exports provided: FACTORY_ID, CACHE_TYPE_CLASS_ID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FACTORY_ID\", function() { return FACTORY_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CACHE_TYPE_CLASS_ID\", function() { return CACHE_TYPE_CLASS_ID; });\nconst FACTORY_ID = 1;\nconst CACHE_TYPE_CLASS_ID = {\n  ORDER: 1,\n  CLIENT: 2\n};\n\n//# sourceURL=webpack:///../shared/src/cache/cacheConstants.ts?");

/***/ }),

/***/ "../shared/src/cache/cacher.ts":
/*!*************************************!*\
  !*** ../shared/src/cache/cacher.ts ***!
  \*************************************/
/*! exports provided: Cacher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cacher\", function() { return Cacher; });\n/* harmony import */ var hazelcast_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hazelcast-client */ \"../shared/node_modules/hazelcast-client/lib/index.js\");\n/* harmony import */ var hazelcast_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hazelcast_client__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _cacheClientConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cacheClientConfig */ \"../shared/src/cache/cacheClientConfig.ts\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logger */ \"../shared/src/logger.ts\");\n\n\n\nclass Cacher {}\nCacher.client = null;\n\nCacher.getClient = async env => {\n  if (Cacher.client === null) {\n    Cacher.client = await hazelcast_client__WEBPACK_IMPORTED_MODULE_0__[\"Client\"].newHazelcastClient(Object(_cacheClientConfig__WEBPACK_IMPORTED_MODULE_1__[\"getClientConfig\"])(env));\n    _logger__WEBPACK_IMPORTED_MODULE_2__[\"log\"].info('Hazelcast client initialized');\n  }\n\n  return Cacher.client;\n};\n\nCacher.getMap = async (env, mapName) => {\n  try {\n    if (mapName.length > 0) {\n      const instance = await Cacher.getClient(env);\n      const map = await instance.getMap(mapName);\n      return map;\n    }\n\n    return null;\n  } catch (err) {\n    _logger__WEBPACK_IMPORTED_MODULE_2__[\"log\"].error(err);\n    return null;\n  }\n};\n\nCacher.getValues = async (env, mapName, filter) => {\n  try {\n    if (mapName.length > 0) {\n      const map = await Cacher.getMap(env, mapName);\n      const values = filter.length > 0 ? await map.valuesWithPredicate(hazelcast_client__WEBPACK_IMPORTED_MODULE_0__[\"Predicates\"].sql(filter)) : await map.values();\n      const results = values.toArray(); // log.info(\"results\", results)\n\n      return results.map(i => i.toObject());\n    }\n\n    return [];\n  } catch (err) {\n    _logger__WEBPACK_IMPORTED_MODULE_2__[\"log\"].error(err);\n    return [];\n  }\n};\n\n//# sourceURL=webpack:///../shared/src/cache/cacher.ts?");

/***/ }),

/***/ "../shared/src/cache/factory/base.ts":
/*!*******************************************!*\
  !*** ../shared/src/cache/factory/base.ts ***!
  \*******************************************/
/*! exports provided: BaseType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseType\", function() { return BaseType; });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../logger */ \"../shared/src/logger.ts\");\n\nclass BaseType {\n  constructor() {\n    this.isValidField = fieldName => {\n      // @ts-ignore\n      const field = this[fieldName];\n      const blacklistFields = ['factoryId', 'classId'];\n      return typeof field !== 'function' && !blacklistFields.includes(fieldName);\n    };\n\n    this.isPortableField = fieldName => {\n      // @ts-ignore\n      return BaseType.isPrototypeOf(this[fieldName]) || this[fieldName] instanceof BaseType;\n    };\n\n    this.toObject = () => {\n      const obj = {};\n\n      for (const key of Object.keys(this)) {\n        if (this.isValidField(key)) {\n          // @ts-ignore\n          const field = this[key];\n\n          if (this.isPortableField(key)) {\n            obj[key] = field.toObject();\n          } else {\n            obj[key] = field;\n          }\n        }\n      }\n\n      return obj;\n    };\n\n    this.readPortable = input => {\n      for (const key of Object.keys(this)) {\n        if (this.isValidField(key)) {\n          if (this.isPortableField(key)) {\n            _logger__WEBPACK_IMPORTED_MODULE_0__[\"log\"].info(\"read key\", key); // @ts-ignore\n\n            this[key] = input.readPortable(key);\n          } else {\n            // @ts-ignore\n            this[key] = input.readUTF(key);\n          }\n        }\n      }\n    };\n\n    this.writePortable = output => {\n      for (const key of Object.keys(this)) {\n        if (this.isValidField(key)) {\n          if (this.isPortableField(key)) {\n            // @ts-ignore\n            output.writePortable(key, this[key]);\n          } else {\n            // @ts-ignore\n            output.writeUTF(key, this[key]);\n          }\n        }\n      }\n    };\n  }\n\n}\n\n//# sourceURL=webpack:///../shared/src/cache/factory/base.ts?");

/***/ }),

/***/ "../shared/src/cache/factory/client.ts":
/*!*********************************************!*\
  !*** ../shared/src/cache/factory/client.ts ***!
  \*********************************************/
/*! exports provided: Client */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Client\", function() { return Client; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"../shared/src/cache/factory/base.ts\");\n/* harmony import */ var _cacheConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cacheConstants */ \"../shared/src/cache/cacheConstants.ts\");\n\n\nclass Client extends _base__WEBPACK_IMPORTED_MODULE_0__[\"BaseType\"] {\n  constructor(...args) {\n    super(...args);\n    this.factoryId = _cacheConstants__WEBPACK_IMPORTED_MODULE_1__[\"FACTORY_ID\"];\n    this.classId = _cacheConstants__WEBPACK_IMPORTED_MODULE_1__[\"CACHE_TYPE_CLASS_ID\"].CLIENT;\n    this.id = '';\n    this.name = '';\n  }\n\n}\n\n//# sourceURL=webpack:///../shared/src/cache/factory/client.ts?");

/***/ }),

/***/ "../shared/src/cache/factory/order.ts":
/*!********************************************!*\
  !*** ../shared/src/cache/factory/order.ts ***!
  \********************************************/
/*! exports provided: Order */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Order\", function() { return Order; });\n/* harmony import */ var _cacheConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cacheConstants */ \"../shared/src/cache/cacheConstants.ts\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"../shared/src/cache/factory/base.ts\");\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./client */ \"../shared/src/cache/factory/client.ts\");\n\n\n\nclass Order extends _base__WEBPACK_IMPORTED_MODULE_1__[\"BaseType\"] {\n  constructor(...args) {\n    super(...args);\n    this.factoryId = _cacheConstants__WEBPACK_IMPORTED_MODULE_0__[\"FACTORY_ID\"];\n    this.classId = _cacheConstants__WEBPACK_IMPORTED_MODULE_0__[\"CACHE_TYPE_CLASS_ID\"].ORDER;\n    this.city = \"\";\n    this.weather = \"\";\n    this.country = \"\";\n    this.client = new _client__WEBPACK_IMPORTED_MODULE_2__[\"Client\"]();\n  }\n\n}\n\n//# sourceURL=webpack:///../shared/src/cache/factory/order.ts?");

/***/ }),

/***/ "../shared/src/cache/factory/portableFactory.ts":
/*!******************************************************!*\
  !*** ../shared/src/cache/factory/portableFactory.ts ***!
  \******************************************************/
/*! exports provided: CachePortableFactory, PORTABLE_FACTORIES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CachePortableFactory\", function() { return CachePortableFactory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PORTABLE_FACTORIES\", function() { return PORTABLE_FACTORIES; });\n/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./order */ \"../shared/src/cache/factory/order.ts\");\n/* harmony import */ var _cacheConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cacheConstants */ \"../shared/src/cache/cacheConstants.ts\");\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./client */ \"../shared/src/cache/factory/client.ts\");\n\n\n\nconst CLASS_ID_TO_TYPE = {\n  [_cacheConstants__WEBPACK_IMPORTED_MODULE_1__[\"CACHE_TYPE_CLASS_ID\"].ORDER]: _order__WEBPACK_IMPORTED_MODULE_0__[\"Order\"],\n  [_cacheConstants__WEBPACK_IMPORTED_MODULE_1__[\"CACHE_TYPE_CLASS_ID\"].CLIENT]: _client__WEBPACK_IMPORTED_MODULE_2__[\"Client\"]\n};\nconst CachePortableFactory = classId => {\n  return CLASS_ID_TO_TYPE[classId] ? new CLASS_ID_TO_TYPE[classId]() : null;\n};\nconst PORTABLE_FACTORIES = {\n  [_cacheConstants__WEBPACK_IMPORTED_MODULE_1__[\"FACTORY_ID\"]]: CachePortableFactory\n};\n\n//# sourceURL=webpack:///../shared/src/cache/factory/portableFactory.ts?");

/***/ }),

/***/ "../shared/src/enums.ts":
/*!******************************!*\
  !*** ../shared/src/enums.ts ***!
  \******************************/
/*! exports provided: Env, WsResponseType, WsRequestType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Env\", function() { return Env; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WsResponseType\", function() { return WsResponseType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WsRequestType\", function() { return WsRequestType; });\nlet Env;\n\n(function (Env) {\n  Env[\"Prod\"] = \"prod\";\n  Env[\"QA\"] = \"qa\";\n  Env[\"Dev\"] = \"dev\";\n})(Env || (Env = {}));\n\nlet WsResponseType;\n\n(function (WsResponseType) {\n  WsResponseType[\"InitData\"] = \"InitData\";\n  WsResponseType[\"DeltaData\"] = \"DeltaData\";\n  WsResponseType[\"Notificaiton\"] = \"Notification\";\n})(WsResponseType || (WsResponseType = {}));\n\nlet WsRequestType;\n\n(function (WsRequestType) {\n  WsRequestType[\"None\"] = \"None\";\n  WsRequestType[\"Subscribe\"] = \"Subscribe\";\n  WsRequestType[\"Query\"] = \"Query\";\n})(WsRequestType || (WsRequestType = {}));\n\n//# sourceURL=webpack:///../shared/src/enums.ts?");

/***/ }),

/***/ "../shared/src/logger.ts":
/*!*******************************!*\
  !*** ../shared/src/logger.ts ***!
  \*******************************/
/*! exports provided: log, childLog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"childLog\", function() { return childLog; });\n/* harmony import */ var bunyan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bunyan */ \"../shared/node_modules/bunyan/lib/bunyan.js\");\n/* harmony import */ var bunyan__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bunyan__WEBPACK_IMPORTED_MODULE_0__);\n\nconst log = bunyan__WEBPACK_IMPORTED_MODULE_0__[\"createLogger\"]({\n  name: \"next-app\"\n});\nconst childLog = componentName => {\n  return log.child({\n    componentName\n  });\n};\n\n//# sourceURL=webpack:///../shared/src/logger.ts?");

/***/ }),

/***/ "./node_modules/bufferutil/fallback.js":
/*!*********************************************!*\
  !*** ./node_modules/bufferutil/fallback.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nconst mask = (source, mask, output, offset, length) => {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n};\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nconst unmask = (buffer, mask) => {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n};\n\nmodule.exports = { mask, unmask };\n\n\n//# sourceURL=webpack:///./node_modules/bufferutil/fallback.js?");

/***/ }),

/***/ "./node_modules/bufferutil/index.js":
/*!******************************************!*\
  !*** ./node_modules/bufferutil/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"./node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"./node_modules/bufferutil/fallback.js\");\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./node_modules/bufferutil/index.js?");

/***/ }),

/***/ "./node_modules/node-gyp-build/index.js":
/*!**********************************************!*\
  !*** ./node_modules/node-gyp-build/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fs = __webpack_require__(/*! fs */ \"fs\")\nvar path = __webpack_require__(/*! path */ \"path\")\nvar os = __webpack_require__(/*! os */ \"os\")\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire =  true ? require : undefined // eslint-disable-line\n\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = os.arch()\nvar platform = os.platform()\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n  if (release) return release\n\n  var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n  if (debug) return debug\n\n  var prebuild = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchPrebuild)\n  if (prebuild) return prebuild\n\n  var napiRuntime = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapiRuntime)\n  if (napiRuntime) return napiRuntime\n\n  var napi = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapi)\n  if (napi) return napi\n\n  throw new Error('No native build was found for runtime=' + runtime + ' abi=' + abi + ' platform=' + platform + ' arch=' + arch)\n}\n\nfunction getFirst (dir, filter) {\n  try {\n    var files = fs.readdirSync(dir).filter(filter)\n    return files[0] && path.join(dir, files[0])\n  } catch (err) {\n    return null\n  }\n}\n\nfunction matchNapiRuntime (name) {\n  return name === runtime + '-napi.node'\n}\n\nfunction matchNapi (name) {\n  return name === 'node-napi.node'\n}\n\nfunction matchPrebuild (name) {\n  var parts = name.split('-')\n  return parts[0] === runtime && parts[1] === abi + '.node'\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\n\n//# sourceURL=webpack:///./node_modules/node-gyp-build/index.js?");

/***/ }),

/***/ "./node_modules/utf-8-validate/fallback.js":
/*!*************************************************!*\
  !*** ./node_modules/utf-8-validate/fallback.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nconst isValidUTF8 = (buf) => {\n  var len = buf.length;\n  var i = 0;\n\n  while (i < len) {\n    if (buf[i] < 0x80) {  // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0  // overlong\n      ) {\n        return false;\n      } else {\n        i += 2;\n      }\n    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong\n        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0     // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      } else {\n        i += 3;\n      }\n    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong\n        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF\n      ) {\n        return false;\n      } else {\n        i += 4;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = isValidUTF8;\n\n\n//# sourceURL=webpack:///./node_modules/utf-8-validate/fallback.js?");

/***/ }),

/***/ "./node_modules/utf-8-validate/index.js":
/*!**********************************************!*\
  !*** ./node_modules/utf-8-validate/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\n\ntry {\n  module.exports = __webpack_require__(/*! node-gyp-build */ \"./node_modules/node-gyp-build/index.js\")(__dirname);\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./fallback */ \"./node_modules/utf-8-validate/fallback.js\");\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./node_modules/utf-8-validate/index.js?");

/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"./node_modules/ws/lib/websocket.js\");\n\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"./node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"./node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"./node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"./node_modules/ws/lib/sender.js\");\n\nmodule.exports = WebSocket;\n\n\n//# sourceURL=webpack:///./node_modules/ws/index.js?");

/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (let i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = __webpack_require__(/*! bufferutil */ \"./node_modules/bufferutil/index.js\");\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bu.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bu.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/buffer-util.js?");

/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  EMPTY_BUFFER: Buffer.alloc(0),\n  NOOP: () => {}\n};\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/constants.js?");

/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Class representing an event.\n *\n * @private\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */\n  constructor(type, target) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(data, target) {\n    super('message', target);\n\n    this.data = data;\n  }\n}\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(code, reason, target) {\n    super('close', target);\n\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n}\n\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(target) {\n    super('open', target);\n  }\n}\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n * @private\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {Object} error The error that generated this event\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(error, target) {\n    super('error', target);\n\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} options An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} options.once A `Boolean`` indicating that the listener\n   *     should be invoked at most once after being added. If `true`, the\n   *     listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage(data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose(code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError(error) {\n      listener.call(this, new ErrorEvent(error, this));\n    }\n\n    function onOpen() {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    const method = options && options.once ? 'once' : 'on';\n\n    if (type === 'message') {\n      onMessage._listener = listener;\n      this[method](type, onMessage);\n    } else if (type === 'close') {\n      onClose._listener = listener;\n      this[method](type, onClose);\n    } else if (type === 'error') {\n      onError._listener = listener;\n      this[method](type, onError);\n    } else if (type === 'open') {\n      onOpen._listener = listener;\n      this[method](type, onOpen);\n    } else {\n      this[method](type, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener(type, listener) {\n    const listeners = this.listeners(type);\n\n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(type, listeners[i]);\n      }\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/event-target.js?");

/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n\n  if (header === undefined || header === '') return offers;\n\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/extension.js?");

/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} concurrency The maximum number of jobs allowed to run\n   *     concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/limiter.js?");

/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"./node_modules/ws/lib/limiter.js\");\nconst { kStatusCode, NOOP } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the\n      // `zlib.DeflateRaw` instance is closed while data is being processed.\n      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong\n      // time due to an abnormal WebSocket closure.\n      //\n      this._deflate.on('error', NOOP);\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/permessage-deflate.js?");

/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends stream.Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {String} binaryType The type for binary data\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Boolean} isServer Specifies whether to operate in client or server\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(binaryType, extensions, isServer, maxPayload) {\n    super();\n\n    this._binaryType = binaryType || BINARY_TYPES[0];\n    this[kWebSocket] = undefined;\n    this._extensions = extensions || {};\n    this._isServer = !!isServer;\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002);\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002);\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(RangeError, 'MASK must be set', true, 1002);\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(RangeError, 'MASK must be clear', true, 1002);\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its lenght is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(RangeError, 'Max payload size exceeded', false, 1009)\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('message', buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, '');\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002);\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002);\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('conclude', code, buf.toString());\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {(Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err[kStatusCode] = statusCode;\n  return err;\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/receiver.js?");

/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst mask = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    let offset = options.mask ? 6 : 2;\n    let payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    randomFillSync(mask, 0, 4);\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask,\n        readOnly: false\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(buf, {\n          fin: options.fin,\n          rsv1: false,\n          opcode,\n          mask: options.mask,\n          readOnly: toBuffer.readOnly\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += data.length;\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const callback = this._queue[i][4];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= data.length;\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/sender.js?");

/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {stream.Duplex} The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} options The options for the `Duplex` constructor\n * @return {stream.Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let resumeOnReceiverDrain = true;\n\n  function receiverOnDrain() {\n    if (resumeOnReceiverDrain) ws._socket.resume();\n  }\n\n  if (ws.readyState === ws.CONNECTING) {\n    ws.once('open', function open() {\n      ws._receiver.removeAllListeners('drain');\n      ws._receiver.on('drain', receiverOnDrain);\n    });\n  } else {\n    ws._receiver.removeAllListeners('drain');\n    ws._receiver.on('drain', receiverOnDrain);\n  }\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg) {\n    if (!duplex.push(msg)) {\n      resumeOnReceiverDrain = false;\n      ws._socket.pause();\n    }\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {\n      resumeOnReceiverDrain = true;\n      if (!ws._receiver._writableState.needDrain) ws._socket.resume();\n    }\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/stream.js?");

/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\ntry {\n  const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"./node_modules/utf-8-validate/index.js\");\n\n  exports.isValidUTF8 =\n    typeof isValidUTF8 === 'object'\n      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n      : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n  exports.isValidUTF8 = () => true;\n}\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nexports.isValidStatusCode = (code) => {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n};\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/validation.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { createServer, STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"./node_modules/ws/lib/websocket.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} options.backlog The maximum length of the queue of pending\n   *     connections\n   * @param {Boolean} options.clientTracking Specifies whether or not to track\n   *     clients\n   * @param {Function} options.handleProtocols A hook to handle protocols\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {String} options.path Accept only connections matching this path\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n   *     permessage-deflate\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient A hook to reject connections\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    };\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError(\n        'One of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = createServer((req, res) => {\n        const body = STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, (ws) => {\n            this.emit('connection', ws, req);\n          });\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(cb) {\n    if (cb) this.once('close', cb);\n\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) {\n        server.close(() => this.emit('close'));\n        return;\n      }\n    }\n\n    process.nextTick(emitClose, this);\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key'].trim()\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(key, extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(key, extensions, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(key, extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new WebSocket(null);\n    let protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.trim().split(/ *, */);\n\n      //\n      // Optionally call external protocol selection handler.\n      //\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws.protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-Type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n\n    socket.write(\n      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/websocket-server.js?");

/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"./node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"./node_modules/ws/lib/sender.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { addEventListener, removeEventListener } = __webpack_require__(/*! ./event-target */ \"./node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|url.URL)} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = '';\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._closeCode = 1006;\n    this._extensions = {};\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  get CONNECTING() {\n    return WebSocket.CONNECTING;\n  }\n  get CLOSING() {\n    return WebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return WebSocket.CLOSED;\n  }\n  get OPEN() {\n    return WebSocket.OPEN;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} maxPayload The maximum allowed message size\n   * @private\n   */\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(\n      this._binaryType,\n      this._extensions,\n      this._isServer,\n      maxPayload\n    );\n\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this.readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this.readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived) this._socket.end();\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this.readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\nreadyStates.forEach((readyState, i) => {\n  WebSocket[readyState] = i;\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get() {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set(listener) {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|url.URL)} address The URL to which to connect\n * @param {String} protocols The subprotocols\n * @param {Object} options Connection options\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n *     permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the\n *     handshake request\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`\n *     header\n * @param {String} options.origin Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {Boolean} options.followRedirects Whether or not to follow redirects\n * @param {Number} options.maxRedirects The maximum number of redirects allowed\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket.url = address.href;\n  } else {\n    parsedUrl = new URL(address);\n    websocket.url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${websocket.url}`);\n  }\n\n  const isSecure =\n    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (websocket._req.aborted) return;\n\n    req = websocket._req = null;\n    websocket.readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      const addr = new URL(location, address);\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    let protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const extensions = parse(res.headers['sec-websocket-extensions']);\n\n        if (extensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          websocket._extensions[\n            PerMessageDeflate.extensionName\n          ] = perMessageDeflate;\n        }\n      } catch (err) {\n        abortHandshake(\n          websocket,\n          socket,\n          'Invalid Sec-WebSocket-Extensions header'\n        );\n        return;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n *     socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket.readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} data The data to send\n * @param {Function} cb Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n  websocket._socket.resume();\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._closeCode = err[kStatusCode];\n  websocket.emit('error', err);\n  websocket._socket.destroy();\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('end', socketOnEnd);\n\n  websocket.readyState = WebSocket.CLOSING;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk and emitted synchronously in a single\n  // `'data'` event.\n  //\n  websocket._socket.read();\n  websocket._receiver.end();\n\n  this.removeListener('data', socketOnData);\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket.readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ws/lib/websocket.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: start */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"start\", function() { return start; });\n/* harmony import */ var _wsServer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wsServer */ \"./src/wsServer.ts\");\n\nconst start = () => {\n  const server = new _wsServer__WEBPACK_IMPORTED_MODULE_0__[\"WsServer\"]();\n};\nstart();\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/socket.ts":
/*!***********************!*\
  !*** ./src/socket.ts ***!
  \***********************/
/*! exports provided: Socket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Socket\", function() { return Socket; });\n/* harmony import */ var shared_src_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shared/src/logger */ \"../shared/src/logger.ts\");\n/* harmony import */ var shared_src_cache_cacher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/src/cache/cacher */ \"../shared/src/cache/cacher.ts\");\n/* harmony import */ var shared_src_enums__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shared/src/enums */ \"../shared/src/enums.ts\");\n\n\n\nclass Socket {\n  constructor(ws) {\n    this.log = Object(shared_src_logger__WEBPACK_IMPORTED_MODULE_0__[\"childLog\"])(Socket.name);\n    this.id = void 0;\n    this.socket = void 0;\n    this.mapSubscriptions = {};\n\n    this.onClose = async (code, reason) => {\n      this.log.warn(\"one connection closed\", code, reason);\n      await this.clearAllListeners();\n    };\n\n    this.onError = async err => {\n      this.log.error(err);\n      await this.clearAllListeners();\n    };\n\n    this.clearAllListeners = async () => {\n      for (const map in this.mapSubscriptions) {\n        await this.clearMapListeners(map);\n      }\n    };\n\n    this.clearMapListeners = async mapName => {\n      const listenIds = this.mapSubscriptions[mapName];\n\n      if (listenIds && listenIds.length > 0) {\n        this.log.info(\"clear listeners in map\", mapName);\n        const map = await shared_src_cache_cacher__WEBPACK_IMPORTED_MODULE_1__[\"Cacher\"].getMap(shared_src_enums__WEBPACK_IMPORTED_MODULE_2__[\"Env\"].Dev, mapName);\n\n        for (const id of listenIds) {\n          await map.removeEntryListener(id);\n        }\n      }\n\n      this.mapSubscriptions[mapName] = [];\n    };\n\n    this.messageHandler = async message => {\n      let req = JSON.parse(message);\n      this.log.info(req);\n\n      if (req.action === shared_src_enums__WEBPACK_IMPORTED_MODULE_2__[\"WsRequestType\"].Subscribe) {\n        this.log.info(req);\n        this.clearAllListeners();\n        const map = await shared_src_cache_cacher__WEBPACK_IMPORTED_MODULE_1__[\"Cacher\"].getMap(shared_src_enums__WEBPACK_IMPORTED_MODULE_2__[\"Env\"].Dev, req.map);\n        const listenId = await map.addEntryListener({\n          added: this.onEntryAdded\n        }, undefined, true);\n\n        if (!this.mapSubscriptions[req.map]) {\n          this.mapSubscriptions[req.map] = [];\n        }\n\n        this.mapSubscriptions[req.map].push(listenId);\n        const values = await shared_src_cache_cacher__WEBPACK_IMPORTED_MODULE_1__[\"Cacher\"].getValues(shared_src_enums__WEBPACK_IMPORTED_MODULE_2__[\"Env\"].Dev, req.map, req.filter);\n        this.send(shared_src_enums__WEBPACK_IMPORTED_MODULE_2__[\"WsResponseType\"].InitData, values);\n      }\n    };\n\n    this.onEntryAdded = evt => {\n      const newValue = evt.value;\n      this.log.info(newValue);\n      this.send(shared_src_enums__WEBPACK_IMPORTED_MODULE_2__[\"WsResponseType\"].DeltaData, [newValue]);\n    };\n\n    this.send = (type, data) => {\n      this.socket.send(JSON.stringify({\n        type,\n        data\n      }));\n    };\n\n    this.id = `${Math.random() * 100000000}`;\n    this.socket = ws;\n    this.socket.on(\"message\", this.messageHandler);\n    this.socket.on(\"close\", this.onClose);\n    this.socket.on(\"error\", this.onError);\n  }\n\n}\n\n//# sourceURL=webpack:///./src/socket.ts?");

/***/ }),

/***/ "./src/wsServer.ts":
/*!*************************!*\
  !*** ./src/wsServer.ts ***!
  \*************************/
/*! exports provided: WsServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WsServer\", function() { return WsServer; });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"./node_modules/ws/index.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_src_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/src/logger */ \"../shared/src/logger.ts\");\n/* harmony import */ var _socket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./socket */ \"./src/socket.ts\");\n\n\n\nclass WsServer {\n  constructor() {\n    this.wss = void 0;\n    this.socketList = void 0;\n    this.log = Object(shared_src_logger__WEBPACK_IMPORTED_MODULE_1__[\"childLog\"])(WsServer.name);\n\n    this.initServer = () => {\n      this.wss = new ws__WEBPACK_IMPORTED_MODULE_0__[\"Server\"]({\n        port: WsServer.port\n      });\n      this.wss.on(\"connection\", this.onConnect);\n      this.log.info(\"websocket server started at port\", WsServer.port);\n    };\n\n    this.onConnect = (socket, request) => {\n      this.log.info(\"Received a connection\");\n      new _socket__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"](socket);\n    };\n\n    this.initServer();\n  }\n\n}\nWsServer.port = 9999;\n\n//# sourceURL=webpack:///./src/wsServer.ts?");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");\n\n//# sourceURL=webpack:///external_%22assert%22?");

/***/ }),

/***/ "async_hooks":
/*!******************************!*\
  !*** external "async_hooks" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"async_hooks\");\n\n//# sourceURL=webpack:///external_%22async_hooks%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack:///external_%22http%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=webpack:///external_%22https%22?");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");\n\n//# sourceURL=webpack:///external_%22net%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack:///external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=webpack:///external_%22stream%22?");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tls\");\n\n//# sourceURL=webpack:///external_%22tls%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack:///external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");\n\n//# sourceURL=webpack:///external_%22zlib%22?");

/***/ })

/******/ });